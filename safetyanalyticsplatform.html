<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Safety Analytics Platform - Amazon WHS Austria | Developed by Erwin Esener @eeesener</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="assets/modern.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" crossorigin="anonymous" referrerpolicy="no-referrer" />
    <script type="module" src="assets/modern.js" defer></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.0/papaparse.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/4.4.0/chart.umd.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.31/jspdf.plugin.autotable.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <style>
        :root {
            --amazon-orange: #FF9900;
            --amazon-orange-dark: #e88600;
            --amazon-dark: #232F3E;
            --amazon-blue: #232F3E;
            --amazon-blue-dark: #37475A;
            --amazon-yellow: #FFD814;
            --success: #4CAF50;
            --warning: #FFC107;
            --danger: #FF5722;
            --critical: #B71C1C;
            --bg-primary: #ffffff;
            --bg-secondary: #f5f5f5;
            --text-primary: #212121;
            --text-secondary: #757575;
            --shadow: rgba(0,0,0,0.08);
            --shadow-hover: rgba(0,0,0,0.12);
            --border-radius: 8px;
            --transition: all 0.2s ease;
            --spacing-xs: 0.25rem;
            --spacing-sm: 0.5rem;
            --spacing-md: 1rem;
            --spacing-lg: 1.5rem;
            --spacing-xl: 2rem;
        }

        [data-theme="dark"] {
            --bg-primary: #1a1a1a;
            --bg-secondary: #2d2d2d;
            --text-primary: #ffffff;
            --text-secondary: #b0b0b0;
            --shadow: rgba(255,255,255,0.05);
            --shadow-hover: rgba(255,255,255,0.1);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Amazon Ember', sans-serif;
            background-color: var(--bg-secondary);
            color: var(--text-primary);
            line-height: 1.5;
            transition: var(--transition);
        }

        /* Compact Header */
        .header {
            background: linear-gradient(90deg, var(--amazon-blue) 0%, var(--amazon-blue-dark) 100%);
            color: white;
            padding: 0.75rem 0;
            position: sticky;
            top: 0;
            z-index: 100;
            box-shadow: 0 2px 8px var(--shadow);
        }

        .header-content {
            max-width: 1400px;
            margin: 0 auto;
            padding: 0 var(--spacing-md);
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: var(--spacing-md);
        }

        .header-title {
            display: flex;
            align-items: center;
            gap: var(--spacing-sm);
        }

        .amazon-logo {
            height: 32px;
            display: flex;
            align-items: center;
            font-weight: bold;
            font-size: 1.5rem;
            color: var(--amazon-orange);
        }

        .header h1 {
            font-size: 1.25rem;
            font-weight: 400;
            display: flex;
            align-items: center;
            gap: var(--spacing-sm);
        }

        .header-subtitle {
            font-size: 0.85rem;
            opacity: 0.9;
            display: flex;
            align-items: center;
            gap: var(--spacing-xs);
        }

        .header-actions {
            display: flex;
            gap: var(--spacing-sm);
            align-items: center;
        }

        /* Mode Toggle */
        .mode-toggle {
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 20px;
            padding: 0.4rem 0.8rem;
            color: white;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: var(--spacing-xs);
            transition: var(--transition);
            font-size: 0.85rem;
        }

        .mode-toggle:hover {
            background: rgba(255,255,255,0.2);
        }

        /* Compact Navigation */
        .nav-container {
            background: var(--bg-primary);
            box-shadow: 0 1px 4px var(--shadow);
            position: sticky;
            top: 56px;
            z-index: 90;
        }

        .nav-tabs {
            max-width: 1400px;
            margin: 0 auto;
            padding: 0 var(--spacing-md);
            display: flex;
            gap: 0;
            overflow-x: auto;
            scrollbar-width: thin;
        }

        .nav-tab {
            padding: 0.6rem 1.2rem;
            cursor: pointer;
            transition: var(--transition);
            white-space: nowrap;
            font-weight: 500;
            font-size: 0.9rem;
            position: relative;
            background: transparent;
            color: var(--text-secondary);
            border-bottom: 3px solid transparent;
        }

        .nav-tab .notification-badge {
            position: absolute;
            top: 6px;
            right: 8px;
            background: var(--danger);
            color: #fff;
            border-radius: 999px;
            padding: 0 6px;
            font-size: 0.7rem;
            font-weight: 700;
            display: none;
            align-items: center;
            justify-content: center;
            min-width: 18px;
            height: 18px;
        }

        .nav-tab:hover {
            color: var(--amazon-orange);
            background: var(--bg-secondary);
        }

        .nav-tab.active {
            color: var(--amazon-orange);
            border-bottom-color: var(--amazon-orange);
            font-weight: 600;
        }

        .nav-tab-icon {
            font-size: 1rem;
            margin-right: var(--spacing-xs);
        }

        /* Container */
        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: var(--spacing-lg) var(--spacing-md);
        }

        /* Compact Cards */
        .card {
            background: var(--bg-primary);
            border-radius: var(--border-radius);
            padding: var(--spacing-md);
            box-shadow: 0 1px 4px var(--shadow);
            transition: var(--transition);
        }

        .card:hover {
            box-shadow: 0 4px 12px var(--shadow-hover);
        }

        /* Compact Metrics Grid */
        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: var(--spacing-md);
            margin-bottom: var(--spacing-lg);
        }

        .metric-card {
            background: var(--bg-primary);
            border-radius: var(--border-radius);
            padding: var(--spacing-md);
            position: relative;
            overflow: hidden;
            box-shadow: 0 1px 4px var(--shadow);
            transition: var(--transition);
            border-left: 4px solid var(--amazon-orange);
        }

        .metric-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px var(--shadow-hover);
        }

        .metric-icon {
            width: 36px;
            height: 36px;
            background: linear-gradient(135deg, var(--amazon-orange), var(--amazon-orange-dark));
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            margin-bottom: var(--spacing-sm);
        }

        .metric-value {
            font-size: 1.8rem;
            font-weight: 700;
            color: var(--text-primary);
            margin: var(--spacing-xs) 0;
        }

        .metric-label {
            color: var(--text-secondary);
            font-size: 0.85rem;
        }

        .metric-trend {
            position: absolute;
            top: var(--spacing-sm);
            right: var(--spacing-sm);
            font-size: 0.8rem;
            padding: 0.2rem 0.5rem;
            border-radius: 12px;
            background: rgba(76, 175, 80, 0.1);
            color: var(--success);
        }

        .metric-trend.down {
            background: rgba(255, 87, 34, 0.1);
            color: var(--danger);
        }

        /* Compact Control Panel */
        .control-panel {
            background: var(--bg-primary);
            border-radius: var(--border-radius);
            padding: var(--spacing-md);
            margin-bottom: var(--spacing-lg);
            box-shadow: 0 1px 4px var(--shadow);
        }

        .control-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: var(--spacing-md);
            flex-wrap: wrap;
            gap: var(--spacing-sm);
        }

        .control-title {
            font-size: 1.25rem;
            font-weight: 600;
            color: var(--text-primary);
        }

        /* Compact Buttons */
        .btn {
            padding: 0.5rem 1rem;
            border: none;
            border-radius: 4px;
            font-size: 0.85rem;
            font-weight: 500;
            cursor: pointer;
            transition: var(--transition);
            display: inline-flex;
            align-items: center;
            gap: var(--spacing-xs);
        }

        .btn-primary {
            background: var(--amazon-orange);
            color: white;
        }

        .btn-primary:hover {
            background: var(--amazon-orange-dark);
            transform: translateY(-1px);
        }

        .btn-secondary {
            background: var(--amazon-blue);
            color: white;
        }

        .btn-secondary:hover {
            background: var(--amazon-blue-dark);
            transform: translateY(-1px);
        }

        .btn-outline {
            background: transparent;
            border: 1px solid var(--amazon-orange);
            color: var(--amazon-orange);
        }

        .btn-outline:hover {
            background: var(--amazon-orange);
            color: white;
        }

        .btn-sm {
            padding: 0.3rem 0.6rem;
            font-size: 0.8rem;
        }

        /* Compact File Upload */
        .upload-area {
            border: 2px dashed var(--amazon-orange);
            border-radius: var(--border-radius);
            padding: var(--spacing-lg);
            text-align: center;
            transition: var(--transition);
            background: rgba(255, 153, 0, 0.02);
            margin-bottom: var(--spacing-md);
        }

        .upload-area:hover {
            border-color: var(--amazon-orange-dark);
            background: rgba(255, 153, 0, 0.05);
        }

        .upload-area.dragging {
            background: rgba(255, 153, 0, 0.1);
            border-color: var(--amazon-orange);
        }

        .file-input {
            display: none;
        }

        .upload-label {
            display: inline-block;
            padding: 0.5rem 1.5rem;
            background: var(--amazon-orange);
            color: white;
            border-radius: 4px;
            cursor: pointer;
            transition: var(--transition);
            font-weight: 500;
            font-size: 0.9rem;
        }

        .upload-label:hover {
            background: var(--amazon-orange-dark);
        }

        /* Compact Filter Section */
        .filter-section {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
            gap: var(--spacing-sm);
            margin-bottom: var(--spacing-md);
        }

        .filter-group {
            display: flex;
            flex-direction: column;
            gap: var(--spacing-xs);
        }

        .filter-label {
            font-size: 0.8rem;
            font-weight: 500;
            color: var(--text-secondary);
        }

        .filter-input {
            padding: 0.4rem 0.6rem;
            border: 1px solid transparent;
            border-radius: 4px;
            background: var(--bg-secondary);
            color: var(--text-primary);
            transition: var(--transition);
            font-size: 0.85rem;
        }

        .filter-input:focus {
            outline: none;
            border-color: var(--amazon-orange);
            background: var(--bg-primary);
        }

        /* Quick Actions Bar */
        .quick-actions {
            display: flex;
            gap: var(--spacing-sm);
            flex-wrap: wrap;
        }

        /* Compact Charts Container */
        .charts-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(450px, 1fr));
            gap: var(--spacing-md);
            margin-bottom: var(--spacing-lg);
        }

        .chart-card {
            background: var(--bg-primary);
            border-radius: var(--border-radius);
            padding: var(--spacing-md);
            box-shadow: 0 1px 4px var(--shadow);
        }

        .chart-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: var(--spacing-sm);
            gap: var(--spacing-sm);
        }

        .chart-title {
            font-size: 1rem;
            font-weight: 600;
            color: var(--text-primary);
        }

        .chart-container {
            position: relative;
            height: 250px;
        }

        .capture-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(255, 255, 255, 0.9);
            border: 1px solid #ddd;
            border-radius: 50%;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.3s ease;
            z-index: 10;
            opacity: 0.7;
        }

        .capture-btn:hover {
            opacity: 1;
            background: #FF9900;
            color: white;
            transform: scale(1.1);
        }

        [data-theme="dark"] .capture-btn {
            background: rgba(46, 46, 46, 0.9);
            border-color: #555;
        }

        [data-theme="dark"] .capture-btn:hover {
            background: #FF9900;
        }

        /* Data Table */
        .table-container {
            background: var(--bg-primary);
            border-radius: var(--border-radius);
            padding: var(--spacing-md);
            box-shadow: 0 1px 4px var(--shadow);
            overflow: hidden;
        }

        .table-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: var(--spacing-sm);
        }

        .table-wrapper {
            overflow-x: auto;
            margin: -var(--spacing-md);
            padding: var(--spacing-md);
        }

        table {
            width: 100%;
            border-collapse: collapse;
        }

        th {
            background: var(--amazon-blue);
            color: white;
            padding: 0.6rem;
            text-align: left;
            font-weight: 500;
            font-size: 0.85rem;
            position: sticky;
            top: 0;
            z-index: 10;
            white-space: nowrap;
        }

        td {
            padding: 0.5rem 0.6rem;
            border-bottom: 1px solid var(--bg-secondary);
            color: var(--text-primary);
            font-size: 0.85rem;
        }

        tr:hover {
            background: var(--bg-secondary);
        }

        /* Badges */
        .badge {
            display: inline-block;
            padding: 0.15rem 0.5rem;
            border-radius: 12px;
            font-size: 0.75rem;
            font-weight: 600;
        }

        .badge-success {
            background: rgba(76, 175, 80, 0.2);
            color: var(--success);
        }

        .badge-warning {
            background: rgba(255, 193, 7, 0.2);
            color: var(--warning);
        }

        .badge-danger {
            background: rgba(255, 87, 34, 0.2);
            color: var(--danger);
        }

        .badge-critical {
            background: rgba(183, 28, 28, 0.2);
            color: var(--critical);
        }

        .badge-info {
            background: rgba(33, 150, 243, 0.2);
            color: #2196F3;
        }

        /* Risk Matrix */
        .risk-matrix {
            display: grid;
            grid-template-columns: 60px repeat(5, 1fr);
            grid-template-rows: repeat(6, 60px);
            gap: 2px;
            max-width: 500px;
            margin: var(--spacing-lg) auto;
        }

        .matrix-cell {
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 600;
            color: white;
            cursor: pointer;
            transition: var(--transition);
            border-radius: 4px;
            font-size: 0.9rem;
        }

        .matrix-cell:hover {
            transform: scale(1.05);
            z-index: 10;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        }

        .matrix-label {
            background: var(--amazon-blue);
            color: white;
            font-size: 0.8rem;
            font-weight: 500;
        }

        .risk-low { background: var(--success); }
        .risk-medium { background: var(--warning); color: #333; }
        .risk-high { background: var(--danger); }
        .risk-critical { background: var(--critical); }

        /* Timeline */
        .timeline-container {
            background: var(--bg-primary);
            border-radius: var(--border-radius);
            padding: var(--spacing-md);
            box-shadow: 0 1px 4px var(--shadow);
        }

        .timeline-item {
            border-left: 3px solid var(--amazon-orange);
            padding-left: var(--spacing-lg);
            margin-bottom: var(--spacing-lg);
            position: relative;
        }

        .timeline-item::before {
            content: '';
            position: absolute;
            left: -6px;
            top: 0;
            width: 9px;
            height: 9px;
            border-radius: 50%;
            background: var(--amazon-orange);
        }

        .timeline-date {
            font-weight: 600;
            color: var(--amazon-orange);
            margin-bottom: var(--spacing-xs);
            font-size: 0.85rem;
        }

        .timeline-content {
            background: var(--bg-secondary);
            padding: var(--spacing-sm);
            border-radius: 4px;
            font-size: 0.85rem;
        }

        /* Quality Assessment Styles */
        .quality-score-card {
            background: linear-gradient(135deg, var(--amazon-blue) 0%, var(--amazon-blue-dark) 100%);
            color: white;
            border-radius: var(--border-radius);
            padding: var(--spacing-lg);
            text-align: center;
            margin-bottom: var(--spacing-lg);
            display: flex;
            justify-content: center;
        }

        .quality-score-value {
            font-size: 3rem;
            font-weight: 700;
            margin: 0;
        }

        .quality-metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: var(--spacing-md);
            margin-top: var(--spacing-md);
        }

        .quality-metric {
            background: rgba(255, 255, 255, 0.1);
            padding: var(--spacing-md);
            border-radius: var(--border-radius);
        }

        .quality-metrics-container {
            max-width: 800px;
            margin: 0 auto;
        }

        .quality-score-circle {
            width: 160px;
            height: 160px;
            border-radius: 50%;
            background: var(--bg-primary);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            margin: 0 auto;
            color: var(--text-primary);
            box-shadow: 0 2px 8px var(--shadow);
        }

        .quality-score-circle.success { border: 6px solid var(--success); }
        .quality-score-circle.warning { border: 6px solid var(--warning); }
        .quality-score-circle.danger { border: 6px solid var(--danger); }

        .quality-score-label {
            font-size: 0.875rem;
            color: var(--text-secondary);
            margin-top: var(--spacing-xs);
        }

        .quality-section {
            margin-top: var(--spacing-xl);
        }

        .duplicate-list {
            display: grid;
            gap: var(--spacing-sm);
            margin-top: var(--spacing-sm);
        }

        .duplicate-item {
            background: var(--bg-primary);
            padding: var(--spacing-sm);
            border-radius: var(--border-radius);
            box-shadow: 0 1px 3px var(--shadow);
        }

        .missing-fields-chart {
            position: relative;
            height: 300px;
        }

        .recommendations-list {
            display: grid;
            gap: var(--spacing-sm);
        }

        .word-heatmap {
            display: flex;
            flex-wrap: wrap;
            gap: var(--spacing-xs);
        }

        .word-heatmap .heatmap-item {
            padding: var(--spacing-xs) var(--spacing-sm);
            border-radius: 4px;
            color: #fff;
            font-size: 0.85rem;
        }

        .recommendation-item {
            display: flex;
            align-items: center;
            gap: var(--spacing-sm);
            padding: var(--spacing-sm);
            border-radius: var(--border-radius);
            background: var(--bg-primary);
            box-shadow: 0 1px 3px var(--shadow);
        }

        .recommendation-item.critical { border-left: 4px solid var(--critical); }
        .recommendation-item.warning { border-left: 4px solid var(--warning); }
        .recommendation-item.success { border-left: 4px solid var(--success); }

        .rec-icon {
            font-size: 1.2rem;
        }

        /* Status Messages */
        .status-message {
            padding: 0.6rem 1rem;
            border-radius: 4px;
            margin: var(--spacing-sm) 0;
            display: flex;
            align-items: center;
            gap: var(--spacing-sm);
            animation: slideIn 0.3s ease-out;
            font-size: 0.85rem;
        }

        @keyframes slideIn {
            from {
                transform: translateY(-10px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        .status-success {
            background: rgba(76, 175, 80, 0.1);
            color: var(--success);
            border: 1px solid rgba(76, 175, 80, 0.3);
        }

        .status-error {
            background: rgba(255, 87, 34, 0.1);
            color: var(--danger);
            border: 1px solid rgba(255, 87, 34, 0.3);
        }

        .status-info {
            background: rgba(33, 150, 243, 0.1);
            color: #2196F3;
            border: 1px solid rgba(33, 150, 243, 0.3);
        }

        /* Austin Link */
        .austin-link {
            background: var(--amazon-yellow);
            color: var(--amazon-blue);
            padding: 0.3rem 0.6rem;
            border-radius: 3px;
            text-decoration: none;
            font-size: 0.75rem;
            font-weight: 600;
            transition: var(--transition);
            display: inline-flex;
            align-items: center;
            gap: 0.2rem;
        }

        .austin-link:hover {
            background: #ffc700;
            transform: translateY(-1px);
        }

        /* Loading Spinner */
        .spinner {
            width: 30px;
            height: 30px;
            border: 3px solid var(--bg-secondary);
            border-top: 3px solid var(--amazon-orange);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: var(--spacing-lg) auto;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            .header-content {
                flex-direction: column;
                text-align: center;
                gap: var(--spacing-sm);
            }

            .nav-tabs {
                overflow-x: scroll;
            }

            .charts-grid {
                grid-template-columns: 1fr;
            }

            .filter-section {
                grid-template-columns: 1fr;
            }

            .risk-matrix {
                grid-template-columns: 30px repeat(5, 1fr);
                grid-template-rows: repeat(6, 50px);
                font-size: 0.7rem;
            }

            .chart-container {
                height: 200px;
            }
        }

        /* Tab Content */
        .tab-content {
            display: none;
            animation: fadeIn 0.3s ease-out;
        }

        .tab-content.active {
            display: block;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* Hidden class */
        .hidden {
            display: none !important;
        }

        /* Capture controls */
        .injury-view,
        .nearmiss-view {
            position: relative;
        }

        .capture-view-btn {
            position: absolute;
            top: 1rem;
            right: 1rem;
            padding: 0.35rem 0.75rem;
            border-radius: 999px;
            background: rgba(35, 47, 62, 0.85);
            color: #ffffff;
            border: none;
            cursor: pointer;
            font-size: 0.75rem;
            font-weight: 500;
            display: inline-flex;
            align-items: center;
            gap: 0.35rem;
            opacity: 0;
            pointer-events: none;
            transform: translateY(-4px);
            transition: var(--transition);
            box-shadow: 0 2px 8px var(--shadow);
            z-index: 5;
        }

        .capture-view-btn:hover {
            background: var(--amazon-orange);
            box-shadow: 0 4px 12px var(--shadow-hover);
        }

        .capture-view-btn.capturing {
            visibility: hidden;
        }

        .injury-view:hover .capture-view-btn,
        .nearmiss-view:hover .capture-view-btn {
            opacity: 1;
            pointer-events: auto;
            transform: translateY(0);
        }

        body.capturing .capture-view-btn {
            opacity: 0 !important;
            visibility: hidden !important;
        }

        /* Sub Navigation */
        .sub-nav {
            display: flex;
            gap: 0;
            margin-bottom: var(--spacing-md);
            border-bottom: 1px solid var(--bg-secondary);
        }

        .sub-nav-item {
            padding: 0.5rem 1rem;
            cursor: pointer;
            transition: var(--transition);
            font-size: 0.85rem;
            position: relative;
            color: var(--text-secondary);
            border-bottom: 2px solid transparent;
        }

        .sub-nav-item:hover {
            color: var(--amazon-orange);
            background: var(--bg-secondary);
        }

        .sub-nav-item.active {
            color: var(--amazon-orange);
            border-bottom-color: var(--amazon-orange);
        }

        /* Modal */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 1000;
            animation: fadeIn 0.3s;
        }

        .modal-content {
            position: relative;
            background: var(--bg-primary);
            margin: 5% auto;
            padding: var(--spacing-lg);
            width: 90%;
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
            border-radius: var(--border-radius);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            animation: slideDown 0.3s;
        }

        @keyframes slideDown {
            from {
                transform: translateY(-50px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: var(--spacing-md);
            border-bottom: 1px solid var(--bg-secondary);
            padding-bottom: var(--spacing-sm);
        }

        .modal-close {
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            color: var(--text-secondary);
            transition: var(--transition);
        }

        .modal-close:hover {
            color: var(--text-primary);
            transform: rotate(90deg);
        }

        /* Help Modal */
        .help-modal-content {
            width: 90%;
            max-width: 800px;
            padding: var(--spacing-lg);
        }
        .help-body {
            max-height: 60vh;
            overflow-y: auto;
            padding-right: var(--spacing-sm);
        }
        .help-tabs {
            display: flex;
            gap: var(--spacing-sm);
            border-bottom: 1px solid var(--bg-secondary);
            margin-bottom: var(--spacing-md);
            overflow-x: auto;
        }
        .help-tab {
            background: none;
            border: none;
            padding: var(--spacing-sm) var(--spacing-md);
            cursor: pointer;
            color: var(--text-secondary);
            transition: var(--transition);
            white-space: nowrap;
        }
        .help-tab.active {
            color: var(--amazon-orange);
            border-bottom: 2px solid var(--amazon-orange);
        }
        .help-section {
            display: none;
            animation: fadeIn 0.3s ease-out;
        }
        .help-section.active {
            display: block;
        }
        .section-title {
            display: flex;
            align-items: center;
            gap: var(--spacing-sm);
            margin-bottom: var(--spacing-md);
        }
        .section-title i {
            color: var(--amazon-orange);
        }
        .text-muted {
            color: var(--text-secondary);
            font-size: 0.9rem;
        }
        .help-card {
            background: var(--bg-primary);
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.15);
            padding: var(--spacing-md);
            transition: var(--transition);
            margin-bottom: var(--spacing-md);
        }
        .help-card:hover {
            transform: translateY(-4px);
            box-shadow: 0 6px 24px rgba(0,0,0,0.2);
        }
        .features-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: var(--spacing-md);
        }
        .feature-card i {
            font-size: 2rem;
            color: var(--amazon-orange);
            margin-bottom: var(--spacing-sm);
        }
        .quick-step {
            display: flex;
            gap: var(--spacing-md);
            margin-bottom: var(--spacing-md);
        }
        .quick-step-number {
            flex-shrink: 0;
            width: 32px;
            height: 32px;
            border-radius: 50%;
            background: var(--amazon-orange);
            color: #fff;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
        }
        .quick-step-content {
            flex: 1;
        }
        .progress {
            height: 4px;
            background: var(--bg-secondary);
            border-radius: 2px;
            overflow: hidden;
            margin-top: var(--spacing-sm);
        }
        .progress-bar {
            height: 100%;
            background: var(--amazon-orange);
            width: 0;
            animation: progress 1s forwards;
        }
        @keyframes progress {
            from { width: 0; }
            to { width: 100%; }
        }
        .try-btn {
            margin-top: var(--spacing-sm);
        }
        .demo-image {
            width: 100%;
            border-radius: 12px;
            margin-top: var(--spacing-md);
        }
        .help-list {
            display: flex;
            flex-direction: column;
            gap: var(--spacing-sm);
            margin-left: 1.2rem;
        }
        .help-list kbd {
            background: var(--bg-secondary);
            padding: 2px 4px;
            border-radius: 4px;
        }
        /* Pagination */
        .pagination {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: var(--spacing-sm);
            margin-top: var(--spacing-md);
        }

        .pagination-info {
            color: var(--text-secondary);
            font-size: 0.85rem;
        }

        /* KPI Dashboard */
        .kpi-container {
            background: linear-gradient(135deg, var(--amazon-blue) 0%, var(--amazon-blue-dark) 100%);
            color: white;
            border-radius: var(--border-radius);
            padding: var(--spacing-lg);
            margin-bottom: var(--spacing-lg);
        }

        .kpi-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: var(--spacing-lg);
            margin-top: var(--spacing-md);
        }

        .kpi-item {
            text-align: center;
        }

        .kpi-value {
            font-size: 2rem;
            font-weight: 700;
            margin-bottom: var(--spacing-xs);
        }

        .kpi-label {
            font-size: 0.85rem;
            opacity: 0.9;
        }

        /* Footer */
        .footer {
            background: var(--amazon-blue);
            color: white;
            padding: var(--spacing-lg) 0;
            margin-top: 3rem;
            text-align: center;
            font-size: 0.85rem;
        }

        .footer a {
            color: var(--amazon-orange);
            text-decoration: none;
        }

        .footer a:hover {
            text-decoration: underline;
        }

        /* Amazon Prime Style Welcome */
        .welcome-screen {
            text-align: center;
            padding: 3rem var(--spacing-lg);
        }

        .welcome-title {
            font-size: 2rem;
            margin-bottom: var(--spacing-sm);
            background: linear-gradient(135deg, var(--amazon-orange), var(--amazon-orange-dark));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .welcome-subtitle {
            font-size: 1.1rem;
            color: var(--text-secondary);
            margin-bottom: var(--spacing-xl);
        }

        .welcome-actions {
            display: flex;
            gap: var(--spacing-sm);
            justify-content: center;
            flex-wrap: wrap;
        }

        /* Export Options */
        .export-section {
            background: var(--bg-primary);
            border-radius: var(--border-radius);
            padding: var(--spacing-md);
            margin-top: var(--spacing-lg);
            box-shadow: 0 1px 4px var(--shadow);
        }

        .export-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: var(--spacing-sm);
            margin-top: var(--spacing-sm);
        }

        /* Print Styles */
        @media print {
            body {
                background: white;
            }
            
            .header, .nav-container, .mode-toggle, .btn, .upload-area {
                display: none !important;
            }
            
            .card, .table-container {
                break-inside: avoid;
                box-shadow: none;
                border: 1px solid #ddd;
            }
        }

        /* Amazon Smile */
        .amazon-smile {
            color: var(--amazon-orange);
            font-size: 1.2rem;
            margin-right: var(--spacing-xs);
        }

        /* Inspection Module Styles */
        #inspections .alert-section {
            background: #FFEBEE;
            border-left: 4px solid #B71C1C;
            padding: 15px;
            margin: 20px 0;
            border-radius: 4px;
            box-shadow: 0 1px 4px var(--shadow);
        }

        #inspections .filters-container {
            display: flex;
            flex-wrap: wrap;
            gap: 0.75rem;
        }

        #inspections .filters-container select,
        #inspections .filters-container input[type="date"] {
            min-width: 160px;
            padding: 0.6rem 0.75rem;
            border-radius: 6px;
            border: 1px solid rgba(0,0,0,0.1);
            background: var(--bg-primary);
            color: var(--text-primary);
        }

        .overdue-list {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        .overdue-list li {
            padding: 10px 12px;
            background: white;
            margin: 8px 0;
            border-radius: 6px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 1rem;
            box-shadow: 0 1px 3px rgba(0,0,0,0.05);
        }

        .overdue-days {
            color: #B71C1C;
            font-weight: 600;
            padding: 2px 10px;
            background: #FFEBEE;
            border-radius: 999px;
        }

        .inspection-status-badge {
            padding: 4px 12px;
            border-radius: 999px;
            font-size: 0.85rem;
            font-weight: 600;
            display: inline-flex;
            align-items: center;
            gap: 0.25rem;
        }

        .status-overdue { background: #FFEBEE; color: #B71C1C; }
        .status-upcoming { background: #FFF8E1; color: #F57C00; }
        .status-completed { background: #E8F5E9; color: #2E7D32; }
        .status-scheduled { background: #E3F2FD; color: #1565C0; }

        /* WBR Report Styles */
        .wbr-header {
            background: linear-gradient(135deg, #FF9900, #FF6F00);
            color: white;
            padding: 30px;
            border-radius: 8px;
            text-align: center;
        }

        .wbr-section {
            margin: 20px 0;
            padding: 20px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .wbr-metrics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }

        .wbr-metric-card {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            border-left: 4px solid #FF9900;
        }

        .wbr-metric-value {
            font-size: 2em;
            font-weight: bold;
            color: #232F3E;
            margin: 10px 0;
        }

        .wbr-metric-label {
            color: #666;
            font-size: 0.9em;
        }
    </style>
</head>
<body class="modernized" data-page="Safety Analytics Platform">
    <div class="neo-shell">
        <header class="neo-topbar">
            <div class="neo-brand">
                <div class="neo-brand__mark">SAP</div>
                <div class="neo-brand__meta">
                    <p class="neo-brand__title">Safety Analytics Platform</p>
                    <p class="neo-brand__subtitle">Enterprise WHS Intelligence</p>
                </div>
            </div>
            <div class="neo-topbar__controls">
                <button class="neo-chip" data-open-command>
                    <i class="fa-solid fa-magnifying-glass"></i>
                    <span>Search workspace</span>
                    <kbd>Ctrl</kbd><kbd>K</kbd>
                </button>
                <button class="neo-chip" data-toggle-theme>
                    <i class="fa-solid fa-circle-half-stroke"></i>
                    <span>Theme</span>
                </button>
                <button class="neo-chip" data-open-quicktour>
                    <i class="fa-solid fa-compass-drafting"></i>
                    <span>Guided focus</span>
                </button>
            </div>
        </header>

        <section class="neo-ribbon" aria-label="experience signals">
            <div class="neo-ribbon__item">
                <p class="label">Operational coverage</p>
                <div class="value">All workflows preserved</div>
            </div>
            <div class="neo-ribbon__item">
                <p class="label">Performance mode</p>
                <div class="value">Modern shell ¬∑ Cached assets</div>
            </div>
            <div class="neo-ribbon__item">
                <p class="label">Assistive layer</p>
                <div class="value">Context-aware shortcuts</div>
            </div>
        </section>

        <section class="neo-quickbar" aria-label="priority actions">
            <div class="neo-quickbar__content">
                <div>
                    <p class="eyebrow">Priority controls</p>
                    <p class="headline">Jump directly to the tools you use most</p>
                </div>
                <div class="neo-quick-actions" data-quick-actions></div>
            </div>
            <div class="neo-context-hints" data-context-hints>
                <p class="eyebrow">Smart guidance</p>
                <p class="hint">Hover or focus on any form to receive tailored shortcuts.</p>
            </div>
        </section>
    </div>

    <div class="neo-command" data-command-palette hidden>
        <div class="neo-command__dialog" role="dialog" aria-modal="true" aria-label="Command Palette">
            <div class="neo-command__header">
                <input type="search" placeholder="Find pages, sections, or actions" data-command-input />
                <button class="neo-command__close" data-close-command aria-label="Close">
                    <i class="fa-solid fa-xmark"></i>
                </button>
            </div>
            <div class="neo-command__results" data-command-results></div>
        </div>
    </div>

    <!-- Header -->
    <header class="header">
        <div class="header-content">
            <div class="header-title">
                <div class="amazon-logo">
                    <span class="amazon-smile">‚Üí</span>
                    <span>amazon</span>
                </div>
                <div>
                    <h1>Safety Analytics Platform</h1>
                    <div class="header-subtitle">
                        <span>WHS Austria</span>
                        <span style="opacity: 0.7;">|</span>
                        <span>Developed by Erwin Esener @eeesener</span>
                    </div>
                </div>
            </div>
            <div class="header-actions">
                <button class="mode-toggle" onclick="toggleTheme()">
                    <span id="themeIcon">üåô</span>
                    <span id="themeText">Dark Mode</span>
                </button>
                <button class="mode-toggle" onclick="openHelpModal()">
                    <span>‚ùî</span>
                    <span>Help</span>
                </button>
            </div>
        </div>
    </header>

    <!-- Navigation -->
    <nav class="nav-container">
        <div class="nav-tabs">
            <div class="nav-tab active" data-module="overview" onclick="switchModule('overview', event)">
                <span class="nav-tab-icon">üìä</span>
                <span>Overview</span>
            </div>
            <div class="nav-tab" data-module="injury" onclick="switchModule('injury', event)">
                <span class="nav-tab-icon">üè•</span>
                <span>Injury & Illness</span>
            </div>
            <div class="nav-tab" data-module="nearmiss" onclick="switchModule('nearmiss', event)">
                <span class="nav-tab-icon">‚ö†Ô∏è</span>
                <span>Near Miss</span>
            </div>
            <div class="nav-tab" data-module="combined" onclick="switchModule('combined', event)">
                <span class="nav-tab-icon">üìà</span>
                <span>Combined Analytics</span>
            </div>
            <div class="nav-tab" data-module="inspections" onclick="switchModule('inspections', event)">
                <span class="nav-tab-icon">üìã</span>
                <span>Inspections</span>
            </div>
            <div class="nav-tab" data-module="reports" onclick="switchModule('reports', event)">
                <span class="nav-tab-icon">üìÑ</span>
                <span>Reports</span>
            </div>
            <div class="nav-tab" data-module="actions" onclick="switchModule('actions', event)">
                <span class="nav-tab-icon">‚úÖ</span>
                <span>Actions</span>
            </div>
        </div>
    </nav>

    <div class="container">
        <!-- Status Message Container -->
        <div id="statusContainer"></div>

        <!-- Overview Module -->
        <div id="overview" class="tab-content active">
            <div class="welcome-screen" id="welcomeScreen">
                <h2 class="welcome-title">Welcome to Safety Analytics</h2>
                <p class="welcome-subtitle">Your comprehensive platform for workplace safety data analysis</p>
                <div class="welcome-actions">
                    <button class="btn btn-primary" onclick="switchModule('injury')">
                        <span>üè•</span> Analyze Injuries
                    </button>
                    <button class="btn btn-primary" onclick="switchModule('nearmiss')">
                        <span>‚ö†Ô∏è</span> Review Near Misses
                    </button>
                    <button class="btn btn-secondary" onclick="loadSampleData()">
                        <span>üß™</span> Load Sample Data
                    </button>
                </div>
            </div>

            <!-- Unified Filters for Overview Dashboards -->
            <div id="overviewFilters" class="filter-section" style="display: none; margin-top: 1rem; gap: 1rem;">
                <div class="filter-group">
                    <label class="filter-label">Site</label>
                    <select class="filter-input" id="overviewSiteFilter" onchange="applyOverviewFilters()">
                        <option value="">All Sites</option>
                    </select>
                </div>
                <div class="filter-group">
                    <label class="filter-label">Severity</label>
                    <select class="filter-input" id="overviewSeverityFilter" onchange="applyOverviewFilters()">
                        <option value="">All Severities</option>
                        <option value="A">A - Critical</option>
                        <option value="B">B - High</option>
                        <option value="C">C - Medium</option>
                        <option value="D">D - Low</option>
                    </select>
                </div>
                <div class="filter-group">
                    <label class="filter-label">Date From</label>
                    <input type="date" class="filter-input" id="overviewDateFrom" onchange="applyOverviewFilters()">
                </div>
                <div class="filter-group">
                    <label class="filter-label">Date To</label>
                    <input type="date" class="filter-input" id="overviewDateTo" onchange="applyOverviewFilters()">
                </div>
                <!-- Additional unified filters to mirror both modules -->
                <div class="filter-group">
                    <label class="filter-label">Body Part</label>
                    <select class="filter-input" id="overviewBodyPartFilter" onchange="applyOverviewFilters()">
                        <option value="">All Body Parts</option>
                    </select>
                </div>
                <div class="filter-group">
                    <label class="filter-label">Impact</label>
                    <select class="filter-input" id="overviewImpactFilter" onchange="applyOverviewFilters()">
                        <option value="">All Impacts</option>
                    </select>
                </div>
                <div class="filter-group">
                    <label class="filter-label">Location</label>
                    <select class="filter-input" id="overviewLocationFilter" onchange="applyOverviewFilters()">
                        <option value="">All Locations</option>
                    </select>
                </div>
                <div class="filter-group">
                    <label class="filter-label">Process Path</label>
                    <select class="filter-input" id="overviewProcessFilter" onchange="applyOverviewFilters()">
                        <option value="">All Processes</option>
                    </select>
                </div>
                <div class="filter-group">
                    <label class="filter-label">Likelihood</label>
                    <select class="filter-input" id="overviewLikelihoodFilter" onchange="applyOverviewFilters()">
                        <option value="">All Likelihoods</option>
                    </select>
                </div>
            </div>

            <!-- KPI Dashboard -->
            <div class="kpi-container" id="kpiDashboard" style="display: none;">
                <h3>Key Performance Indicators - Austria Region</h3>
                <div class="kpi-grid">
                    <div class="kpi-item">
                        <div class="kpi-value" id="kpiTRIR">0.00</div>
                        <div class="kpi-label">TRIR</div>
                    </div>
                    <div class="kpi-item">
                        <div class="kpi-value" id="kpiLTIR">0.00</div>
                        <div class="kpi-label">LTIR</div>
                    </div>
                    <div class="kpi-item">
                        <div class="kpi-value" id="kpiDAFWR">0.00</div>
                        <div class="kpi-label">DAFWR</div>
                    </div>
                    <div class="kpi-item">
                        <div class="kpi-value" id="kpiNMFR">0.00</div>
                        <div class="kpi-label">NMFR</div>
                    </div>
                </div>
            </div>

            <!-- Combined Metrics Overview -->
            <div class="metrics-grid" id="overviewMetrics" style="display: none;">
                <div class="metric-card">
                    <div class="metric-icon">üìä</div>
                    <div class="metric-value" id="totalIncidents">0</div>
                    <div class="metric-label">Total Safety Events</div>
                    <div class="metric-trend">‚Üì 12%</div>
                </div>
                <div class="metric-card">
                    <div class="metric-icon">üè•</div>
                    <div class="metric-value" id="injuryCount">0</div>
                    <div class="metric-label">Injuries & Illnesses</div>
                </div>
                <div class="metric-card">
                    <div class="metric-icon">‚ö†Ô∏è</div>
                    <div class="metric-value" id="nearMissCount">0</div>
                    <div class="metric-label">Near Misses</div>
                </div>
                <div class="metric-card">
                    <div class="metric-icon">üìà</div>
                    <div class="metric-value" id="riskScore">0.0</div>
                    <div class="metric-label">Overall Risk Score</div>
                </div>
            </div>

            <!-- Quick Charts -->
            <div class="charts-grid" id="overviewCharts" style="display: none;">
                <div class="chart-card">
                    <div class="chart-header">
                        <h3 class="chart-title">Safety Trend Overview</h3>
                    </div>
                    <div class="chart-container" data-capture-title="Safety Trend Overview">
                        <canvas id="overviewTrendChart"></canvas>
                    </div>
                </div>
                <div class="chart-card">
                    <div class="chart-header">
                        <h3 class="chart-title">Site Comparison</h3>
                    </div>
                    <div class="chart-container" data-capture-title="Site Comparison">
                        <canvas id="overviewSiteChart"></canvas>
                    </div>
                </div>
            </div>
        </div>

        <!-- Injury & Illness Module -->
        <div id="injury" class="tab-content">
            <!-- Sub Navigation -->
            <div class="sub-nav">
                <div class="sub-nav-item active" onclick="switchInjuryView('dashboard')">Dashboard</div>
                <div class="sub-nav-item" onclick="switchInjuryView('riskMatrix')">Risk Matrix</div>
                <div class="sub-nav-item" onclick="switchInjuryView('timeline')">Timeline</div>
                <div class="sub-nav-item" onclick="switchInjuryView('quality')">Quality Assessment</div>
                <div class="sub-nav-item" onclick="switchInjuryView('analytics')">Advanced Analytics</div>
            </div>

            <!-- Dashboard View -->
            <div id="injuryDashboard" class="injury-view">
                <div class="control-panel">
                    <div class="control-header">
                        <h2 class="control-title">Injury & Illness Analysis</h2>
                        <div class="quick-actions">
                            <button class="btn btn-primary" onclick="generateInjuryReport()">
                                <span>üìÑ</span> Generate Report
                            </button>
                            <button class="btn btn-secondary" onclick="exportInjuryData()">
                                <span>üìä</span> Export Excel
                            </button>
                        </div>
                    </div>

                    <div class="upload-area" id="injuryUploadArea" ondrop="handleDrop(event, 'injury')" ondragover="handleDragOver(event)" ondragleave="handleDragLeave(event)">
                        <p style="margin-bottom: 0.5rem;">üìÅ Drag and drop your injury CSV file here</p>
                        <label for="injuryFile" class="upload-label">Choose File</label>
                        <input type="file" id="injuryFile" class="file-input" accept=".csv" onchange="handleFileUpload(event, 'injury')">
                        <p style="margin-top: 0.5rem; font-size: 0.8rem; color: var(--text-secondary);">
                            Supports CSV files with injury/illness data including Austin case study links
                        </p>
                    </div>

                    <div class="filter-section">
                        <div class="filter-group">
                            <label class="filter-label">Site</label>
                            <select class="filter-input" id="injurySiteFilter" onchange="applyFilters('injury')">
                                <option value="">All Sites</option>
                            </select>
                        </div>
                        <div class="filter-group">
                            <label class="filter-label">Severity</label>
                            <select class="filter-input" id="injurySeverityFilter" onchange="applyFilters('injury')">
                                <option value="">All Severities</option>
                                <option value="A">A - Critical</option>
                                <option value="B">B - High</option>
                                <option value="C">C - Medium</option>
                                <option value="D">D - Low</option>
                            </select>
                        </div>
                        <div class="filter-group">
                            <label class="filter-label">Recordable</label>
                            <select class="filter-input" id="injuryRecordableFilter" onchange="applyFilters('injury')">
                                <option value="">All Cases</option>
                                <option value="1">Recordable Only</option>
                                <option value="0">Non-Recordable Only</option>
                            </select>
                        </div>
                        <div class="filter-group">
                            <label class="filter-label">OTR Status</label>
                            <select class="filter-input" id="injuryOTRFilter" onchange="applyFilters('injury')">
                                <option value="">All</option>
                                <option value="yes">On The Road</option>
                                <option value="no">Under the Roof</option>
                            </select>
                        </div>
                        <div class="filter-group">
                            <label class="filter-label">Body Part</label>
                            <select class="filter-input" id="injuryBodyPartFilter" onchange="applyFilters('injury')">
                                <option value="">All Body Parts</option>
                            </select>
                        </div>
                        <div class="filter-group">
                            <label class="filter-label">Root Cause</label>
                            <select class="filter-input" id="injuryRootCauseFilter" onchange="applyFilters('injury')">
                                <option value="">All Causes</option>
                            </select>
                        </div>
                        <div class="filter-group">
                            <label class="filter-label">Date From</label>
                            <input type="date" class="filter-input" id="injuryDateFrom" onchange="applyFilters('injury')">
                        </div>
                        <div class="filter-group">
                            <label class="filter-label">Date To</label>
                            <input type="date" class="filter-input" id="injuryDateTo" onchange="applyFilters('injury')">
                        </div>
                    </div>
                </div>

                <!-- Injury Metrics -->
                <div class="metrics-grid" id="injuryMetrics">
                    <div class="metric-card">
                        <div class="metric-icon">üè•</div>
                        <div class="metric-value" id="injuryTotal">0</div>
                        <div class="metric-label">Total Incidents</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-icon">üìù</div>
                        <div class="metric-value" id="injuryRecordable">0</div>
                        <div class="metric-label">Recordable Cases</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-icon">üìÖ</div>
                        <div class="metric-value" id="injuryLostTime">0</div>
                        <div class="metric-label">Lost Time Cases</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-icon">‚è±Ô∏è</div>
                        <div class="metric-value" id="injuryDaysLost">0</div>
                        <div class="metric-label">Days Away From Work</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-icon">üöó</div>
                        <div class="metric-value" id="injuryOTR">0</div>
                        <div class="metric-label">OTR Incidents</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-icon">üìä</div>
                        <div class="metric-value" id="injuryRecordableRate">0.0</div>
                        <div class="metric-label">Recordable Rate</div>
                    </div>
                </div>

                <!-- Injury Charts -->
                <div class="charts-grid">
                    <div class="chart-card">
                        <div class="chart-header">
                            <h3 class="chart-title">Analysis View 1</h3>
                            <select class="filter-input" style="width: auto;" onchange="updateInjuryChart(1, this.value)">
                                <option value="severity">Severity Distribution</option>
                                <option value="site">Site Comparison</option>
                                <option value="trend">Monthly Trend</option>
                                <option value="bodyPart">Body Parts Affected</option>
                                <option value="rootCause">Root Causes</option>
                                <option value="processPath">Process Paths</option>
                                <option value="recordableTrend">Recordable Trend</option>
                                <option value="impactType">Impact Types</option>
                            </select>
                        </div>
                        <div class="chart-container" data-capture-title="Injury Analysis View 1">
                            <canvas id="injuryChart1"></canvas>
                        </div>
                    </div>
                    <div class="chart-card">
                        <div class="chart-header">
                            <h3 class="chart-title">Analysis View 2</h3>
                            <select class="filter-input" style="width: auto;" onchange="updateInjuryChart(2, this.value)">
                                <option value="severity">Severity Distribution</option>
                                <option value="site">Site Comparison</option>
                                <option value="trend">Monthly Trend</option>
                                <option value="bodyPart">Body Parts Affected</option>
                                <option value="rootCause">Root Causes</option>
                                <option value="processPath">Process Paths</option>
                                <option value="recordableTrend">Recordable Trend</option>
                                <option value="impactType">Impact Types</option>
                            </select>
                        </div>
                        <div class="chart-container" data-capture-title="Injury Analysis View 2">
                            <canvas id="injuryChart2"></canvas>
                        </div>
                    </div>
                    <div class="chart-card">
                        <div class="chart-header">
                            <h3 class="chart-title">Analysis View 3</h3>
                            <select class="filter-input" style="width: auto;" onchange="updateInjuryChart(3, this.value)">
                                <option value="severity">Severity Distribution</option>
                                <option value="site">Site Comparison</option>
                                <option value="trend">Monthly Trend</option>
                                <option value="bodyPart">Body Parts Affected</option>
                                <option value="rootCause">Root Causes</option>
                                <option value="processPath">Process Paths</option>
                                <option value="recordableTrend">Recordable Trend</option>
                                <option value="impactType">Impact Types</option>
                            </select>
                        </div>
                        <div class="chart-container" data-capture-title="Injury Analysis View 3">
                            <canvas id="injuryChart3"></canvas>
                        </div>
                    </div>
                    <div class="chart-card">
                        <div class="chart-header">
                            <h3 class="chart-title">Analysis View 4</h3>
                            <select class="filter-input" style="width: auto;" onchange="updateInjuryChart(4, this.value)">
                                <option value="severity">Severity Distribution</option>
                                <option value="site">Site Comparison</option>
                                <option value="trend">Monthly Trend</option>
                                <option value="bodyPart">Body Parts Affected</option>
                                <option value="rootCause">Root Causes</option>
                                <option value="processPath">Process Paths</option>
                                <option value="recordableTrend">Recordable Trend</option>
                                <option value="impactType">Impact Types</option>
                            </select>
                        </div>
                        <div class="chart-container" data-capture-title="Injury Analysis View 4">
                            <canvas id="injuryChart4"></canvas>
                        </div>
                    </div>
                </div>

                <!-- Injury Table -->
                <div class="table-container">
                    <div class="table-header">
                        <h3>Recent Injury & Illness Cases</h3>
                        <button class="btn btn-sm btn-outline" onclick="exportTable('injury')">
                            <span>üìä</span> Export
                        </button>
                    </div>
                    <div class="table-wrapper">
                        <table id="injuryTable">
                            <thead>
                                <tr>
                                    <th>Case Number</th>
                                    <th>Date</th>
                                    <th>Site</th>
                                    <th>Body Part</th>
                                    <th>Type</th>
                                    <th>Severity</th>
                                    <th>Recordable</th>
                                    <th>OTR</th>
                                    <th>DAFW Days</th>
                                    <th>Root Cause</th>
                                    <th>Actions</th>
                                </tr>
                            </thead>
                            <tbody id="injuryTableBody">
                                <tr>
                                    <td colspan="11" style="text-align: center; padding: 2rem;">
                                        No data loaded. Please upload a CSV file.
                                    </td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                    <div class="pagination">
                        <button class="btn btn-sm" onclick="changePage('injury', -1)" id="injuryPrevBtn">Previous</button>
                        <span class="pagination-info" id="injuryPageInfo">Page 1 of 1</span>
                        <button class="btn btn-sm" onclick="changePage('injury', 1)" id="injuryNextBtn">Next</button>
                    </div>
                </div>
            </div>

            <!-- Risk Matrix View -->
            <div id="injuryRiskMatrix" class="injury-view hidden">
                <div class="card">
                    <h3 style="margin-bottom: 1rem;">Injury & Illness Risk Assessment Matrix</h3>
                    <p style="color: var(--text-secondary); margin-bottom: 0.5rem; font-size: 0.85rem;">
                        Click on any cell to view incidents in that risk category
                    </p>
                    <div class="risk-matrix" id="injuryRiskMatrixGrid">
                        <!-- Will be populated dynamically -->
                    </div>
                    <div style="margin-top: 1.5rem; text-align: center;">
                        <h4 style="font-size: 0.9rem;">Risk Levels:</h4>
                        <div style="display: flex; gap: 1.5rem; justify-content: center; margin-top: 0.5rem; font-size: 0.8rem;">
                            <span><span style="display: inline-block; width: 16px; height: 16px; background: #4CAF50; vertical-align: middle; border-radius: 3px;"></span> Low (1-5)</span>
                            <span><span style="display: inline-block; width: 16px; height: 16px; background: #FFC107; vertical-align: middle; border-radius: 3px;"></span> Medium (6-10)</span>
                            <span><span style="display: inline-block; width: 16px; height: 16px; background: #FF5722; vertical-align: middle; border-radius: 3px;"></span> High (11-15)</span>
                            <span><span style="display: inline-block; width: 16px; height: 16px; background: #B71C1C; vertical-align: middle; border-radius: 3px;"></span> Critical (16-25)</span>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Timeline View -->
            <div id="injuryTimeline" class="injury-view hidden">
                <div class="timeline-container">
                    <h3 style="margin-bottom: 1rem;">Injury & Illness Timeline</h3>
                    <div id="injuryTimelineContent">
                        <p style="text-align: center; padding: 2rem;">Timeline will be displayed after data is loaded.</p>
                    </div>
                    <div class="pagination">
                        <button class="btn btn-sm" onclick="changeTimelinePage('injury', -1)">Previous</button>
                        <span class="pagination-info" id="injuryTimelinePageInfo">Page 1 of 1</span>
                        <button class="btn btn-sm" onclick="changeTimelinePage('injury', 1)">Next</button>
                    </div>
                </div>
            </div>

            <!-- Quality Assessment View -->
            <div id="injuryQuality" class="injury-view hidden">
                <div class="quality-score-card">
                    <h3>Data Quality Assessment</h3>
                    <div class="quality-score-value" id="injuryQualityScore">0%</div>
                    <div class="quality-metrics">
                        <div class="quality-metric">
                            <div style="font-size: 1.5rem; font-weight: 700;" id="injuryCompleteness">0%</div>
                            <div style="font-size: 0.85rem;">Completeness</div>
                        </div>
                        <div class="quality-metric">
                            <div style="font-size: 1.5rem; font-weight: 700;" id="injuryAccuracy">0%</div>
                            <div style="font-size: 0.85rem;">Accuracy</div>
                        </div>
                        <div class="quality-metric">
                            <div style="font-size: 1.5rem; font-weight: 700;" id="injuryConsistency">0%</div>
                            <div style="font-size: 0.85rem;">Consistency</div>
                        </div>
                        <div class="quality-metric">
                            <div style="font-size: 1.5rem; font-weight: 700;" id="injuryTimeliness">0%</div>
                            <div style="font-size: 0.85rem;">Timeliness</div>
                        </div>
                    </div>
                </div>

                <div class="card" style="margin-top: 1rem;">
                    <h4 style="margin-bottom: 1rem;">Quality Issues Detected</h4>
                    <div id="injuryQualityIssues">
                        <p style="color: var(--text-secondary);">Quality assessment will appear after data is loaded.</p>
                    </div>
                </div>

                <div class="card" style="margin-top: 1rem;">
                    <h4 style="margin-bottom: 1rem;">Duplicate Detection</h4>
                    <div id="injuryDuplicates">
                        <p style="color: var(--text-secondary);">Duplicate analysis will appear after data is loaded.</p>
                    </div>
                </div>
            </div>

            <!-- Advanced Analytics View -->
            <div id="injuryAnalytics" class="injury-view hidden">
                <div class="charts-grid">
                    <div class="chart-card">
                        <div class="chart-header">
                            <h3 class="chart-title">Severity Pattern Radar</h3>
                        </div>
                        <div class="chart-container" data-capture-title="Severity Pattern Radar">
                            <canvas id="injurySeverityPatternChart"></canvas>
                        </div>
                    </div>
                    <div class="chart-card">
                        <div class="chart-header">
                            <h3 class="chart-title">Average Recovery Time</h3>
                        </div>
                        <div class="chart-container" data-capture-title="Average Recovery Time">
                            <canvas id="injuryRecoveryTimeChart"></canvas>
                        </div>
                    </div>
                    <div class="chart-card">
                        <div class="chart-header">
                            <h3 class="chart-title">Estimated Cost Impact</h3>
                        </div>
                        <div class="chart-container" data-capture-title="Estimated Cost Impact">
                            <canvas id="injuryCostImpactChart"></canvas>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Near Miss Module -->
        <div id="nearmiss" class="tab-content">
            <!-- Sub Navigation -->
            <div class="sub-nav">
                <div class="sub-nav-item active" onclick="switchNearMissView('dashboard')">Dashboard</div>
                <div class="sub-nav-item" onclick="switchNearMissView('riskMatrix')">Risk Matrix</div>
                <div class="sub-nav-item" onclick="switchNearMissView('timeline')">Timeline</div>
                <div class="sub-nav-item" onclick="switchNearMissView('quality')">Quality Assessment</div>
                <div class="sub-nav-item" onclick="switchNearMissView('analytics')">Advanced Analytics</div>
            </div>

            <!-- Dashboard View -->
            <div id="nearMissDashboard" class="nearmiss-view">
                <div class="control-panel">
                    <div class="control-header">
                        <h2 class="control-title">Near Miss Analysis</h2>
                        <div class="quick-actions">
                            <button class="btn btn-primary" onclick="generateNearMissReport()">
                                <span>üìÑ</span> Generate Report
                            </button>
                            <button class="btn btn-secondary" onclick="exportNearMissData()">
                                <span>üìä</span> Export Excel
                            </button>
                        </div>
                    </div>

                    <div class="upload-area" id="nearMissUploadArea" ondrop="handleDrop(event, 'nearmiss')" ondragover="handleDragOver(event)" ondragleave="handleDragLeave(event)">
                        <p style="margin-bottom: 0.5rem;">üìÅ Drag and drop your near miss CSV file here</p>
                        <label for="nearMissFile" class="upload-label">Choose File</label>
                        <input type="file" id="nearMissFile" class="file-input" accept=".csv" onchange="handleFileUpload(event, 'nearmiss')">
                        <p style="margin-top: 0.5rem; font-size: 0.8rem; color: var(--text-secondary);">
                            Supports CSV files with near miss tracking data
                        </p>
                    </div>

                    <div class="filter-section">
                        <div class="filter-group">
                            <label class="filter-label">Site</label>
                            <select class="filter-input" id="nearMissSiteFilter" onchange="applyFilters('nearmiss')">
                                <option value="">All Sites</option>
                            </select>
                        </div>
                        <div class="filter-group">
                            <label class="filter-label">Potential Severity</label>
                            <select class="filter-input" id="nearMissSeverityFilter" onchange="applyFilters('nearmiss')">
                                <option value="">All Severities</option>
                                <option value="A">A - Critical</option>
                                <option value="B">B - High</option>
                                <option value="C">C - Medium</option>
                                <option value="D">D - Low</option>
                            </select>
                        </div>
                        <div class="filter-group">
                            <label class="filter-label">Primary Impact</label>
                            <select class="filter-input" id="nearMissPrimaryImpactFilter" onchange="applyFilters('nearmiss')">
                                <option value="">All Impacts</option>
                            </select>
                        </div>
                        <div class="filter-group">
                            <label class="filter-label">Location</label>
                            <select class="filter-input" id="nearMissLocationFilter" onchange="applyFilters('nearmiss')">
                                <option value="">All Locations</option>
                            </select>
                        </div>
                        <div class="filter-group">
                            <label class="filter-label">Process Path</label>
                            <select class="filter-input" id="nearMissProcessFilter" onchange="applyFilters('nearmiss')">
                                <option value="">All Processes</option>
                            </select>
                        </div>
                        <div class="filter-group">
                            <label class="filter-label">Likelihood</label>
                            <select class="filter-input" id="nearMissLikelihoodFilter" onchange="applyFilters('nearmiss')">
                                <option value="">All Likelihoods</option>
                                <option value="Rare">Rare</option>
                                <option value="Unlikely">Unlikely</option>
                                <option value="Possible">Possible</option>
                                <option value="Likely">Likely</option>
                                <option value="Almost Certain">Almost Certain</option>
                            </select>
                        </div>
                        <div class="filter-group">
                            <label class="filter-label">Date From</label>
                            <input type="date" class="filter-input" id="nearMissDateFrom" onchange="applyFilters('nearmiss')">
                        </div>
                        <div class="filter-group">
                            <label class="filter-label">Date To</label>
                            <input type="date" class="filter-input" id="nearMissDateTo" onchange="applyFilters('nearmiss')">
                        </div>
                    </div>
                </div>

                <!-- Near Miss Metrics -->
                <div class="metrics-grid" id="nearMissMetrics">
                    <div class="metric-card">
                        <div class="metric-icon">‚ö†Ô∏è</div>
                        <div class="metric-value" id="nearMissTotal">0</div>
                        <div class="metric-label">Total Near Misses</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-icon">üìä</div>
                        <div class="metric-value" id="nearMissRisk">0.0</div>
                        <div class="metric-label">Average Risk Score</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-icon">üö®</div>
                        <div class="metric-value" id="nearMissHigh">0</div>
                        <div class="metric-label">High Severity (A & B)</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-icon">‚úÖ</div>
                        <div class="metric-value" id="nearMissRepeat">0%</div>
                        <div class="metric-label">Closure Rate</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-icon">‚ö°</div>
                        <div class="metric-value" id="nearMissActionable">0</div>
                        <div class="metric-label">Requires Action</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-icon">üìà</div>
                        <div class="metric-value" id="nearMissFrequency">0.0</div>
                        <div class="metric-label">Frequency Rate</div>
                    </div>
                </div>

                <!-- Near Miss Charts -->
                <div class="charts-grid">
                    <div class="chart-card">
                        <div class="chart-header">
                            <h3 class="chart-title">Analysis View 1</h3>
                            <select class="filter-input" style="width: auto;" onchange="updateNearMissChart(1, this.value)">
                                <option value="severity">Severity Distribution</option>
                                <option value="site">Site Comparison</option>
                                <option value="trend">Monthly Trend</option>
                                <option value="location">Top Locations</option>
                                <option value="impact">Primary Impacts</option>
                                <option value="process">Process Paths</option>
                                <option value="likelihood">Likelihood Analysis</option>
                                <option value="riskTrend">Risk Score Trend</option>
                            </select>
                        </div>
                        <div class="chart-container" data-capture-title="Near Miss Analysis View 1">
                            <canvas id="nearMissChart1"></canvas>
                        </div>
                    </div>
                    <div class="chart-card">
                        <div class="chart-header">
                            <h3 class="chart-title">Analysis View 2</h3>
                            <select class="filter-input" style="width: auto;" onchange="updateNearMissChart(2, this.value)">
                                <option value="severity">Severity Distribution</option>
                                <option value="site">Site Comparison</option>
                                <option value="trend">Monthly Trend</option>
                                <option value="location">Top Locations</option>
                                <option value="impact">Primary Impacts</option>
                                <option value="process">Process Paths</option>
                                <option value="likelihood">Likelihood Analysis</option>
                                <option value="riskTrend">Risk Score Trend</option>
                            </select>
                        </div>
                        <div class="chart-container" data-capture-title="Near Miss Analysis View 2">
                            <canvas id="nearMissChart2"></canvas>
                        </div>
                    </div>
                    <div class="chart-card">
                        <div class="chart-header">
                            <h3 class="chart-title">Analysis View 3</h3>
                            <select class="filter-input" style="width: auto;" onchange="updateNearMissChart(3, this.value)">
                                <option value="severity">Severity Distribution</option>
                                <option value="site">Site Comparison</option>
                                <option value="trend">Monthly Trend</option>
                                <option value="location">Top Locations</option>
                                <option value="impact">Primary Impacts</option>
                                <option value="process">Process Paths</option>
                                <option value="likelihood">Likelihood Analysis</option>
                                <option value="riskTrend">Risk Score Trend</option>
                            </select>
                        </div>
                        <div class="chart-container" data-capture-title="Near Miss Analysis View 3">
                            <canvas id="nearMissChart3"></canvas>
                        </div>
                    </div>
                    <div class="chart-card">
                        <div class="chart-header">
                            <h3 class="chart-title">Analysis View 4</h3>
                            <select class="filter-input" style="width: auto;" onchange="updateNearMissChart(4, this.value)">
                                <option value="severity">Severity Distribution</option>
                                <option value="site">Site Comparison</option>
                                <option value="trend">Monthly Trend</option>
                                <option value="location">Top Locations</option>
                                <option value="impact">Primary Impacts</option>
                                <option value="process">Process Paths</option>
                                <option value="likelihood">Likelihood Analysis</option>
                                <option value="riskTrend">Risk Score Trend</option>
                            </select>
                        </div>
                        <div class="chart-container" data-capture-title="Near Miss Analysis View 4">
                            <canvas id="nearMissChart4"></canvas>
                        </div>
                    </div>
                </div>

                <!-- Near Miss Table -->
                <div class="table-container">
                    <div class="table-header">
                        <h3>Recent Near Miss Reports</h3>
                        <button class="btn btn-sm btn-outline" onclick="exportTable('nearmiss')">
                            <span>üìä</span> Export
                        </button>
                    </div>
                    <div class="table-wrapper">
                        <table id="nearMissTable">
                            <thead>
                                <tr>
                                    <th>Near Miss ID</th>
                                    <th>Date</th>
                                    <th>Site</th>
                                    <th>Location</th>
                                    <th>Process Path</th>
                                    <th>Primary Impact</th>
                                    <th>Severity</th>
                                    <th>Likelihood</th>
                                    <th>Risk Score</th>
                                    <th>Actions</th>
                                </tr>
                            </thead>
                            <tbody id="nearMissTableBody">
                                <tr>
                                    <td colspan="10" style="text-align: center; padding: 2rem;">
                                        No data loaded. Please upload a CSV file.
                                    </td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                    <div class="pagination">
                        <button class="btn btn-sm" onclick="changePage('nearmiss', -1)" id="nearMissPrevBtn">Previous</button>
                        <span class="pagination-info" id="nearMissPageInfo">Page 1 of 1</span>
                        <button class="btn btn-sm" onclick="changePage('nearmiss', 1)" id="nearMissNextBtn">Next</button>
                    </div>
                </div>
            </div>

            <!-- Risk Matrix View -->
            <div id="nearMissRiskMatrix" class="nearmiss-view hidden">
                <div class="card">
                    <h3 style="margin-bottom: 1rem;">Near Miss Risk Assessment Matrix</h3>
                    <p style="color: var(--text-secondary); margin-bottom: 0.5rem; font-size: 0.85rem;">
                        Click on any cell to view incidents in that risk category
                    </p>
                    <div class="risk-matrix" id="nearMissRiskMatrixGrid">
                        <!-- Will be populated dynamically -->
                    </div>
                </div>
            </div>

            <!-- Timeline View -->
            <div id="nearMissTimeline" class="nearmiss-view hidden">
                <div class="timeline-container">
                    <h3 style="margin-bottom: 1rem;">Near Miss Timeline</h3>
                    <div id="nearMissTimelineContent">
                        <p style="text-align: center; padding: 2rem;">Timeline will be displayed after data is loaded.</p>
                    </div>
                    <div class="pagination">
                        <button class="btn btn-sm" onclick="changeTimelinePage('nearmiss', -1)">Previous</button>
                        <span class="pagination-info" id="nearMissTimelinePageInfo">Page 1 of 1</span>
                        <button class="btn btn-sm" onclick="changeTimelinePage('nearmiss', 1)">Next</button>
                    </div>
                </div>
            </div>

            <!-- Quality Assessment View -->
            <div id="nearMissQuality" class="nearmiss-view hidden">
                <div class="quality-score-card">
                    <h3>Data Quality Assessment</h3>
                    <div class="quality-score-value" id="nearMissQualityScore">0%</div>
                    <div class="quality-metrics">
                        <div class="quality-metric">
                            <div style="font-size: 1.5rem; font-weight: 700;" id="nearMissCompleteness">0%</div>
                            <div style="font-size: 0.85rem;">Completeness</div>
                        </div>
                        <div class="quality-metric">
                            <div style="font-size: 1.5rem; font-weight: 700;" id="nearMissAccuracy">0%</div>
                            <div style="font-size: 0.85rem;">Accuracy</div>
                        </div>
                        <div class="quality-metric">
                            <div style="font-size: 1.5rem; font-weight: 700;" id="nearMissConsistency">0%</div>
                            <div style="font-size: 0.85rem;">Consistency</div>
                        </div>
                        <div class="quality-metric">
                            <div style="font-size: 1.5rem; font-weight: 700;" id="nearMissTimeliness">0%</div>
                            <div style="font-size: 0.85rem;">Timeliness</div>
                        </div>
                    </div>
                </div>

                <div class="card" style="margin-top: 1rem;">
                    <h4 style="margin-bottom: 1rem;">Quality Issues Detected</h4>
                    <div id="nearMissQualityIssues">
                        <p style="color: var(--text-secondary);">Quality assessment will appear after data is loaded.</p>
                    </div>
                </div>

        <div class="card" style="margin-top: 1rem;">
                    <h4 style="margin-bottom: 1rem;">Duplicate Detection</h4>
                    <div id="nearMissDuplicates">
                        <p style="color: var(--text-secondary);">Duplicate analysis will appear after data is loaded.</p>
                    </div>
                </div>
                <!-- Word count and heat map for near miss quality -->
                <div class="card" style="margin-top: 1rem;">
                    <h4 style="margin-bottom: 1rem;">Word Count Summary</h4>
                    <p id="nearMissWordCount" style="font-size: 0.9rem; color: var(--text-secondary);">Word count analysis will appear after data is loaded.</p>
                </div>
                <div class="card" style="margin-top: 1rem;">
                    <h4 style="margin-bottom: 1rem;">Word Heat Map</h4>
                    <div id="nearMissWordHeatMap" class="word-heatmap"></div>
                </div>
            </div>

            <!-- Advanced Analytics View -->
            <div id="nearMissAnalytics" class="nearmiss-view hidden">
                <div class="charts-grid">
                    <div class="chart-card">
                        <div class="chart-header">
                            <h3 class="chart-title">Near Miss to Injury Ratio</h3>
                        </div>
                        <div class="chart-container" data-capture-title="Near Miss to Injury Ratio">
                            <canvas id="nearMissToInjuryRatioChart"></canvas>
                        </div>
                    </div>
                    <div class="chart-card">
                        <div class="chart-header">
                            <h3 class="chart-title">Emerging Risk Locations</h3>
                        </div>
                        <div class="chart-container" data-capture-title="Emerging Risk Locations">
                            <canvas id="nearMissPredictiveRiskChart"></canvas>
                        </div>
                    </div>
                    <div class="chart-card">
                        <div class="chart-header">
                            <h3 class="chart-title">Risk Hotspots</h3>
                        </div>
                        <div class="chart-container" data-capture-title="Risk Hotspots">
                            <canvas id="nearMissHotspotChart"></canvas>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Combined Analytics Module -->
        <div id="combined" class="tab-content">
            <div class="control-panel">
                <div class="control-header">
                    <h2 class="control-title">Combined Safety Analytics</h2>
                    <div>
                        <button class="btn btn-primary" onclick="generateWBRReport()">
                            <span>üìÑ</span> Generate Combined Report
                        </button>
                    </div>
                </div>
                <!-- Unified filters for the combined analytics.  This mirrors the overview
                     and module-specific filters so users can slice data consistently across
                     all dashboards.  The filter ids are namespaced with "combined" to
                     avoid duplicate IDs on the page.  Each dropdown calls
                     applyCombinedFilters() on change to propagate selections to the
                     underlying injury and near miss modules, refresh the overview, and
                     update the combined analytics itself.  Options are populated
                     dynamically once data is loaded. -->
                <div id="combinedFilters" class="filter-section" style="display: none; margin-top: 1rem; gap: 1rem;">
                    <div class="filter-group">
                        <label class="filter-label">Site</label>
                        <select class="filter-input" id="combinedSiteFilter" onchange="applyCombinedFilters()">
                            <option value="">All Sites</option>
                        </select>
                    </div>
                    <div class="filter-group">
                        <label class="filter-label">Severity</label>
                        <select class="filter-input" id="combinedSeverityFilter" onchange="applyCombinedFilters()">
                            <option value="">All Severities</option>
                            <option value="A">A - Critical</option>
                            <option value="B">B - High</option>
                            <option value="C">C - Medium</option>
                            <option value="D">D - Low</option>
                        </select>
                    </div>
                    <div class="filter-group">
                        <label class="filter-label">Date From</label>
                        <input type="date" class="filter-input" id="combinedDateFrom" onchange="applyCombinedFilters()">
                    </div>
                    <div class="filter-group">
                        <label class="filter-label">Date To</label>
                        <input type="date" class="filter-input" id="combinedDateTo" onchange="applyCombinedFilters()">
                    </div>
                    <div class="filter-group">
                        <label class="filter-label">Body Part</label>
                        <select class="filter-input" id="combinedBodyPartFilter" onchange="applyCombinedFilters()">
                            <option value="">All Body Parts</option>
                        </select>
                    </div>
                    <div class="filter-group">
                        <label class="filter-label">Impact</label>
                        <select class="filter-input" id="combinedImpactFilter" onchange="applyCombinedFilters()">
                            <option value="">All Impacts</option>
                        </select>
                    </div>
                    <div class="filter-group">
                        <label class="filter-label">Location</label>
                        <select class="filter-input" id="combinedLocationFilter" onchange="applyCombinedFilters()">
                            <option value="">All Locations</option>
                        </select>
                    </div>
                    <div class="filter-group">
                        <label class="filter-label">Process Path</label>
                        <select class="filter-input" id="combinedProcessFilter" onchange="applyCombinedFilters()">
                            <option value="">All Processes</option>
                        </select>
                    </div>
                    <div class="filter-group">
                        <label class="filter-label">Likelihood</label>
                        <select class="filter-input" id="combinedLikelihoodFilter" onchange="applyCombinedFilters()">
                            <option value="">All Likelihoods</option>
                        </select>
                    </div>
                </div>
            </div>

            <!-- Combined Metrics -->
            <div class="metrics-grid">
                <div class="metric-card">
                    <div class="metric-icon">üìä</div>
                    <div class="metric-value" id="combinedTotal">0</div>
                    <div class="metric-label">Total Safety Events</div>
                </div>
                <div class="metric-card">
                    <div class="metric-icon">‚ö†Ô∏è</div>
                    <div class="metric-value" id="combinedHighRisk">0</div>
                    <div class="metric-label">High Risk Events</div>
                </div>
                <div class="metric-card">
                    <div class="metric-icon">üìà</div>
                    <div class="metric-value" id="combinedTrend">0%</div>
                    <div class="metric-label">Monthly Trend</div>
                </div>
                <div class="metric-card">
                    <div class="metric-icon">üéØ</div>
                    <div class="metric-value" id="combinedTargetSites">0</div>
                    <div class="metric-label">Sites Requiring Focus</div>
                </div>
            </div>

            <!-- Risk Matrix -->
            <div class="card">
                <h3 style="margin-bottom: 1rem;">Combined Risk Assessment Matrix</h3>
                <div class="risk-matrix" id="combinedRiskMatrix">
                    <!-- Will be populated dynamically -->
                </div>
            </div>

            <!-- Combined Charts -->
            <div class="charts-grid">
                <div class="chart-card">
                    <div class="chart-header">
                        <h3 class="chart-title">Safety Performance Trend</h3>
                    </div>
                    <div class="chart-container" data-capture-title="Safety Performance Trend">
                        <canvas id="combinedTrendChart"></canvas>
                    </div>
                </div>
                <div class="chart-card">
                    <div class="chart-header">
                        <h3 class="chart-title">Site Safety Comparison</h3>
                    </div>
                    <div class="chart-container" data-capture-title="Site Safety Comparison">
                        <canvas id="combinedSiteChart"></canvas>
                    </div>
                </div>
                <div class="chart-card">
                    <div class="chart-header">
                        <h3 class="chart-title">Severity Analysis</h3>
                    </div>
                    <div class="chart-container" data-capture-title="Severity Analysis">
                        <canvas id="combinedSeverityChart"></canvas>
                    </div>
                </div>
                <div class="chart-card">
                    <div class="chart-header">
                        <h3 class="chart-title">Prevention Effectiveness</h3>
                    </div>
                    <div class="chart-container" data-capture-title="Prevention Effectiveness">
                        <canvas id="combinedPreventionChart"></canvas>
                    </div>
                </div>
            </div>

            <!-- Insights -->
            <div class="card" style="margin-top: 1.5rem;">
                <h3 style="margin-bottom: 1rem;">Key Insights & Correlations</h3>
                <div id="combinedInsights">
                    <p style="color: var(--text-secondary);">Load data to see insights and correlations between injuries and near misses</p>
                </div>
            </div>
        </div>

        <div id="inspections" class="tab-content">
            <div class="control-panel">
                <div class="control-header">
                    <h2 class="control-title">Austin Inspections Tracking</h2>
                    <div>
                        <input type="file" id="inspectionsUpload" class="file-input" accept=".csv" onchange="handleFileUpload(event, 'inspections')">
                        <label for="inspectionsUpload" class="btn btn-primary">
                            <span>üìÅ</span>
                            <span>Import Austin Inspections</span>
                        </label>
                    </div>
                </div>
                <div class="kpi-grid">
                    <div class="kpi-card">
                        <div class="kpi-value" id="overdueInspections">0</div>
                        <div class="kpi-label">Overdue Inspections</div>
                        <div class="kpi-trend danger">‚ö†Ô∏è Require Immediate Action</div>
                    </div>
                    <div class="kpi-card">
                        <div class="kpi-value" id="upcomingInspections">0</div>
                        <div class="kpi-label">Due This Week</div>
                        <div class="kpi-trend warning">üìÖ Schedule Resources</div>
                    </div>
                    <div class="kpi-card">
                        <div class="kpi-value" id="completionRate">0%</div>
                        <div class="kpi-label">Completion Rate</div>
                        <div class="kpi-trend" id="completionTrend">MTD Performance</div>
                    </div>
                    <div class="kpi-card">
                        <div class="kpi-value" id="totalInspections">0</div>
                        <div class="kpi-label">Total Inspections</div>
                        <div class="kpi-trend">This Period</div>
                    </div>
                </div>
                <div class="filters-container">
                    <select id="inspectionSiteFilter" onchange="applyFilters('inspections')">
                        <option value="">All Sites</option>
                    </select>
                    <select id="inspectionStatusFilter" onchange="applyFilters('inspections')">
                        <option value="">All Statuses</option>
                        <option value="overdue">Overdue</option>
                        <option value="upcoming">Upcoming (7 days)</option>
                        <option value="completed">Completed</option>
                        <option value="scheduled">Scheduled</option>
                    </select>
                    <select id="inspectionTypeFilter" onchange="applyFilters('inspections')">
                        <option value="">All Types</option>
                    </select>
                    <input type="date" id="inspectionDateFrom" onchange="applyFilters('inspections')">
                    <input type="date" id="inspectionDateTo" onchange="applyFilters('inspections')">
                </div>
            </div>

            <div class="alert-section" id="overdueAlert" style="display: none;">
                <h3>üö® Overdue Inspections - Immediate Action Required</h3>
                <div id="overdueList"></div>
            </div>

            <div class="chart-grid">
                <div class="chart-container">
                    <h3>Inspections by Site</h3>
                    <canvas id="inspectionsBySite"></canvas>
                </div>
                <div class="chart-container">
                    <h3>Completion Status</h3>
                    <canvas id="inspectionStatus"></canvas>
                </div>
                <div class="chart-container">
                    <h3>Weekly Trend</h3>
                    <canvas id="inspectionTrend"></canvas>
                </div>
                <div class="chart-container">
                    <h3>Type Distribution</h3>
                    <canvas id="inspectionTypes"></canvas>
                </div>
            </div>

            <div class="table-container">
                <h3>Inspection Details</h3>
                <table id="inspectionsTable">
                    <thead>
                        <tr>
                            <th>Site</th>
                            <th>Inspection Type</th>
                            <th>Due Date</th>
                            <th>Status</th>
                            <th>Days Until Due</th>
                            <th>Owner</th>
                            <th>Actions</th>
                        </tr>
                    </thead>
                    <tbody></tbody>
                </table>
                <div class="pagination-controls">
                    <button class="btn btn-sm" onclick="changePage('inspections', -1)" id="inspectionsPrevBtn">Previous</button>
                    <span class="pagination-info" id="inspectionsPageInfo">Page 1 of 1</span>
                    <button class="btn btn-sm" onclick="changePage('inspections', 1)" id="inspectionsNextBtn">Next</button>
                </div>
            </div>
        </div>

        <!-- Reports Module -->
        <div id="reports" class="tab-content">
            <div class="control-panel">
                <div class="control-header">
                    <h2 class="control-title">Report Generation Center</h2>
                </div>
            </div>

            <div class="export-section">
                <h3 style="margin-bottom: 1rem;">Available Reports</h3>
                <div class="export-grid">
                    <button class="btn btn-primary" onclick="generateInjuryReport()">
                        <span>üìÑ</span> 
                        <div>
                            <div>Injury Report</div>
                            <small style="font-size: 0.75rem; opacity: 0.8;">Comprehensive analysis</small>
                        </div>
                    </button>
                    <button class="btn btn-primary" onclick="generateNearMissReport()">
                        <span>üìÑ</span>
                        <div>
                            <div>Near Miss Report</div>
                            <small style="font-size: 0.75rem; opacity: 0.8;">Trends & patterns</small>
                        </div>
                    </button>
                    <button class="btn btn-primary" onclick="generateWBRReport()">
                        <span>üìä</span>
                        <div>
                            <div>Safety WBR Report</div>
                            <small style="font-size: 0.75rem; opacity: 0.8;">Weekly Business Review</small>
                        </div>
                    </button>
                    <button class="btn btn-secondary" onclick="exportToExcel('all')">
                        <span>üìä</span>
                        <div>
                            <div>Export All Data</div>
                            <small style="font-size: 0.75rem; opacity: 0.8;">Excel format</small>
                        </div>
                    </button>
                    <button class="btn btn-secondary" onclick="exportDashboard()">
                        <span>üì∏</span>
                        <div>
                            <div>Dashboard Snapshot</div>
                            <small style="font-size: 0.75rem; opacity: 0.8;">PNG image</small>
                        </div>
                    </button>
                </div>
            </div>

            <div class="card" style="margin-top: 1.5rem;">
                <h3 style="margin-bottom: 1rem;">Report History</h3>
                <div id="reportHistory">
                    <p style="color: var(--text-secondary);">No reports generated yet</p>
                </div>
            </div>
        </div>

        <!-- Action Tracking Module -->
        <div id="actions" class="tab-content">
            <div class="control-panel">
                <div class="control-header">
                    <h2 class="control-title">Action Item Tracking</h2>
                    <button class="btn btn-primary" onclick="addNewAction()">
                        <span>‚ûï</span> Add Action
                    </button>
                </div>
            </div>

            <div class="card">
                <h4 style="color: var(--danger); margin-bottom: 1rem;">
                    <span style="margin-right: 0.5rem;">üö®</span>
                    Immediate Actions Required
                </h4>
                <div id="immediateActions">
                    <p style="color: var(--text-secondary);">No immediate actions identified. Load data to see recommendations.</p>
                </div>
            </div>

            <div class="card" style="margin-top: 1rem;">
                <h4 style="color: var(--warning); margin-bottom: 1rem;">
                    <span style="margin-right: 0.5rem;">‚ö°</span>
                    Short-term Actions (30 days)
                </h4>
                <div id="shortTermActions">
                    <p style="color: var(--text-secondary);">Actions will be generated based on data analysis.</p>
                </div>
            </div>

            <div class="card" style="margin-top: 1rem;">
                <h4 style="color: #2196F3; margin-bottom: 1rem;">
                    <span style="margin-right: 0.5rem;">üéØ</span>
                    Long-term Improvements
                </h4>
                <div id="longTermActions">
                    <p style="color: var(--text-secondary);">Strategic improvements will be suggested based on trends.</p>
                </div>
            </div>
        </div>
    </div>

    <!-- Help Modal -->
    <div id="helpModal" class="modal">
        <div class="modal-content help-modal-content">
            <div class="modal-header">
                <h3>Safety Analytics Help</h3>
                <button class="modal-close" onclick="closeHelpModal()">&times;</button>
            </div>
            <div class="help-tabs">
                <button class="help-tab active" data-section="welcome">Welcome</button>
                <button class="help-tab" data-section="quickstart">Quick Start</button>
                <button class="help-tab" data-section="features">Features</button>
                <button class="help-tab" data-section="modules">Modules</button>
                <button class="help-tab" data-section="tips">Tips &amp; Shortcuts</button>
            </div>
            <div class="help-body">
                <section id="welcome" class="help-section active">
                    <h2 class="section-title"><i class="fa-solid fa-handshake"></i> Welcome</h2>
                    <p><strong>Welcome to Safety Analytics Platform v2.0</strong></p>
                    <p>Your comprehensive tool for tracking workplace safety incidents and near misses</p>
                    <p class="text-muted">Developed by Erwin Esener | Amazon WHS Austria</p>
                    <img src="https://via.placeholder.com/600x300?text=Dashboard+Demo" alt="Platform demo" class="demo-image">
                </section>

                <section id="quickstart" class="help-section">
                    <h2 class="section-title"><i class="fa-solid fa-bolt"></i> Quick Start Guide</h2>
                    <div class="quick-step">
                        <div class="quick-step-number">1</div>
                        <div class="quick-step-content">
                            <h4>Upload Data</h4>
                            <p>Import your CSV files using the upload buttons</p>
                            <div class="progress"><div class="progress-bar" style="animation-delay:0s"></div></div>
                            <button class="btn btn-primary try-btn" onclick="tryNow('injury','injuryUploadArea')">Try Now</button>
                        </div>
                    </div>
                    <div class="quick-step">
                        <div class="quick-step-number">2</div>
                        <div class="quick-step-content">
                            <h4>Navigate Modules</h4>
                            <p>Use the sidebar to switch between different analytics views</p>
                            <div class="progress"><div class="progress-bar" style="animation-delay:0.2s"></div></div>
                            <button class="btn btn-primary try-btn" onclick="tryNow('injury')">Try Now</button>
                        </div>
                    </div>
                    <div class="quick-step">
                        <div class="quick-step-number">3</div>
                        <div class="quick-step-content">
                            <h4>Apply Filters</h4>
                            <p>Filter data by date, site, severity to focus your analysis</p>
                            <div class="progress"><div class="progress-bar" style="animation-delay:0.4s"></div></div>
                        </div>
                    </div>
                    <div class="quick-step">
                        <div class="quick-step-number">4</div>
                        <div class="quick-step-content">
                            <h4>View Insights</h4>
                            <p>Explore charts, tables, and KPIs for actionable insights</p>
                            <div class="progress"><div class="progress-bar" style="animation-delay:0.6s"></div></div>
                        </div>
                    </div>
                    <div class="quick-step">
                        <div class="quick-step-number">5</div>
                        <div class="quick-step-content">
                            <h4>Generate Reports</h4>
                            <p>Export PDF reports or Excel files for sharing</p>
                            <div class="progress"><div class="progress-bar" style="animation-delay:0.8s"></div></div>
                        </div>
                    </div>
                </section>

                <section id="features" class="help-section">
                    <h2 class="section-title"><i class="fa-solid fa-star"></i> Key Features</h2>
                    <div class="features-grid">
                        <div class="feature-card help-card">
                            <i class="fa-solid fa-chart-line"></i>
                            <h4>Interactive Dashboards</h4>
                            <p>Real-time KPIs and trend analysis</p>
                        </div>
                        <div class="feature-card help-card">
                            <i class="fa-solid fa-triangle-exclamation"></i>
                            <h4>Injury &amp; Illness Tracking</h4>
                            <p>OSHA compliance and recordkeeping</p>
                        </div>
                        <div class="feature-card help-card">
                            <i class="fa-solid fa-exclamation-circle"></i>
                            <h4>Near Miss Analysis</h4>
                            <p>Proactive risk identification</p>
                        </div>
                        <div class="feature-card help-card">
                            <i class="fa-solid fa-table-cells-large"></i>
                            <h4>Risk Matrix</h4>
                            <p>Visual risk assessment and scoring</p>
                        </div>
                        <div class="feature-card help-card">
                            <i class="fa-solid fa-file-export"></i>
                            <h4>Report Generation</h4>
                            <p>Professional PDF and Excel exports</p>
                        </div>
                        <div class="feature-card help-card">
                            <i class="fa-solid fa-filter"></i>
                            <h4>Advanced Filtering</h4>
                            <p>Multi-dimensional data exploration</p>
                        </div>
                    </div>
                </section>

                <section id="modules" class="help-section">
                    <h2 class="section-title"><i class="fa-solid fa-layer-group"></i> Module Overview</h2>
                    <div class="help-card">
                        <h4>Overview</h4>
                        <p>Main dashboard with key metrics</p>
                        <button class="btn btn-secondary try-btn" onclick="tryNow('overview')">Try Now</button>
                    </div>
                    <div class="help-card">
                        <h4>Injury &amp; Illness</h4>
                        <p>Detailed incident tracking and analysis</p>
                        <button class="btn btn-secondary try-btn" onclick="tryNow('injury')">Try Now</button>
                    </div>
                    <div class="help-card">
                        <h4>Near Miss</h4>
                        <p>Proactive safety event monitoring</p>
                        <button class="btn btn-secondary try-btn" onclick="tryNow('nearmiss')">Try Now</button>
                    </div>
                    <div class="help-card">
                        <h4>Combined Analytics</h4>
                        <p>Cross-module insights and comparisons</p>
                        <button class="btn btn-secondary try-btn" onclick="tryNow('combined')">Try Now</button>
                    </div>
                    <div class="help-card">
                        <h4>Reports</h4>
                        <p>Professional report generation tools</p>
                        <button class="btn btn-secondary try-btn" onclick="tryNow('reports')">Try Now</button>
                    </div>
                </section>

                <section id="tips" class="help-section">
                    <h2 class="section-title"><i class="fa-solid fa-lightbulb"></i> Tips &amp; Shortcuts</h2>
                    <ul class="help-list">
                        <li>Use keyboard shortcuts (<kbd>Ctrl</kbd>+<kbd>S</kbd> to export, <kbd>Ctrl</kbd>+<kbd>P</kbd> for PDF)</li>
                        <li>Toggle dark/light mode</li>
                        <li>Export data anytime</li>
                        <li>Filter combinations for deeper insights</li>
                    </ul>
                </section>
            </div>
        </div>
    </div>

    <!-- Modal for details -->
    <div id="detailModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 id="modalTitle">Details</h3>
                <button class="modal-close" onclick="closeModal()">&times;</button>
            </div>
            <div id="modalBody">
                <!-- Content will be populated dynamically -->
            </div>
        </div>
    </div>

    <!-- Footer -->
    <footer class="footer">
        <p>
            Safety Analytics Platform v2.0 | Amazon WHS Austria | 
            Developed by <a href="https://twitter.com/eeesener" target="_blank">Erwin Esener @eeesener</a> | 
            ¬© 2024 Amazon.com, Inc.
        </p>
    </footer>

    <script>
       // Global State Management
const state = {
    injury: {
        rawData: [],
        filteredData: [],
        charts: {},
        currentPage: 1,
        timelinePage: 1,
        qualityMetrics: {},
        sort: { column: 'incident_date', direction: 'desc' }
    },
    nearMiss: {
        rawData: [],
        filteredData: [],
        charts: {},
        currentPage: 1,
        timelinePage: 1,
        qualityMetrics: {},
        sort: { column: 'nearmiss_date', direction: 'desc' }
    },
    inspections: {
        rawData: [],
        filteredData: [],
        charts: {},
        currentPage: 1,
        overdueCount: 0,
        upcomingCount: 0,
        completedCount: 0
    },
    currentModule: 'overview',
    theme: 'light',
    itemsPerPage: 20
};

// Constants
const SEVERITY_COLORS = {
    'A': '#B71C1C',
    'B': '#FF5722',
    'C': '#FFC107',
    'D': '#4CAF50',
    'Unknown': '#9E9E9E'
};

// Amazon Brand Colors
const AMAZON_COLORS = {
    orange: '#FF9900',
    darkBlue: '#232F3E',
    lightBlue: '#37475A',
    gray: '#131A22',
    smile: '#FF9900'
};

/**
 * Convert a hex colour (e.g. "#FF9900") into an RGB array.
 * jsPDF requires colour values to be provided as separate R, G, B numbers.  When
 * passing the raw hex codes directly to jsPDF it attempts to parse the
 * individual digits which results in invalid colour values and errors like
 * "Invalid argument passed to jsPDF.f2".  This helper ensures colours are
 * properly converted before being used in the PDF generator.
 *
 * @param {string} hex A hexadecimal colour string beginning with '#'.
 * @returns {number[]} An array [r, g, b] representing the colour.
 */
function hexToRgb(hex) {
    if (!hex) return [0, 0, 0];
    let h = hex.replace('#', '');
    // If a shorthand hex code is provided (e.g. #abc) expand it to full form.
    if (h.length === 3) {
        h = h.split('').map(ch => ch + ch).join('');
    }
    const bigint = parseInt(h, 16);
    const r = (bigint >> 16) & 255;
    const g = (bigint >> 8) & 255;
    const b = bigint & 255;
    return [r, g, b];
}

// ---------------------------------------------------------------------------
// Enhanced safety analytics helpers and KPI calculators
// ---------------------------------------------------------------------------

const REPORT_THEME = {
    primary: '#FF9900',
    secondary: '#232F3E',
    accent: '#37475A',
    success: '#4CAF50',
    warning: '#FFC107',
    danger: '#B71C1C',
    neutral: '#9E9E9E',
    background: '#F4F6F8'
};

const SEVERITY_SCORES = { A: 4, B: 3, C: 2, D: 1 };
const LIKELIHOOD_SCORES = {
    'very likely': 4,
    'likely': 3,
    'possible': 2,
    'unlikely': 1,
    'rare': 1,
    'low': 1
};

function normaliseString(value, fallback = 'Unknown') {
    if (typeof value === 'string') {
        const trimmed = value.trim();
        return trimmed.length ? trimmed : fallback;
    }
    if (value === null || value === undefined) {
        return fallback;
    }
    return String(value);
}

function getSeverityScore(severity) {
    if (!severity) return 0;
    const key = normaliseString(severity, '').toUpperCase();
    return SEVERITY_SCORES[key] || 0;
}

function getLikelihoodScore(value) {
    if (value === null || value === undefined) return 1;
    if (typeof value === 'number') {
        if (Number.isFinite(value)) {
            return Math.max(1, Math.min(4, Number(value)));
        }
        return 1;
    }
    const key = normaliseString(value, '').toLowerCase();
    if (!key) return 1;
    return LIKELIHOOD_SCORES[key] || 1;
}

function parseDateFromRecord(record, preferredField) {
    if (!record) return null;
    if (record.parsedDate instanceof Date && !Number.isNaN(record.parsedDate)) {
        return record.parsedDate;
    }
    const candidates = [];
    if (preferredField && record[preferredField]) {
        candidates.push(record[preferredField]);
    }
    candidates.push(
        record.incident_date,
        record.nearmiss_date,
        record.date,
        record.event_date,
        record.report_date
    );
    for (const candidate of candidates) {
        if (!candidate) continue;
        const parsed = new Date(candidate);
        if (!Number.isNaN(parsed)) {
            return parsed;
        }
    }
    return null;
}

function getDateRangeLabel(data, preferredField) {
    if (!Array.isArray(data) || data.length === 0) {
        return 'No data available';
    }
    const dates = data
        .map(item => parseDateFromRecord(item, preferredField))
        .filter(date => date instanceof Date && !Number.isNaN(date.getTime()))
        .sort((a, b) => a - b);
    if (!dates.length) {
        return 'No data available';
    }
    const formatter = new Intl.DateTimeFormat('en-GB', {
        day: '2-digit', month: 'short', year: 'numeric'
    });
    return `${formatter.format(dates[0])} ‚Äì ${formatter.format(dates[dates.length - 1])}`;
}

function isClosedStatus(status) {
    if (!status) return false;
    const value = normaliseString(status, '').toLowerCase();
    return /(closed|complete|resolved|implemented|finished|done)/.test(value);
}

function safeDivide(numerator, denominator) {
    if (!denominator) return 0;
    return numerator / denominator;
}

function calculateTrendIndicators(data, period = 30, preferredField) {
    if (!Array.isArray(data) || !data.length) {
        return { current: 0, previous: 0, change: 0, direction: 'flat', indicator: '‚Üí 0%' };
    }
    const now = new Date();
    const currentStart = new Date(now);
    currentStart.setHours(0, 0, 0, 0);
    currentStart.setDate(currentStart.getDate() - (period - 1));
    const previousStart = new Date(currentStart);
    previousStart.setDate(previousStart.getDate() - period);
    let current = 0;
    let previous = 0;
    data.forEach(item => {
        const date = parseDateFromRecord(item, preferredField);
        if (!date) return;
        if (date >= currentStart && date <= now) {
            current += 1;
        } else if (date >= previousStart && date < currentStart) {
            previous += 1;
        }
    });
    let change = 0;
    let direction = 'flat';
    if (previous === 0 && current === 0) {
        change = 0;
        direction = 'flat';
    } else if (previous === 0) {
        change = current > 0 ? 100 : 0;
        direction = current > 0 ? 'up' : 'flat';
    } else {
        change = ((current - previous) / previous) * 100;
        direction = change > 0 ? 'up' : change < 0 ? 'down' : 'flat';
    }
    const symbol = direction === 'up' ? '‚Üë' : direction === 'down' ? '‚Üì' : '‚Üí';
    const indicator = `${symbol} ${Math.abs(change).toFixed(1)}%`;
    return {
        current,
        previous,
        change: Number.isFinite(change) ? Number(change.toFixed(1)) : 0,
        direction,
        indicator
    };
}

function calculateSumTrend(data, field, period = 30, preferredField) {
    if (!Array.isArray(data) || !data.length) {
        return { current: 0, previous: 0, change: 0, direction: 'flat', indicator: '‚Üí 0%' };
    }
    const now = new Date();
    const currentStart = new Date(now);
    currentStart.setHours(0, 0, 0, 0);
    currentStart.setDate(currentStart.getDate() - (period - 1));
    const previousStart = new Date(currentStart);
    previousStart.setDate(previousStart.getDate() - period);
    let current = 0;
    let previous = 0;
    data.forEach(item => {
        const date = parseDateFromRecord(item, preferredField);
        if (!date) return;
        const value = Number(item[field]) || 0;
        if (date >= currentStart && date <= now) {
            current += value;
        } else if (date >= previousStart && date < currentStart) {
            previous += value;
        }
    });
    let change = 0;
    let direction = 'flat';
    if (previous === 0 && current === 0) {
        change = 0;
        direction = 'flat';
    } else if (previous === 0) {
        change = current > 0 ? 100 : 0;
        direction = current > 0 ? 'up' : 'flat';
    } else {
        change = ((current - previous) / previous) * 100;
        direction = change > 0 ? 'up' : change < 0 ? 'down' : 'flat';
    }
    const symbol = direction === 'up' ? '‚Üë' : direction === 'down' ? '‚Üì' : '‚Üí';
    const indicator = `${symbol} ${Math.abs(change).toFixed(1)}%`;
    return {
        current,
        previous,
        change: Number.isFinite(change) ? Number(change.toFixed(1)) : 0,
        direction,
        indicator
    };
}

function calculateAverageTrend(data, valueExtractor, period = 30, preferredField) {
    if (!Array.isArray(data) || !data.length) {
        return { current: 0, previous: 0, change: 0, direction: 'flat', indicator: '‚Üí 0%' };
    }
    const now = new Date();
    const currentStart = new Date(now);
    currentStart.setHours(0, 0, 0, 0);
    currentStart.setDate(currentStart.getDate() - (period - 1));
    const previousStart = new Date(currentStart);
    previousStart.setDate(previousStart.getDate() - period);
    let currentSum = 0;
    let currentCount = 0;
    let previousSum = 0;
    let previousCount = 0;
    data.forEach(item => {
        const date = parseDateFromRecord(item, preferredField);
        if (!date) return;
        const value = valueExtractor(item);
        if (!Number.isFinite(value)) return;
        if (date >= currentStart && date <= now) {
            currentSum += value;
            currentCount += 1;
        } else if (date >= previousStart && date < currentStart) {
            previousSum += value;
            previousCount += 1;
        }
    });
    const current = currentCount ? currentSum / currentCount : 0;
    const previous = previousCount ? previousSum / previousCount : 0;
    let change = 0;
    let direction = 'flat';
    if (previous === 0 && current === 0) {
        change = 0;
    } else if (previous === 0) {
        change = current > 0 ? 100 : 0;
        direction = current > 0 ? 'up' : 'flat';
    } else {
        change = ((current - previous) / previous) * 100;
        direction = change > 0 ? 'up' : change < 0 ? 'down' : 'flat';
    }
    const symbol = direction === 'up' ? '‚Üë' : direction === 'down' ? '‚Üì' : '‚Üí';
    const indicator = `${symbol} ${Math.abs(change).toFixed(1)}%`;
    return {
        current: Number(current.toFixed(2)),
        previous: Number(previous.toFixed(2)),
        change: Number.isFinite(change) ? Number(change.toFixed(1)) : 0,
        direction,
        indicator
    };
}

function groupByField(data, field, fallback = 'Unknown') {
    const map = new Map();
    if (!Array.isArray(data)) {
        return map;
    }
    data.forEach(item => {
        const raw = item ? item[field] : null;
        const key = normaliseString(raw, fallback);
        map.set(key, (map.get(key) || 0) + 1);
    });
    return map;
}

function getTopCategories(data, field, limit = 3, fallback = 'Unknown') {
    const grouped = groupByField(data, field, fallback);
    return Array.from(grouped.entries())
        .map(([name, count]) => ({ name, count }))
        .sort((a, b) => b.count - a.count)
        .slice(0, limit);
}

function buildMonthlyTrend(data, months = 6, preferredField) {
    if (!Array.isArray(data)) return [];
    const bucket = new Map();
    data.forEach(item => {
        const date = parseDateFromRecord(item, preferredField);
        if (!date) return;
        const key = `${date.getFullYear()}-${date.getMonth()}`;
        bucket.set(key, (bucket.get(key) || 0) + 1);
    });
    const results = [];
    const now = new Date();
    for (let i = months - 1; i >= 0; i--) {
        const ref = new Date(now.getFullYear(), now.getMonth() - i, 1);
        const key = `${ref.getFullYear()}-${ref.getMonth()}`;
        const label = ref.toLocaleString('en-GB', { month: 'short' });
        results.push({ label, value: bucket.get(key) || 0 });
    }
    return results;
}

function getISOWeek(date) {
    const tmp = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate()));
    const dayNum = tmp.getUTCDay() || 7;
    tmp.setUTCDate(tmp.getUTCDate() + 4 - dayNum);
    const yearStart = new Date(Date.UTC(tmp.getUTCFullYear(), 0, 1));
    return Math.ceil((((tmp - yearStart) / 86400000) + 1) / 7);
}

function getStartOfISOWeek(date) {
    const tmp = new Date(date);
    const day = tmp.getDay() || 7;
    if (day !== 1) {
        tmp.setDate(tmp.getDate() - (day - 1));
    }
    tmp.setHours(0, 0, 0, 0);
    return tmp;
}

function buildWeeklyTrend(injuryData, nearMissData, weeks = 12) {
    const injuryBuckets = new Map();
    const nearBuckets = new Map();
    const pushToBucket = (map, date) => {
        const week = getISOWeek(date);
        const key = `${date.getFullYear()}-W${week}`;
        map.set(key, (map.get(key) || 0) + 1);
    };
    (Array.isArray(injuryData) ? injuryData : []).forEach(record => {
        const date = parseDateFromRecord(record, 'incident_date');
        if (!date) return;
        pushToBucket(injuryBuckets, getStartOfISOWeek(date));
    });
    (Array.isArray(nearMissData) ? nearMissData : []).forEach(record => {
        const date = parseDateFromRecord(record, 'nearmiss_date');
        if (!date) return;
        pushToBucket(nearBuckets, getStartOfISOWeek(date));
    });
    const now = new Date();
    const start = getStartOfISOWeek(now);
    const trend = [];
    for (let i = weeks - 1; i >= 0; i--) {
        const weekStart = new Date(start);
        weekStart.setDate(weekStart.getDate() - (i * 7));
        const weekNumber = getISOWeek(weekStart);
        const key = `${weekStart.getFullYear()}-W${weekNumber}`;
        trend.push({
            label: `W${String(weekNumber).padStart(2, '0')}`,
            injuries: injuryBuckets.get(key) || 0,
            nearMisses: nearBuckets.get(key) || 0
        });
    }
    return trend;
}

function generateSiteComparison(data, metric = 'incidents') {
    if (!Array.isArray(data) || !data.length) return [];
    const summary = new Map();
    data.forEach(item => {
        const site = normaliseString(item?.site, 'Unknown');
        if (!summary.has(site)) {
            summary.set(site, {
                site,
                incidents: 0,
                injuries: 0,
                nearMisses: 0,
                recordable: 0,
                severityScore: 0,
                riskScore: 0
            });
        }
        const entry = summary.get(site);
        entry.incidents += 1;
        const isInjury = Boolean(item?.case_number);
        if (isInjury) {
            entry.injuries += 1;
        } else {
            entry.nearMisses += 1;
        }
        if (Number(item?.recordable) === 1) {
            entry.recordable += 1;
        }
        const severity = getSeverityScore(item?.severity || item?.potential_severity);
        const likelihood = getLikelihoodScore(item?.initial_risk_assessment_likeliness);
        if (severity) {
            entry.severityScore += severity;
        }
        entry.riskScore += severity * (likelihood || 1);
    });
    return Array.from(summary.values()).map(entry => {
        const recordableRate = entry.incidents ? (entry.recordable / entry.incidents) * 100 : 0;
        const avgSeverity = entry.incidents ? entry.severityScore / entry.incidents : 0;
        const avgRisk = entry.incidents ? entry.riskScore / entry.incidents : 0;
        let value = entry.incidents;
        if (metric === 'recordableRate') {
            value = recordableRate;
        } else if (metric === 'risk') {
            value = avgRisk;
        }
        return {
            ...entry,
            value,
            recordableRate,
            avgSeverity,
            avgRisk
        };
    }).sort((a, b) => b.value - a.value);
}

function createProcessPathMatrix(data) {
    if (!Array.isArray(data) || !data.length) return [];
    const matrix = new Map();
    data.forEach(item => {
        const process = normaliseString(
            item?.initial_info_process_path || item?.process_path || item?.process,
            'Unspecified'
        );
        if (!matrix.has(process)) {
            matrix.set(process, {
                process,
                incidents: 0,
                recordable: 0,
                severityScore: 0,
                severityA: 0,
                riskTotal: 0
            });
        }
        const entry = matrix.get(process);
        entry.incidents += 1;
        if (Number(item?.recordable) === 1) {
            entry.recordable += 1;
        }
        const severity = getSeverityScore(item?.severity || item?.potential_severity);
        if (severity >= SEVERITY_SCORES.A) {
            entry.severityA += 1;
        }
        entry.severityScore += severity;
        const likelihood = getLikelihoodScore(item?.initial_risk_assessment_likeliness);
        entry.riskTotal += (severity || 1) * (likelihood || 1);
    });
    return Array.from(matrix.values()).map(entry => {
        const avgSeverity = entry.incidents ? entry.severityScore / entry.incidents : 0;
        const riskScore = entry.incidents ? entry.riskTotal / entry.incidents : 0;
        let riskLevel = 'Low';
        if (riskScore >= 3.2) {
            riskLevel = 'Critical';
        } else if (riskScore >= 2.4) {
            riskLevel = 'High';
        } else if (riskScore >= 1.6) {
            riskLevel = 'Medium';
        }
        return {
            ...entry,
            avgSeverity,
            riskScore,
            riskLevel,
            recordableRate: entry.incidents ? (entry.recordable / entry.incidents) * 100 : 0
        };
    }).sort((a, b) => b.riskScore - a.riskScore);
}

function analyzePrimaryImpacts(data) {
    if (!Array.isArray(data) || !data.length) return [];
    const impacts = new Map();
    data.forEach(item => {
        const impact = normaliseString(
            item?.initial_info_primary_impact || item?.primary_impact,
            'Unspecified'
        );
        if (!impacts.has(impact)) {
            impacts.set(impact, {
                impact,
                count: 0,
                severityScores: [],
                riskTotal: 0
            });
        }
        const entry = impacts.get(impact);
        entry.count += 1;
        const severity = getSeverityScore(item?.severity || item?.potential_severity);
        if (severity) {
            entry.severityScores.push(severity);
        }
        const likelihood = getLikelihoodScore(item?.initial_risk_assessment_likeliness);
        entry.riskTotal += (severity || 1) * (likelihood || 1);
    });
    const total = Array.from(impacts.values()).reduce((sum, value) => sum + value.count, 0);
    return Array.from(impacts.values()).map(entry => {
        const avgSeverityScore = entry.severityScores.length
            ? entry.severityScores.reduce((a, b) => a + b, 0) / entry.severityScores.length
            : 0;
        const severityLabel = avgSeverityScore >= 3.5 ? 'A'
            : avgSeverityScore >= 2.5 ? 'B'
                : avgSeverityScore >= 1.5 ? 'C'
                    : 'D';
        const avgRisk = entry.count ? entry.riskTotal / entry.count : 0;
        let riskLevel = 'Low';
        if (avgRisk >= 12) {
            riskLevel = 'Critical';
        } else if (avgRisk >= 8) {
            riskLevel = 'High';
        } else if (avgRisk >= 4) {
            riskLevel = 'Medium';
        }
        return {
            name: entry.impact,
            count: entry.count,
            percentage: total ? Number(((entry.count / total) * 100).toFixed(1)) : 0,
            avgSeverity: severityLabel,
            avgRiskScore: Number(avgRisk.toFixed(1)),
            riskLevel
        };
    }).sort((a, b) => b.count - a.count);
}

function calculateSafetyKPIs(injuryDataInput, nearMissDataInput) {
    const injuryData = Array.isArray(injuryDataInput) ? injuryDataInput : [];
    const nearMissData = Array.isArray(nearMissDataInput) ? nearMissDataInput : [];
    const combinedData = [...injuryData, ...nearMissData];
    const hoursWorkedValue = Number(state?.hoursWorked);
    const hoursWorked = Number.isFinite(hoursWorkedValue) && hoursWorkedValue > 0 ? hoursWorkedValue : 200000;

    // Injury KPIs
    const injuryTrend = calculateTrendIndicators(injuryData, 30, 'incident_date');
    const recordableInjuries = injuryData.filter(item => Number(item?.recordable) === 1);
    const recordableTrend = calculateTrendIndicators(recordableInjuries, 30, 'incident_date');
    const dafwTrend = calculateSumTrend(injuryData, 'total_dafw_days', 30, 'incident_date');
    const lostTimeCasesData = injuryData.filter(item => (Number(item?.total_dafw_days) || 0) > 0);
    const lostTimeTrend = calculateTrendIndicators(lostTimeCasesData, 30, 'incident_date');
    const severityTrend = calculateAverageTrend(injuryData, item => getSeverityScore(item?.severity), 30, 'incident_date');

    const recordableCount = recordableInjuries.length;
    const totalInjuries = injuryData.length;
    const dafwTotal = injuryData.reduce((sum, item) => sum + (Number(item?.total_dafw_days) || 0), 0);
    const lostTimeCases = lostTimeCasesData.length;
    const trir = hoursWorked ? (recordableCount / hoursWorked) * 200000 : 0;
    const ltir = hoursWorked ? (lostTimeCases / hoursWorked) * 200000 : 0;
    const severitySum = injuryData.reduce((sum, item) => sum + getSeverityScore(item?.severity), 0);
    const avgSeverityScore = totalInjuries ? severitySum / totalInjuries : 0;
    const recordableRate = totalInjuries ? (recordableCount / totalInjuries) * 100 : 0;
    const monthlyInjuryTrend = buildMonthlyTrend(injuryData, 6, 'incident_date');
    const topBodyParts = getTopCategories(injuryData, 'initial_info_principal_body_part', 3);
    const topBodyPartsDetailed = topBodyParts.map(item => ({
        ...item,
        percentage: totalInjuries ? Number(((item.count / totalInjuries) * 100).toFixed(1)) : 0
    }));
    const topRootCauses = getTopCategories(injuryData, 'rca_primary_cause', 3);
    const topRootCausesDetailed = topRootCauses.map(item => ({
        ...item,
        percentage: totalInjuries ? Number(((item.count / totalInjuries) * 100).toFixed(1)) : 0
    }));

    const injuryKPIs = {
        dateRange: getDateRangeLabel(injuryData, 'incident_date'),
        totalIncidents: totalInjuries,
        trend: injuryTrend,
        recordableCount,
        recordableRate,
        recordableTrend,
        recordableRateColor: recordableRate > 8 ? REPORT_THEME.danger : recordableRate >= 5 ? REPORT_THEME.warning : REPORT_THEME.success,
        dafwTotal,
        dafwTrend,
        lostTimeCases,
        ltir,
        ltirTrend: lostTimeTrend,
        trir,
        trirTrend: recordableTrend,
        avgSeverityScore,
        severityTrend,
        topBodyParts: topBodyPartsDetailed,
        topRootCauses: topRootCausesDetailed,
        monthlyTrend: monthlyInjuryTrend
    };

    // Near Miss KPIs
    const nearMissTrend = calculateTrendIndicators(nearMissData, 30, 'nearmiss_date');
    const highRiskNearMisses = nearMissData.filter(item => {
        const severity = normaliseString(item?.potential_severity || item?.severity, '').toUpperCase();
        return severity === 'A' || severity === 'B';
    });
    const highRiskTrend = calculateTrendIndicators(highRiskNearMisses, 30, 'nearmiss_date');
    const riskTrend = calculateAverageTrend(nearMissData, item => {
        const severity = getSeverityScore(item?.potential_severity || item?.severity);
        const likelihood = getLikelihoodScore(item?.initial_risk_assessment_likeliness);
        return severity * (likelihood || 1);
    }, 30, 'nearmiss_date');
    const riskScores = nearMissData.map(item => {
        const severity = getSeverityScore(item?.potential_severity || item?.severity);
        const likelihood = getLikelihoodScore(item?.initial_risk_assessment_likeliness);
        return severity * (likelihood || 1);
    }).filter(score => Number.isFinite(score));
    const avgRiskScore = riskScores.length ? riskScores.reduce((a, b) => a + b, 0) / riskScores.length : 0;
    const totalNearMisses = nearMissData.length;
    const nearMissRatioValue = totalInjuries ? safeDivide(totalNearMisses, totalInjuries) : 0;
    const closureCount = nearMissData.filter(item => isClosedStatus(item?.status)).length;
    const closureRate = totalNearMisses ? (closureCount / totalNearMisses) * 100 : 0;
    const closureTrend = calculateAverageTrend(nearMissData, item => isClosedStatus(item?.status) ? 1 : 0, 30, 'nearmiss_date');
    const topImpactDetails = analyzePrimaryImpacts(nearMissData).slice(0, 3);
    const topLocations = getTopCategories(nearMissData, 'initial_info_location_event', 3);
    const topLocationsDetailed = topLocations.map(item => ({
        ...item,
        percentage: totalNearMisses ? Number(((item.count / totalNearMisses) * 100).toFixed(1)) : 0
    }));
    const repeatLocationCount = Array.from(groupByField(nearMissData, 'initial_info_location_event', 'Unspecified').values())
        .filter(count => count > 1).length;
    const nearMissMonthlyTrend = buildMonthlyTrend(nearMissData, 6, 'nearmiss_date');

    const nearMissKPIs = {
        dateRange: getDateRangeLabel(nearMissData, 'nearmiss_date'),
        totalNearMisses,
        trend: nearMissTrend,
        highRiskCount: highRiskNearMisses.length,
        highRiskTrend,
        avgRiskScore,
        riskTrend,
        nearMissToInjuryRatio: totalInjuries ? `${nearMissRatioValue.toFixed(1)}:1` : 'N/A',
        nearMissRatioValue,
        topImpacts: topImpactDetails,
        topLocations: topLocationsDetailed,
        closureRate,
        closureTrend,
        repeatLocationCount,
        monthlyTrend: nearMissMonthlyTrend
    };

    // WBR / Combined KPIs
    const recordableScore = Math.min(recordableRate / 8, 1);
    const severityNormalised = avgSeverityScore ? Math.min(Math.max((avgSeverityScore - 1) / 3, 0), 1) : 0;
    const riskNormalised = avgRiskScore ? Math.min(avgRiskScore / 16, 1) : 0;
    const combinedSafetyIndex = (1 - ((recordableScore * 0.4) + (severityNormalised * 0.3) + (riskNormalised * 0.3))) * 100;
    const weeklyTrend = buildWeeklyTrend(injuryData, nearMissData, 12).map(point => ({
        ...point,
        combined: point.injuries + point.nearMisses
    }));
    const sitePerformance = generateSiteComparison(combinedData, 'incidents');
    const processMatrix = createProcessPathMatrix(combinedData);
    const primaryImpactAnalysis = analyzePrimaryImpacts(combinedData);
    const rootCauseMap = new Map();
    combinedData.forEach(item => {
        const cause = normaliseString(item?.rca_primary_cause, 'Unspecified');
        if (!rootCauseMap.has(cause)) {
            rootCauseMap.set(cause, { name: cause, count: 0 });
        }
        rootCauseMap.get(cause).count += 1;
    });
    const rootCausePareto = Array.from(rootCauseMap.values()).sort((a, b) => b.count - a.count);
    let cumulative = 0;
    rootCausePareto.forEach(entry => {
        const percent = combinedData.length ? (entry.count / combinedData.length) * 100 : 0;
        cumulative += percent;
        entry.percentage = Number(percent.toFixed(1));
        entry.cumulative = Number(Math.min(cumulative, 100).toFixed(1));
    });
    const combinedClosed = combinedData.filter(item => isClosedStatus(item?.status)).length;
    const actionClosureRate = combinedData.length ? (combinedClosed / combinedData.length) * 100 : 0;
    const leadingCount = nearMissData.length + combinedClosed;
    const laggingCount = totalInjuries + recordableCount;
    const leadingLagging = {
        leading: leadingCount,
        lagging: laggingCount,
        ratio: laggingCount ? Number((leadingCount / laggingCount).toFixed(1)) : null
    };
    const crossSiteMatrix = sitePerformance.map(site => ({
        site: site.site,
        incidents: site.incidents,
        recordableRate: Number(site.recordableRate.toFixed(1)),
        avgRisk: Number(site.avgRisk.toFixed(1)),
        status: site.recordableRate > 8 ? 'Critical' : site.recordableRate >= 5 ? 'Caution' : 'Performing'
    }));

    const wbrKPIs = {
        period: getDateRangeLabel(combinedData),
        combinedSafetyIndex: Math.max(0, Math.min(100, Math.round(combinedSafetyIndex))),
        totalIncidents: combinedData.length,
        weeklyTrend,
        sitePerformance,
        processMatrix,
        primaryImpacts: primaryImpactAnalysis,
        rootCausePareto,
        actionClosureRate,
        leadingLagging,
        crossSiteMatrix,
        injuryMonthlyTrend: monthlyInjuryTrend,
        nearMissMonthlyTrend,
        nearMissRatio: totalInjuries ? Number(nearMissRatioValue.toFixed(2)) : null
    };

    return {
        injury: injuryKPIs,
        nearMiss: nearMissKPIs,
        wbr: wbrKPIs
    };
}

// ==================== INJURY & ILLNESS REPORT ====================
function generateInjuryReport() {
    const data = Array.isArray(state?.injury?.filteredData) ? state.injury.filteredData : [];
    if (data.length === 0) {
        showStatus('No injury data available for report generation', 'warning');
        return;
    }

    const { jsPDF } = window.jspdf || {};
    if (!jsPDF) {
        showStatus('PDF library not available', 'error');
        return;
    }

    const doc = new jsPDF('p', 'mm', 'a4');
    const pageWidth = doc.internal.pageSize.getWidth();
    const pageHeight = doc.internal.pageSize.getHeight();

    const reportDate = new Date().toLocaleDateString('en-GB');
    const dateRange = getDateRange(data, 'incident_date');

    const totalIncidents = data.length;
    const recordableCount = data.filter(d => Number(d.recordable) === 1).length;
    const recordableRateValue = totalIncidents ? (recordableCount / totalIncidents) * 100 : 0;
    const recordableRate = recordableRateValue.toFixed(1);
    const totalDAFW = data.reduce((sum, d) => sum + (Number(d.total_dafw_days) || 0), 0);
    const hoursWorked = 200000;
    const trirValue = hoursWorked ? (recordableCount / hoursWorked) * 200000 : 0;
    const ltirValue = hoursWorked ? (data.filter(d => (Number(d.total_dafw_days) || 0) > 0).length / hoursWorked) * 200000 : 0;
    const dafwrValue = hoursWorked ? (totalDAFW / hoursWorked) * 200000 : 0;
    const trir = trirValue.toFixed(2);
    const ltir = ltirValue.toFixed(2);
    const dafwr = dafwrValue.toFixed(2);

    const severityCount = data.reduce((acc, d) => {
        const sev = standardizeSeverity(d.severity);
        acc[sev] = (acc[sev] || 0) + 1;
        return acc;
    }, {});
    const avgSeverityScore = calculateAverageSeverity(data);
    const avgSeverityDisplay = Number.isFinite(avgSeverityScore) ? avgSeverityScore.toFixed(1) : '0.0';

    const bodyParts = {};
    data.forEach(d => {
        const part = d.bodyPart || d.initial_info_principal_body_part;
        if (part) {
            bodyParts[part] = (bodyParts[part] || 0) + 1;
        }
    });
    const topBodyParts = Object.entries(bodyParts)
        .sort((a, b) => b[1] - a[1])
        .slice(0, 3);

    const rootCauses = {};
    data.forEach(d => {
        const cause = d.rootCause || d.rca_primary_cause;
        if (cause) {
            rootCauses[cause] = (rootCauses[cause] || 0) + 1;
        }
    });
    const topRootCauses = Object.entries(rootCauses)
        .sort((a, b) => b[1] - a[1])
        .slice(0, 3);

    const siteData = {};
    data.forEach(d => {
        const site = d.site || 'Unknown';
        if (!siteData[site]) {
            siteData[site] = { total: 0, recordable: 0, dafw: 0 };
        }
        siteData[site].total += 1;
        if (Number(d.recordable) === 1) {
            siteData[site].recordable += 1;
        }
        siteData[site].dafw += Number(d.total_dafw_days) || 0;
    });

    let yPos = 20;

    doc.setFillColor(35, 47, 62);
    doc.rect(0, 0, pageWidth, 25, 'F');
    doc.setTextColor(255, 255, 255);
    doc.setFontSize(18);
    doc.setFont('helvetica', 'bold');
    doc.text('Injury & Illness Report', pageWidth / 2, 12, { align: 'center' });
    doc.setFontSize(10);
    doc.setFont('helvetica', 'normal');
    doc.text('Amazon WHS Austria ‚Ä¢ Safety Analytics Platform', pageWidth / 2, 20, { align: 'center' });

    doc.setTextColor(100, 100, 100);
    doc.setFontSize(9);
    doc.text(`Reporting Period: ${dateRange}`, 10, 32);
    doc.text(`Generated: ${reportDate}`, pageWidth - 10, 32, { align: 'right' });

    yPos = 45;
    doc.setFillColor(255, 153, 0);
    doc.rect(10, yPos, 3, 7, 'F');
    doc.setTextColor(35, 47, 62);
    doc.setFontSize(14);
    doc.setFont('helvetica', 'bold');
    doc.text('Executive Summary', 15, yPos + 5);

    yPos += 15;
    const cardWidth = 42;
    const cardHeight = 25;
    const cardSpacing = 5;

    drawKPICard(doc, 10, yPos, cardWidth, cardHeight,
        'Total Incidents', totalIncidents.toString(),
        'baseline', '0.0%', [255, 153, 0]);

    const rrStatus = recordableRateValue > 30 ? 'critical' : recordableRateValue > 20 ? 'warning' : 'good';
    drawKPICard(doc, 10 + cardWidth + cardSpacing, yPos, cardWidth, cardHeight,
        'Recordable Rate', `${recordableRate}%`,
        rrStatus, '0.0%', rrStatus === 'critical' ? [183, 28, 28] : rrStatus === 'warning' ? [255, 193, 7] : [76, 175, 80]);

    const dafwStatus = totalDAFW > 100 ? 'warning' : 'good';
    drawKPICard(doc, 10 + (cardWidth + cardSpacing) * 2, yPos, cardWidth, cardHeight,
        'Days Away', totalDAFW.toString(),
        dafwStatus, '0.0%', [255, 153, 0]);

    const trirStatus = trirValue > 25 ? 'critical' : trirValue > 15 ? 'warning' : 'good';
    drawKPICard(doc, 10 + (cardWidth + cardSpacing) * 3, yPos, cardWidth, cardHeight,
        'TRIR', trir,
        trirStatus, '0.0%', trirStatus === 'critical' ? [183, 28, 28] : trirStatus === 'warning' ? [255, 193, 7] : [76, 175, 80]);

    yPos += cardHeight + 15;
    doc.setFillColor(255, 153, 0);
    doc.rect(10, yPos, 3, 7, 'F');
    doc.setFontSize(14);
    doc.setFont('helvetica', 'bold');
    doc.text('KPI Dashboard', 15, yPos + 5);

    yPos += 12;
    doc.setFontSize(10);
    doc.setFont('helvetica', 'normal');
    doc.setTextColor(60, 60, 60);

    const metrics = [
        ['Days Away From Work (DAFW)', totalDAFW.toString(), 'Total days in period'],
        ['Lost Time Incident Rate (LTIR)', ltir, 'Per 200,000 hours worked'],
        ['DAFW Rate', dafwr, 'Days per 200,000 hours'],
        ['Total Recordable Incident Rate (TRIR)', trir, 'Per 200,000 hours worked'],
        ['Average Severity Score', avgSeverityDisplay, `Scale 1-5 (Current: ${avgSeverityScore > 3 ? 'High' : avgSeverityScore > 2 ? 'Medium' : 'Low'})`],
    ];

    metrics.forEach(metric => {
        doc.setFont('helvetica', 'bold');
        doc.text(metric[0], 15, yPos);
        doc.setFont('helvetica', 'normal');
        doc.setTextColor(35, 47, 62);
        doc.setFontSize(12);
        doc.text(metric[1], 100, yPos);
        doc.setFontSize(9);
        doc.setTextColor(100, 100, 100);
        doc.text(metric[2], 130, yPos);
        yPos += 8;
        doc.setTextColor(60, 60, 60);
        doc.setFontSize(10);
    });

    yPos += 5;
    const bodySectionStart = yPos;
    doc.setFont('helvetica', 'bold');
    doc.text('Top Affected Body Parts', 15, yPos);
    yPos += 6;
    doc.setFont('helvetica', 'normal');
    topBodyParts.forEach(([part, count]) => {
        const percentage = ((count / totalIncidents) * 100).toFixed(0);
        doc.text(`${part}`, 20, yPos);
        doc.text(`${count} (${percentage}%)`, 80, yPos);
        doc.setFillColor(255, 153, 0);
        const barWidth = Math.max(1, (count / totalIncidents) * 50);
        doc.rect(20, yPos + 1, barWidth, 2, 'F');
        yPos += 6;
    });
    const bodySectionEnd = yPos;

    let rootY = bodySectionStart;
    doc.setFont('helvetica', 'bold');
    doc.text('Top Root Causes', 110, rootY);
    rootY += 6;
    doc.setFont('helvetica', 'normal');
    topRootCauses.forEach(([cause, count]) => {
        const percentage = ((count / totalIncidents) * 100).toFixed(0);
        const label = cause.length > 28 ? `${cause.slice(0, 27)}‚Ä¶` : cause;
        doc.text(label, 115, rootY);
        doc.text(`${count} (${percentage}%)`, 175, rootY);
        doc.setFillColor(255, 87, 34);
        const barWidth = Math.max(1, (count / totalIncidents) * 50);
        doc.rect(115, rootY + 1, barWidth, 2, 'F');
        rootY += 6;
    });
    yPos = Math.max(bodySectionEnd, rootY) + 5;

    doc.addPage();
    yPos = 20;

    doc.setFillColor(35, 47, 62);
    doc.rect(0, 0, pageWidth, 15, 'F');
    doc.setTextColor(255, 255, 255);
    doc.setFontSize(12);
    doc.setFont('helvetica', 'bold');
    doc.text('Injury & Illness Analysis', pageWidth / 2, 10, { align: 'center' });

    yPos = 25;
    doc.setTextColor(35, 47, 62);
    doc.setFillColor(255, 153, 0);
    doc.rect(10, yPos, 3, 7, 'F');
    doc.setFontSize(14);
    doc.text('Site Performance Analysis', 15, yPos + 5);

    yPos += 12;
    doc.setFontSize(9);
    doc.setFont('helvetica', 'bold');
    doc.text('Site', 15, yPos);
    doc.text('Total', 45, yPos);
    doc.text('Recordable', 65, yPos);
    doc.text('Rate %', 90, yPos);
    doc.text('DAFW', 110, yPos);
    doc.text('Severity', 130, yPos);
    doc.text('Status', 155, yPos);

    yPos += 5;
    doc.setFont('helvetica', 'normal');
    Object.entries(siteData)
        .sort((a, b) => b[1].total - a[1].total)
        .forEach(([site, siteMetrics]) => {
            if (yPos > pageHeight - 30) {
                doc.addPage();
                yPos = 20;
            }
            const rate = siteMetrics.total ? ((siteMetrics.recordable / siteMetrics.total) * 100).toFixed(1) : '0.0';
            const siteSeverity = calculateAverageSeverity(data.filter(d => (d.site || 'Unknown') === site));
            const status = parseFloat(rate) > 30 ? 'Critical' : parseFloat(rate) > 20 ? 'Warning' : 'Good';

            doc.text(site, 15, yPos);
            doc.text(siteMetrics.total.toString(), 45, yPos);
            doc.text(siteMetrics.recordable.toString(), 65, yPos);
            doc.text(`${rate}%`, 90, yPos);
            doc.text(siteMetrics.dafw.toString(), 110, yPos);
            doc.text(siteSeverity.toFixed(1), 130, yPos);

            if (status === 'Critical') {
                doc.setTextColor(183, 28, 28);
            } else if (status === 'Warning') {
                doc.setTextColor(255, 152, 0);
            } else {
                doc.setTextColor(76, 175, 80);
            }
            doc.text(status, 155, yPos);
            doc.setTextColor(60, 60, 60);

            yPos += 6;
        });

    yPos += 10;
    doc.setFillColor(255, 153, 0);
    doc.rect(10, yPos, 3, 7, 'F');
    doc.setTextColor(35, 47, 62);
    doc.setFontSize(14);
    doc.setFont('helvetica', 'bold');
    doc.text('Key Insights & Strategic Actions', 15, yPos + 5);

    yPos += 12;
    doc.setFontSize(10);
    doc.setFont('helvetica', 'normal');

    const insights = generateInjuryInsights(data, recordableRateValue, totalDAFW, severityCount, topRootCauses);

    insights.forEach(insight => {
        if (yPos > pageHeight - 30) {
            doc.addPage();
            yPos = 20;
        }

        doc.setFont('helvetica', 'bold');
        doc.setTextColor(insight.color[0], insight.color[1], insight.color[2]);
        doc.text(insight.priority, 15, yPos);
        doc.setTextColor(60, 60, 60);
        yPos += 6;

        doc.setFont('helvetica', 'normal');
        insight.actions.forEach(action => {
            const lines = doc.splitTextToSize(`‚Ä¢ ${action}`, pageWidth - 25);
            lines.forEach(line => {
                doc.text(line, 20, yPos);
                yPos += 5;
            });
        });
        yPos += 5;
    });

    const totalPages = doc.internal.getNumberOfPages();
    for (let i = 1; i <= totalPages; i++) {
        doc.setPage(i);
        doc.setFontSize(8);
        doc.setTextColor(150, 150, 150);
        doc.text('Amazon WHS Austria ‚Ä¢ Safety Analytics Platform', pageWidth / 2, pageHeight - 10, { align: 'center' });
        doc.text(`Page ${i} of ${totalPages}`, pageWidth - 10, pageHeight - 10, { align: 'right' });
    }

    const fileName = `Injury_Illness_Report_${new Date().toISOString().split('T')[0]}.pdf`;
    doc.save(fileName);
    addToReportHistory('injury', fileName);
    showStatus('Injury & Illness report generated successfully', 'success');
}

// ==================== NEAR MISS REPORT ====================
function generateNearMissReport() {
    const data = Array.isArray(state?.nearMiss?.filteredData) ? state.nearMiss.filteredData : [];
    if (data.length === 0) {
        showStatus('No near miss data available for report generation', 'warning');
        return;
    }

    const { jsPDF } = window.jspdf || {};
    if (!jsPDF) {
        showStatus('PDF library not available', 'error');
        return;
    }

    const doc = new jsPDF('p', 'mm', 'a4');
    const pageWidth = doc.internal.pageSize.getWidth();
    const pageHeight = doc.internal.pageSize.getHeight();

    const reportDate = new Date().toLocaleDateString('en-GB');
    const dateRange = getDateRange(data, 'nearmiss_date');

    const totalNearMisses = data.length;
    const highRiskCount = data.filter(d => {
        const sev = standardizeSeverity(d.potential_severity);
        return sev === 'A' || sev === 'B';
    }).length;
    const avgRiskScore = data.reduce((sum, d) => sum + Number(d.risk ?? calculateRiskScore(d)), 0) / data.length;
    const avgRiskDisplay = Number.isFinite(avgRiskScore) ? avgRiskScore.toFixed(1) : '0.0';
    const closureRate = 100;

    const injuryCount = Array.isArray(state?.injury?.filteredData) ? state.injury.filteredData.length : 0;
    const nmRatioValue = injuryCount > 0 ? totalNearMisses / injuryCount : null;
    const nmRatioDisplay = nmRatioValue !== null ? nmRatioValue.toFixed(1) : 'N/A';

    const impacts = {};
    data.forEach(d => {
        const impact = d.primaryImpact || d.initial_info_primary_impact || 'Unspecified';
        impacts[impact] = (impacts[impact] || 0) + 1;
    });
    const topImpacts = Object.entries(impacts)
        .sort((a, b) => b[1] - a[1])
        .slice(0, 3);

    const locations = {};
    data.forEach(d => {
        const loc = d.location || d.initial_info_location_event || 'Unknown';
        locations[loc] = (locations[loc] || 0) + 1;
    });
    const topLocations = Object.entries(locations)
        .sort((a, b) => b[1] - a[1])
        .slice(0, 3);
    const repeatLocationCount = Object.values(locations).filter(count => count > 2).length;

    const siteData = {};
    data.forEach(d => {
        const site = d.site || 'Unknown';
        if (!siteData[site]) {
            siteData[site] = {
                total: 0,
                highRisk: 0,
                risks: []
            };
        }
        siteData[site].total += 1;
        const sev = standardizeSeverity(d.potential_severity);
        if (sev === 'A' || sev === 'B') {
            siteData[site].highRisk += 1;
        }
        const riskValue = Number(d.risk ?? calculateRiskScore(d));
        if (Number.isFinite(riskValue)) {
            siteData[site].risks.push(riskValue);
        }
    });

    Object.keys(siteData).forEach(site => {
        const risks = siteData[site].risks;
        siteData[site].avgRisk = risks.length ? risks.reduce((a, b) => a + b, 0) / risks.length : 0;
    });

    let yPos = 20;

    doc.setFillColor(35, 47, 62);
    doc.rect(0, 0, pageWidth, 25, 'F');
    doc.setTextColor(255, 255, 255);
    doc.setFontSize(18);
    doc.setFont('helvetica', 'bold');
    doc.text('Near Miss Report', pageWidth / 2, 12, { align: 'center' });
    doc.setFontSize(10);
    doc.setFont('helvetica', 'normal');
    doc.text('Amazon WHS Austria ‚Ä¢ Safety Analytics Platform', pageWidth / 2, 20, { align: 'center' });

    doc.setTextColor(100, 100, 100);
    doc.setFontSize(9);
    doc.text(`Reporting Period: ${dateRange}`, 10, 32);
    doc.text(`Generated: ${reportDate}`, pageWidth - 10, 32, { align: 'right' });

    yPos = 45;
    doc.setFillColor(33, 150, 243);
    doc.rect(10, yPos, 3, 7, 'F');
    doc.setTextColor(35, 47, 62);
    doc.setFontSize(14);
    doc.setFont('helvetica', 'bold');
    doc.text('Executive Summary', 15, yPos + 5);

    yPos += 15;
    const cardWidth = 42;
    const cardHeight = 25;
    const cardSpacing = 5;

    drawKPICard(doc, 10, yPos, cardWidth, cardHeight,
        'Total Near Misses', totalNearMisses.toString(),
        'baseline', '0.0%', [33, 150, 243]);

    const hrStatus = highRiskCount > 20 ? 'critical' : highRiskCount > 10 ? 'warning' : 'good';
    drawKPICard(doc, 10 + cardWidth + cardSpacing, yPos, cardWidth, cardHeight,
        'High Risk (A/B)', highRiskCount.toString(),
        hrStatus, '0.0%', hrStatus === 'critical' ? [183, 28, 28] : hrStatus === 'warning' ? [255, 193, 7] : [76, 175, 80]);

    const riskStatus = avgRiskScore > 4 ? 'critical' : avgRiskScore > 3 ? 'warning' : 'good';
    drawKPICard(doc, 10 + (cardWidth + cardSpacing) * 2, yPos, cardWidth, cardHeight,
        'Avg Risk Score', avgRiskDisplay,
        riskStatus, '0.0%', riskStatus === 'critical' ? [183, 28, 28] : riskStatus === 'warning' ? [255, 193, 7] : [76, 175, 80]);

    drawKPICard(doc, 10 + (cardWidth + cardSpacing) * 3, yPos, cardWidth, cardHeight,
        'Closure Rate', `${closureRate}%`,
        'good', '0.0%', [76, 175, 80]);

    yPos += cardHeight + 15;
    doc.setFillColor(33, 150, 243);
    doc.rect(10, yPos, 3, 7, 'F');
    doc.setFontSize(14);
    doc.setFont('helvetica', 'bold');
    doc.text('KPI Dashboard', 15, yPos + 5);

    yPos += 12;
    doc.setFontSize(10);
    doc.setFont('helvetica', 'normal');
    doc.setTextColor(60, 60, 60);

    const metrics = [
        ['High Risk Events (A/B)', highRiskCount.toString(), `${((highRiskCount / totalNearMisses) * 100).toFixed(0)}% of total`],
        ['Average Risk Score', avgRiskDisplay, avgRiskScore > 4 ? 'Critical' : avgRiskScore > 3 ? 'High' : avgRiskScore > 2 ? 'Medium' : 'Low'],
        ['Near Miss to Injury Ratio', nmRatioValue !== null ? `${nmRatioDisplay}:1` : 'N/A', nmRatioValue !== null ? (nmRatioValue > 3 ? 'Good reporting culture' : 'Needs improvement') : 'Requires injury data'],
        ['Investigation Closure Rate', `${closureRate}%`, 'Actions completed'],
        ['Repeat Location Count', repeatLocationCount.toString(), 'Locations with >2 events']
    ];

    metrics.forEach(metric => {
        doc.setFont('helvetica', 'bold');
        doc.text(metric[0], 15, yPos);
        doc.setFont('helvetica', 'normal');
        doc.setTextColor(35, 47, 62);
        doc.setFontSize(12);
        doc.text(metric[1], 80, yPos);
        doc.setFontSize(9);
        doc.setTextColor(100, 100, 100);
        doc.text(metric[2], 110, yPos);
        yPos += 8;
        doc.setTextColor(60, 60, 60);
        doc.setFontSize(10);
    });

    yPos += 5;
    const impactSectionStart = yPos;
    doc.setFont('helvetica', 'bold');
    doc.text('Top Primary Impacts', 15, yPos);
    yPos += 6;
    doc.setFont('helvetica', 'normal');
    topImpacts.forEach(([impact, count]) => {
        const percentage = ((count / totalNearMisses) * 100).toFixed(0);
        doc.text(`${impact}`, 20, yPos);
        doc.text(`${count} (${percentage}%)`, 80, yPos);
        doc.setFillColor(33, 150, 243);
        const barWidth = Math.max(1, (count / totalNearMisses) * 50);
        doc.rect(20, yPos + 1, barWidth, 2, 'F');
        yPos += 6;
    });
    const impactSectionEnd = yPos;

    let locationY = impactSectionStart;
    doc.setFont('helvetica', 'bold');
    doc.text('Top Risk Locations', 110, locationY);
    locationY += 6;
    doc.setFont('helvetica', 'normal');
    topLocations.forEach(([location, count]) => {
        const percentage = ((count / totalNearMisses) * 100).toFixed(0);
        const locName = location.length > 20 ? `${location.substring(0, 20)}...` : location;
        doc.text(locName, 115, locationY);
        doc.text(`${count} (${percentage}%)`, 175, locationY);
        doc.setFillColor(156, 39, 176);
        const barWidth = Math.max(1, (count / totalNearMisses) * 50);
        doc.rect(115, locationY + 1, barWidth, 2, 'F');
        locationY += 6;
    });
    yPos = Math.max(impactSectionEnd, locationY) + 5;

    doc.addPage();
    yPos = 20;

    doc.setFillColor(35, 47, 62);
    doc.rect(0, 0, pageWidth, 15, 'F');
    doc.setTextColor(255, 255, 255);
    doc.setFontSize(12);
    doc.setFont('helvetica', 'bold');
    doc.text('Near Miss Analysis', pageWidth / 2, 10, { align: 'center' });

    yPos = 25;
    doc.setTextColor(35, 47, 62);
    doc.setFillColor(33, 150, 243);
    doc.rect(10, yPos, 3, 7, 'F');
    doc.setFontSize(14);
    doc.text('Site Risk Analysis', 15, yPos + 5);

    yPos += 12;
    doc.setFontSize(9);
    doc.setFont('helvetica', 'bold');
    doc.text('Site', 15, yPos);
    doc.text('Total', 45, yPos);
    doc.text('High Risk', 65, yPos);
    doc.text('HR %', 85, yPos);
    doc.text('Avg Risk', 105, yPos);
    doc.text('Status', 130, yPos);

    yPos += 5;
    doc.setFont('helvetica', 'normal');
    Object.entries(siteData)
        .sort((a, b) => b[1].avgRisk - a[1].avgRisk)
        .forEach(([site, siteMetrics]) => {
            if (yPos > pageHeight - 30) {
                doc.addPage();
                yPos = 20;
            }
            const hrRate = siteMetrics.total ? ((siteMetrics.highRisk / siteMetrics.total) * 100).toFixed(0) : '0';
            const status = siteMetrics.avgRisk > 4 ? 'Critical' : siteMetrics.avgRisk > 3 ? 'Warning' : 'Good';

            doc.text(site, 15, yPos);
            doc.text(siteMetrics.total.toString(), 45, yPos);
            doc.text(siteMetrics.highRisk.toString(), 65, yPos);
            doc.text(`${hrRate}%`, 85, yPos);
            doc.text(siteMetrics.avgRisk.toFixed(1), 105, yPos);

            if (status === 'Critical') {
                doc.setTextColor(183, 28, 28);
            } else if (status === 'Warning') {
                doc.setTextColor(255, 152, 0);
            } else {
                doc.setTextColor(76, 175, 80);
            }
            doc.text(status, 130, yPos);
            doc.setTextColor(60, 60, 60);

            yPos += 6;
        });

    yPos += 10;
    doc.setFillColor(33, 150, 243);
    doc.rect(10, yPos, 3, 7, 'F');
    doc.setTextColor(35, 47, 62);
    doc.setFontSize(14);
    doc.setFont('helvetica', 'bold');
    doc.text('Risk Matrix Distribution', 15, yPos + 5);

    yPos += 12;
    const riskMatrix = createRiskMatrixData(data);

    doc.setFontSize(9);
    doc.setFont('helvetica', 'normal');
    const matrixX = 15;
    const matrixY = yPos;

    for (let i = 0; i < 5; i++) {
        for (let j = 0; j < 5; j++) {
            const riskLevel = ((5 - i) * (j + 1)) / 5 * 2;
            if (riskLevel >= 8) {
                doc.setFillColor(183, 28, 28);
            } else if (riskLevel >= 5) {
                doc.setFillColor(255, 152, 0);
            } else if (riskLevel >= 3) {
                doc.setFillColor(255, 193, 7);
            } else {
                doc.setFillColor(76, 175, 80);
            }

            doc.rect(matrixX + j * 12, matrixY + i * 12, 11, 11, 'FD');

            const count = riskMatrix[`${5 - i}-${j + 1}`] || 0;
            if (count > 0) {
                doc.setFontSize(8);
                doc.setTextColor(0, 0, 0);
                doc.text(count.toString(), matrixX + j * 12 + 5.5, matrixY + i * 12 + 6, { align: 'center' });
            }
        }
    }

    doc.setFontSize(8);
    doc.setTextColor(100, 100, 100);
    doc.text('Likelihood ‚Üí', matrixX + 25, matrixY - 3);
    doc.text('‚Üë Severity', matrixX - 10, matrixY + 30);

    yPos = matrixY + 70;
    doc.setFillColor(33, 150, 243);
    doc.rect(10, yPos, 3, 7, 'F');
    doc.setTextColor(35, 47, 62);
    doc.setFontSize(14);
    doc.setFont('helvetica', 'bold');
    doc.text('Key Insights & Strategic Actions', 15, yPos + 5);

    yPos += 12;
    doc.setFontSize(10);
    doc.setFont('helvetica', 'normal');

    const insights = generateNearMissInsights(data, highRiskCount, avgRiskScore, nmRatioValue, topLocations);

    insights.forEach(insight => {
        if (yPos > pageHeight - 30) {
            doc.addPage();
            yPos = 20;
        }

        doc.setFont('helvetica', 'bold');
        doc.setTextColor(insight.color[0], insight.color[1], insight.color[2]);
        doc.text(insight.priority, 15, yPos);
        doc.setTextColor(60, 60, 60);
        yPos += 6;

        doc.setFont('helvetica', 'normal');
        insight.actions.forEach(action => {
            const lines = doc.splitTextToSize(`‚Ä¢ ${action}`, pageWidth - 25);
            lines.forEach(line => {
                doc.text(line, 20, yPos);
                yPos += 5;
            });
        });
        yPos += 5;
    });

    const totalPages = doc.internal.getNumberOfPages();
    for (let i = 1; i <= totalPages; i++) {
        doc.setPage(i);
        doc.setFontSize(8);
        doc.setTextColor(150, 150, 150);
        doc.text('Amazon WHS Austria ‚Ä¢ Safety Analytics Platform', pageWidth / 2, pageHeight - 10, { align: 'center' });
        doc.text(`Page ${i} of ${totalPages}`, pageWidth - 10, pageHeight - 10, { align: 'right' });
    }

    const fileName = `Near_Miss_Report_${new Date().toISOString().split('T')[0]}.pdf`;
    doc.save(fileName);
    addToReportHistory('nearmiss', fileName);
    showStatus('Near Miss report generated successfully', 'success');
}

// ==================== WEEKLY BUSINESS REVIEW (WBR) ====================
function generateWBRReport() {
    const injuryData = Array.isArray(state?.injury?.filteredData) ? state.injury.filteredData : [];
    const nearMissData = Array.isArray(state?.nearMiss?.filteredData) ? state.nearMiss.filteredData : [];

    if (injuryData.length === 0 && nearMissData.length === 0) {
        showStatus('No data available for WBR generation', 'warning');
        return;
    }

    const { jsPDF } = window.jspdf || {};
    if (!jsPDF) {
        showStatus('PDF library not available', 'error');
        return;
    }

    const doc = new jsPDF('p', 'mm', 'a4');
    const pageWidth = doc.internal.pageSize.getWidth();
    const pageHeight = doc.internal.pageSize.getHeight();

    const reportDate = new Date().toLocaleDateString('en-GB');

    const allDates = [
        ...injuryData.map(d => new Date(d.incident_date)),
        ...nearMissData.map(d => new Date(d.nearmiss_date))
    ].filter(d => !isNaN(d));

    const dateRange = allDates.length > 0 ?
        `${new Date(Math.min(...allDates)).toLocaleDateString('en-GB')} - ${new Date(Math.max(...allDates)).toLocaleDateString('en-GB')}` :
        'No date range';

    const totalEvents = injuryData.length + nearMissData.length;
    const injuryRecordable = injuryData.filter(d => Number(d.recordable) === 1).length;
    const combinedRecordableRateValue = injuryData.length ? (injuryRecordable / injuryData.length) * 100 : 0;
    const leadingIndicators = nearMissData.length;
    const laggingIndicators = injuryData.length;
    const leadLagRatioValue = laggingIndicators > 0 ? leadingIndicators / laggingIndicators : null;
    const leadLagRatioDisplay = leadLagRatioValue !== null ? `${leadLagRatioValue.toFixed(1)}` : 'N/A';
    const leadLagText = leadLagRatioValue !== null ? `${leadLagRatioDisplay}:1` : 'N/A';

    const safetyIndex = calculateSafetyIndex(injuryData, nearMissData);
    const actionClosureRate = 100;
    const thisWeekEvents = 0;
    const improvement = safetyIndex > 50 ? 'Improving' : safetyIndex > 30 ? 'Stable' : 'Declining';

    const combinedImpacts = {};
    injuryData.forEach(d => {
        const impact = d.initial_info_impact_type_primary || d.primaryImpact || 'Unspecified';
        combinedImpacts[impact] = (combinedImpacts[impact] || 0) + 1;
    });
    nearMissData.forEach(d => {
        const impact = d.primaryImpact || d.initial_info_primary_impact || 'Unspecified';
        combinedImpacts[impact] = (combinedImpacts[impact] || 0) + 1;
    });
    const topCombinedImpacts = Object.entries(combinedImpacts)
        .sort((a, b) => b[1] - a[1])
        .slice(0, 5);

    const combinedSiteData = {};
    [...injuryData, ...nearMissData].forEach(d => {
        const site = d.site || 'Unknown';
        if (!combinedSiteData[site]) {
            combinedSiteData[site] = {
                injuries: 0,
                nearMisses: 0,
                recordable: 0,
                risks: []
            };
        }
        if (d.incident_date) {
            combinedSiteData[site].injuries += 1;
            if (Number(d.recordable) === 1) {
                combinedSiteData[site].recordable += 1;
            }
        } else {
            combinedSiteData[site].nearMisses += 1;
            const riskValue = Number(d.risk ?? calculateRiskScore(d));
            if (Number.isFinite(riskValue)) {
                combinedSiteData[site].risks.push(riskValue);
            }
        }
    });

    Object.keys(combinedSiteData).forEach(site => {
        const data = combinedSiteData[site];
        data.total = data.injuries + data.nearMisses;
        data.recordableRate = data.injuries > 0 ? ((data.recordable / data.injuries) * 100).toFixed(1) : '0.0';
        data.avgRisk = data.risks.length > 0 ? (data.risks.reduce((a, b) => a + b, 0) / data.risks.length).toFixed(1) : '0.0';
    });

    const sortedSites = Object.entries(combinedSiteData)
        .sort((a, b) => b[1].total - a[1].total)
        .slice(0, 5);

    const processData = {};
    [...injuryData, ...nearMissData].forEach(d => {
        const process = d.processPath || d.initial_info_process_path || 'Unknown';
        if (!processData[process]) {
            processData[process] = {
                count: 0,
                recordable: 0,
                risks: []
            };
        }
        processData[process].count += 1;
        if (Number(d.recordable) === 1) {
            processData[process].recordable += 1;
        }
        const riskValue = Number(d.risk ?? calculateRiskScore(d));
        if (Number.isFinite(riskValue)) {
            processData[process].risks.push(riskValue);
        }
    });

    Object.keys(processData).forEach(process => {
        const data = processData[process];
        data.avgRisk = data.risks.length > 0 ? data.risks.reduce((a, b) => a + b, 0) / data.risks.length : 0;
        data.recordableRate = data.count > 0 ? ((data.recordable / data.count) * 100).toFixed(0) : '0';
    });

    const topProcesses = Object.entries(processData)
        .sort((a, b) => b[1].avgRisk - a[1].avgRisk)
        .slice(0, 6);

    const rootCauses = {};
    injuryData.forEach(d => {
        const cause = d.rootCause || d.rca_primary_cause || 'Unknown';
        rootCauses[cause] = (rootCauses[cause] || 0) + 1;
    });
    nearMissData.forEach(d => {
        const cause = d.rootCause || d.rca_primary_cause || 'Hazardous Condition';
        rootCauses[cause] = (rootCauses[cause] || 0) + 1;
    });
    const sortedCauses = Object.entries(rootCauses)
        .sort((a, b) => b[1] - a[1])
        .slice(0, 5);

    let yPos = 20;

    doc.setFillColor(35, 47, 62);
    doc.rect(0, 0, pageWidth, 25, 'F');
    doc.setTextColor(255, 255, 255);
    doc.setFontSize(18);
    doc.setFont('helvetica', 'bold');
    doc.text('Weekly Business Review', pageWidth / 2, 12, { align: 'center' });
    doc.setFontSize(10);
    doc.setFont('helvetica', 'normal');
    doc.text('Amazon WHS Austria ‚Ä¢ Safety Analytics Platform', pageWidth / 2, 20, { align: 'center' });

    doc.setTextColor(100, 100, 100);
    doc.setFontSize(9);
    doc.text(`Reporting Period: ${dateRange}`, 10, 32);
    doc.text(`Generated: ${reportDate}`, pageWidth - 10, 32, { align: 'right' });

    yPos = 45;
    doc.setFillColor(103, 58, 183);
    doc.rect(10, yPos, 3, 7, 'F');
    doc.setTextColor(35, 47, 62);
    doc.setFontSize(14);
    doc.setFont('helvetica', 'bold');
    doc.text('Executive Summary', 15, yPos + 5);

    yPos += 15;
    const cardWidth = 42;
    const cardHeight = 25;
    const cardSpacing = 5;

    const siStatus = safetyIndex > 60 ? 'good' : safetyIndex > 40 ? 'warning' : 'critical';
    drawKPICard(doc, 10, yPos, cardWidth, cardHeight,
        'Safety Index', `${safetyIndex}%`,
        siStatus, improvement, siStatus === 'good' ? [76, 175, 80] : siStatus === 'warning' ? [255, 193, 7] : [183, 28, 28]);

    drawKPICard(doc, 10 + cardWidth + cardSpacing, yPos, cardWidth, cardHeight,
        'This Week', thisWeekEvents.toString(),
        thisWeekEvents === 0 ? 'good' : 'warning', '0%', thisWeekEvents === 0 ? [76, 175, 80] : [255, 193, 7]);

    drawKPICard(doc, 10 + (cardWidth + cardSpacing) * 2, yPos, cardWidth, cardHeight,
        'Action Closure', `${actionClosureRate}%`,
        'good', 'On target', [76, 175, 80]);

    const llStatus = leadLagRatioValue === null || leadLagRatioValue > 2 ? 'good' : 'warning';
    drawKPICard(doc, 10 + (cardWidth + cardSpacing) * 3, yPos, cardWidth, cardHeight,
        'Lead:Lag Ratio', leadLagText,
        llStatus, 'Healthy', llStatus === 'good' ? [76, 175, 80] : [255, 193, 7]);

    yPos += cardHeight + 15;
    doc.setFillColor(103, 58, 183);
    doc.rect(10, yPos, 3, 7, 'F');
    doc.setFontSize(14);
    doc.setFont('helvetica', 'bold');
    doc.text('Combined KPI Dashboard', 15, yPos + 5);

    yPos += 12;
    doc.setFontSize(10);
    doc.setFont('helvetica', 'normal');

    const metrics = [
        ['Combined Safety Index', `${safetyIndex}%`, improvement],
        ['Action Item Closure', `${actionClosureRate}%`, 'Target: 100%'],
        ['Leading Indicators', leadingIndicators.toString(), 'Near misses & observations'],
        ['Lagging Indicators', laggingIndicators.toString(), 'Injuries & incidents']
    ];

    metrics.forEach(metric => {
        doc.setFont('helvetica', 'bold');
        doc.text(metric[0], 15, yPos);
        doc.setFont('helvetica', 'normal');
        doc.setTextColor(35, 47, 62);
        doc.setFontSize(12);
        doc.text(metric[1], 80, yPos);
        doc.setFontSize(9);
        doc.setTextColor(100, 100, 100);
        doc.text(metric[2], 110, yPos);
        yPos += 8;
        doc.setTextColor(60, 60, 60);
        doc.setFontSize(10);
    });

    yPos += 5;
    doc.setFillColor(103, 58, 183);
    doc.rect(10, yPos, 3, 7, 'F');
    doc.setTextColor(35, 47, 62);
    doc.setFontSize(12);
    doc.setFont('helvetica', 'bold');
    doc.text('Site Performance (Combined)', 15, yPos + 5);

    yPos += 10;
    doc.setFontSize(9);
    doc.setFont('helvetica', 'normal');
    sortedSites.forEach(([site, data], index) => {
        if (yPos > pageHeight - 30) {
            doc.addPage();
            yPos = 20;
        }
        doc.text(`${index + 1}. ${site}`, 15, yPos);
        doc.text(`${data.total} events`, 50, yPos);
        doc.text(`${data.recordableRate}% recordable`, 85, yPos);
        const risk = parseFloat(data.avgRisk);
        if (risk > 4) {
            doc.setTextColor(183, 28, 28);
        } else if (risk > 3) {
            doc.setTextColor(255, 152, 0);
        } else {
            doc.setTextColor(76, 175, 80);
        }
        doc.text(`Risk: ${data.avgRisk}`, 130, yPos);
        doc.setTextColor(60, 60, 60);
        yPos += 6;
    });

    doc.addPage();
    yPos = 20;

    doc.setFillColor(35, 47, 62);
    doc.rect(0, 0, pageWidth, 15, 'F');
    doc.setTextColor(255, 255, 255);
    doc.setFontSize(12);
    doc.setFont('helvetica', 'bold');
    doc.text('Trending & Analysis', pageWidth / 2, 10, { align: 'center' });

    yPos = 25;
    doc.setTextColor(35, 47, 62);
    doc.setFillColor(103, 58, 183);
    doc.rect(10, yPos, 3, 7, 'F');
    doc.setFontSize(14);
    doc.text('Primary Impact Distribution', 15, yPos + 5);

    yPos += 12;
    doc.setFontSize(10);
    doc.setFont('helvetica', 'normal');
    topCombinedImpacts.forEach(([impact, count]) => {
        const percentage = totalEvents ? ((count / totalEvents) * 100).toFixed(0) : '0';
        doc.text(`${impact}`, 20, yPos);
        doc.text(`${count}`, 80, yPos);
        doc.text(`(${percentage}%)`, 100, yPos);
        doc.setFillColor(103, 58, 183);
        const barWidth = totalEvents ? Math.max(1, (count / totalEvents) * 60) : 1;
        doc.rect(120, yPos - 3, barWidth, 4, 'F');
        yPos += 7;
    });

    yPos += 10;
    doc.setFillColor(103, 58, 183);
    doc.rect(10, yPos, 3, 7, 'F');
    doc.setTextColor(35, 47, 62);
    doc.setFontSize(14);
    doc.setFont('helvetica', 'bold');
    doc.text('Process Path Risk Focus', 15, yPos + 5);

    yPos += 12;
    doc.setFontSize(10);
    doc.setFont('helvetica', 'normal');
    topProcesses.forEach(([process, data]) => {
        const riskLevel = data.avgRisk > 4 ? 'Critical' : data.avgRisk > 3 ? 'High' : 'Medium';
        doc.text(`${process}`, 20, yPos);
        doc.text(`Incidents: ${data.count}`, 70, yPos);
        doc.text(`Recordable: ${data.recordableRate}%`, 110, yPos);
        if (riskLevel === 'Critical') {
            doc.setTextColor(183, 28, 28);
        } else if (riskLevel === 'High') {
            doc.setTextColor(255, 152, 0);
        } else {
            doc.setTextColor(255, 193, 7);
        }
        doc.text(`Risk: ${data.avgRisk.toFixed(1)} (${riskLevel})`, 150, yPos);
        doc.setTextColor(60, 60, 60);
        yPos += 7;
    });

    yPos += 10;
    doc.setFillColor(103, 58, 183);
    doc.rect(10, yPos, 3, 7, 'F');
    doc.setTextColor(35, 47, 62);
    doc.setFontSize(14);
    doc.setFont('helvetica', 'bold');
    doc.text('Root Cause Pareto Analysis', 15, yPos + 5);

    yPos += 12;
    doc.setFontSize(10);
    doc.setFont('helvetica', 'normal');
    let cumulative = 0;
    sortedCauses.forEach(([cause, count]) => {
        const percentage = totalEvents ? ((count / totalEvents) * 100).toFixed(1) : '0.0';
        cumulative += parseFloat(percentage);
        const label = cause.length > 30 ? `${cause.slice(0, 29)}‚Ä¶` : cause;
        doc.text(label, 20, yPos);
        doc.text(`${count}`, 80, yPos);
        doc.text(`${percentage}%`, 100, yPos);
        doc.text(`(Cum: ${Math.min(cumulative, 100).toFixed(1)}%)`, 125, yPos);
        yPos += 7;
    });

    doc.addPage();
    yPos = 20;

    doc.setFillColor(35, 47, 62);
    doc.rect(0, 0, pageWidth, 15, 'F');
    doc.setTextColor(255, 255, 255);
    doc.setFontSize(12);
    doc.setFont('helvetica', 'bold');
    doc.text('Strategic Actions & Insights', pageWidth / 2, 10, { align: 'center' });

    yPos = 25;
    doc.setTextColor(35, 47, 62);
    doc.setFillColor(103, 58, 183);
    doc.rect(10, yPos, 3, 7, 'F');
    doc.setFontSize(14);
    doc.text('Cross-site Benchmarking', 15, yPos + 5);

    yPos += 12;
    doc.setFontSize(9);
    doc.setFont('helvetica', 'bold');
    doc.text('Site', 15, yPos);
    doc.text('Incidents', 40, yPos);
    doc.text('Rec. Rate', 65, yPos);
    doc.text('Avg Risk', 90, yPos);
    doc.text('Status', 115, yPos);

    yPos += 5;
    doc.setFont('helvetica', 'normal');
    sortedSites.forEach(([site, data]) => {
        if (yPos > pageHeight - 30) {
            doc.addPage();
            yPos = 20;
        }
        const status = parseFloat(data.avgRisk) > 4 ? 'Critical' : parseFloat(data.avgRisk) > 3 ? 'Warning' : 'Good';
        doc.text(site, 15, yPos);
        doc.text(data.total.toString(), 40, yPos);
        doc.text(`${data.recordableRate}%`, 65, yPos);
        doc.text(data.avgRisk, 90, yPos);
        if (status === 'Critical') {
            doc.setTextColor(183, 28, 28);
        } else if (status === 'Warning') {
            doc.setTextColor(255, 152, 0);
        } else {
            doc.setTextColor(76, 175, 80);
        }
        doc.text(status, 115, yPos);
        doc.setTextColor(60, 60, 60);
        yPos += 6;
    });

    yPos += 10;
    doc.setFillColor(103, 58, 183);
    doc.rect(10, yPos, 3, 7, 'F');
    doc.setTextColor(35, 47, 62);
    doc.setFontSize(14);
    doc.setFont('helvetica', 'bold');
    doc.text('Insights & Strategic Actions', 15, yPos + 5);

    yPos += 12;
    doc.setFontSize(10);
    doc.setFont('helvetica', 'normal');

    const insights = generateWBRInsights(
        injuryData,
        nearMissData,
        safetyIndex,
        leadLagRatioValue,
        sortedCauses[0] ? sortedCauses[0][0] : 'Unknown'
    );

    doc.setFont('helvetica', 'bold');
    doc.text('Current Status:', 15, yPos);
    doc.setFont('helvetica', 'normal');
    yPos += 6;
    insights.status.forEach(item => {
        const lines = doc.splitTextToSize(`‚Ä¢ ${item}`, pageWidth - 25);
        lines.forEach(line => {
            doc.text(line, 20, yPos);
            yPos += 5;
        });
    });

    yPos += 5;

    doc.setFont('helvetica', 'bold');
    doc.setTextColor(183, 28, 28);
    doc.text('Network Priorities:', 15, yPos);
    doc.setTextColor(60, 60, 60);
    doc.setFont('helvetica', 'normal');
    yPos += 6;
    insights.priorities.network.forEach(item => {
        const lines = doc.splitTextToSize(`‚Ä¢ ${item}`, pageWidth - 25);
        lines.forEach(line => {
            doc.text(line, 20, yPos);
            yPos += 5;
        });
    });

    if (yPos > pageHeight - 60) {
        doc.addPage();
        yPos = 20;
    }

    yPos += 5;

    doc.setFont('helvetica', 'bold');
    doc.setTextColor(255, 152, 0);
    doc.text('Short-term Focus:', 15, yPos);
    doc.setTextColor(60, 60, 60);
    doc.setFont('helvetica', 'normal');
    yPos += 6;
    insights.priorities.shortTerm.forEach(item => {
        const lines = doc.splitTextToSize(`‚Ä¢ ${item}`, pageWidth - 25);
        lines.forEach(line => {
            doc.text(line, 20, yPos);
            yPos += 5;
        });
    });

    yPos += 5;

    doc.setFont('helvetica', 'bold');
    doc.setTextColor(76, 175, 80);
    doc.text('Strategic Initiatives:', 15, yPos);
    doc.setTextColor(60, 60, 60);
    doc.setFont('helvetica', 'normal');
    yPos += 6;
    insights.priorities.strategic.forEach(item => {
        const lines = doc.splitTextToSize(`‚Ä¢ ${item}`, pageWidth - 25);
        lines.forEach(line => {
            doc.text(line, 20, yPos);
            yPos += 5;
        });
    });

    const totalPages = doc.internal.getNumberOfPages();
    for (let i = 1; i <= totalPages; i++) {
        doc.setPage(i);
        doc.setFontSize(8);
        doc.setTextColor(150, 150, 150);
        doc.text('Amazon WHS Austria ‚Ä¢ Safety Analytics Platform', pageWidth / 2, pageHeight - 10, { align: 'center' });
        doc.text(`Page ${i} of ${totalPages}`, pageWidth - 10, pageHeight - 10, { align: 'right' });
    }

    const fileName = `WBR_Safety_Report_${new Date().toISOString().split('T')[0]}.pdf`;
    doc.save(fileName);
    addToReportHistory('wbr', fileName);
    showStatus('Weekly Business Review generated successfully', 'success');
}

// ==================== HELPER FUNCTIONS ====================
function drawKPICard(doc, x, y, width, height, title, value, status, trend, color) {
    doc.setFillColor(255, 255, 255);
    doc.setDrawColor(230, 230, 230);
    doc.roundedRect(x, y, width, height, 2, 2, 'FD');

    doc.setFontSize(9);
    doc.setFont('helvetica', 'normal');
    doc.setTextColor(100, 100, 100);
    doc.text(title, x + width / 2, y + 5, { align: 'center' });

    doc.setFontSize(16);
    doc.setFont('helvetica', 'bold');
    doc.setTextColor(color[0], color[1], color[2]);
    doc.text(value, x + width / 2, y + 14, { align: 'center' });

    doc.setFontSize(8);
    doc.setFont('helvetica', 'normal');
    if (status === 'critical') {
        doc.setTextColor(183, 28, 28);
        doc.text('‚¨á ' + trend, x + width / 2, y + 20, { align: 'center' });
    } else if (status === 'warning') {
        doc.setTextColor(255, 152, 0);
        doc.text('‚û° ' + trend, x + width / 2, y + 20, { align: 'center' });
    } else if (status === 'good') {
        doc.setTextColor(76, 175, 80);
        doc.text('‚¨Ü ' + trend, x + width / 2, y + 20, { align: 'center' });
    } else {
        doc.setTextColor(100, 100, 100);
        doc.text('‚óÜ ' + trend, x + width / 2, y + 20, { align: 'center' });
    }
}

function getDateRange(data, dateField) {
    const dates = (Array.isArray(data) ? data : [])
        .map(d => new Date(d[dateField]))
        .filter(d => !isNaN(d))
        .sort((a, b) => a - b);

    if (dates.length === 0) return 'No date range';

    const startDate = dates[0].toLocaleDateString('en-GB', { day: '2-digit', month: 'short', year: 'numeric' });
    const endDate = dates[dates.length - 1].toLocaleDateString('en-GB', { day: '2-digit', month: 'short', year: 'numeric' });

    return `${startDate} ‚Äì ${endDate}`;
}

function calculateAverageSeverity(data) {
    if (!Array.isArray(data) || data.length === 0) {
        return 0;
    }
    const severityValues = { 'A': 5, 'B': 4, 'C': 3, 'D': 2, 'Unknown': 1 };
    const total = data.reduce((sum, d) => {
        const sev = standardizeSeverity(d.severity || d.potential_severity);
        return sum + (severityValues[sev] || 1);
    }, 0);
    return total / data.length;
}

function createRiskMatrixData(data) {
    const matrix = {};
    (Array.isArray(data) ? data : []).forEach(d => {
        const severity = standardizeSeverity(d.potential_severity || d.severity);
        const likelihood = standardizeLikelihood(d.standardized_likelihood || d.initial_risk_assessment_likeliness);
        const severityMap = { 'A': 5, 'B': 4, 'C': 3, 'D': 2, 'Unknown': 1 };
        const likelihoodMap = {
            'Almost Certain': 5,
            'Likely': 4,
            'Possible': 3,
            'Unlikely': 2,
            'Rare': 1,
            'Unknown': 1
        };
        const sevValue = severityMap[severity] || 1;
        const likeValue = likelihoodMap[likelihood] || 1;
        const key = `${sevValue}-${likeValue}`;
        matrix[key] = (matrix[key] || 0) + 1;
    });
    return matrix;
}

function calculateSafetyIndex(injuryData, nearMissData) {
    const injuries = Array.isArray(injuryData) ? injuryData : [];
    const nearMisses = Array.isArray(nearMissData) ? nearMissData : [];
    let score = 100;

    if (injuries.length > 0) {
        const recordableRate = (injuries.filter(d => Number(d.recordable) === 1).length / injuries.length) * 100;
        score -= recordableRate * 0.5;
    }

    const highSeverityCount = [...injuries, ...nearMisses].filter(d => {
        const sev = standardizeSeverity(d.severity || d.potential_severity);
        return sev === 'A' || sev === 'B';
    }).length;
    score -= highSeverityCount * 2;

    const ratio = nearMisses.length / Math.max(injuries.length, 1);
    if (ratio > 3) {
        score += 10;
    } else if (ratio > 2) {
        score += 5;
    }

    return Math.max(0, Math.min(100, Math.round(score)));
}

function generateInjuryInsights(data, recordableRate, totalDAFW, severityCount, topRootCauses) {
    const insights = [];
    const criticalActions = [];
    const highSeverity = (severityCount['A'] || 0) + (severityCount['B'] || 0);

    if (recordableRate > 30) {
        criticalActions.push(`Recordable rate of ${recordableRate.toFixed(1)}% exceeds critical threshold. Immediate intervention required.`);
    }
    if (highSeverity > 0) {
        criticalActions.push(`${highSeverity} high-severity incidents require executive review within 24 hours.`);
    }
    if (totalDAFW > 100) {
        criticalActions.push(`${totalDAFW} days lost impacts productivity. Implement return-to-work program immediately.`);
    }

    if (criticalActions.length > 0) {
        insights.push({
            priority: 'Priority 1 ‚Ä¢ Critical',
            color: [183, 28, 28],
            actions: criticalActions
        });
    }

    const shortTermActions = [];
    if (Array.isArray(topRootCauses) && topRootCauses.length > 0) {
        shortTermActions.push(`Focus corrective actions on top root cause: ${topRootCauses[0][0]} (${topRootCauses[0][1]} incidents).`);
    }
    shortTermActions.push('Conduct safety stand-downs in high-incident areas.');
    shortTermActions.push('Review and update risk assessments for all critical tasks.');

    insights.push({
        priority: 'Priority 2 ‚Ä¢ Short Term',
        color: [255, 152, 0],
        actions: shortTermActions
    });

    insights.push({
        priority: 'Priority 3 ‚Ä¢ Strategic',
        color: [76, 175, 80],
        actions: [
            'Implement predictive analytics to identify injury patterns before they occur.',
            'Develop comprehensive ergonomic assessment program for all workstations.',
            'Establish quarterly safety culture survey with action planning.',
            'Create cross-site best practice sharing forum for injury prevention.'
        ]
    });

    return insights;
}

function generateNearMissInsights(data, highRiskCount, avgRiskScore, nmRatioValue, topLocations) {
    const insights = [];
    const criticalActions = [];

    if (highRiskCount > 20) {
        criticalActions.push(`${highRiskCount} high-risk near misses indicate systemic hazards requiring immediate action.`);
    }
    if (avgRiskScore > 4) {
        criticalActions.push(`Average risk score of ${avgRiskScore.toFixed(1)} exceeds critical threshold. Deploy rapid response team.`);
    }
    if (Array.isArray(topLocations) && topLocations[0] && topLocations[0][1] > 10) {
        criticalActions.push(`${topLocations[0][0]} has ${topLocations[0][1]} events - conduct immediate area assessment.`);
    }

    if (criticalActions.length > 0) {
        insights.push({
            priority: 'Priority 1 ‚Ä¢ Critical',
            color: [183, 28, 28],
            actions: criticalActions
        });
    }

    const shortTermActions = [];
    if (nmRatioValue !== null && nmRatioValue < 3) {
        shortTermActions.push(`Near miss ratio of ${nmRatioValue.toFixed(1)}:1 indicates under-reporting. Launch awareness campaign.`);
    }
    shortTermActions.push('Implement visual management boards for high-risk areas.');
    shortTermActions.push('Establish daily near miss review meetings with operations teams.');

    insights.push({
        priority: 'Priority 2 ‚Ä¢ Short Term',
        color: [255, 152, 0],
        actions: shortTermActions
    });

    insights.push({
        priority: 'Priority 3 ‚Ä¢ Strategic',
        color: [76, 175, 80],
        actions: [
            'Deploy mobile reporting app to increase near miss capture rate.',
            'Integrate near miss data with predictive maintenance systems.',
            'Establish recognition program for proactive hazard identification.',
            'Create heat mapping system for real-time risk visualization.'
        ]
    });

    return insights;
}

function generateWBRInsights(injuryData, nearMissData, safetyIndex, leadLagRatioValue, topRootCause) {
    const insights = {
        status: [],
        priorities: {
            network: [],
            shortTerm: [],
            strategic: []
        }
    };

    const injuries = Array.isArray(injuryData) ? injuryData : [];
    const nearMisses = Array.isArray(nearMissData) ? nearMissData : [];
    const recordableRate = injuries.length > 0 ?
        ((injuries.filter(d => Number(d.recordable) === 1).length / injuries.length) * 100).toFixed(0) : 0;

    insights.status.push(`Recordable rate at ${recordableRate}% ${parseFloat(recordableRate) > 30 ? 'requires urgent attention' : 'within acceptable range'}.`);

    const highSeverityTotal = [...injuries, ...nearMisses].filter(d => {
        const sev = standardizeSeverity(d.severity || d.potential_severity);
        return sev === 'A' || sev === 'B';
    }).length;
    insights.status.push(`${highSeverityTotal} high-severity events recorded this period.`);

    if (leadLagRatioValue !== null) {
        insights.status.push(`Near miss reporting ratio of ${leadLagRatioValue.toFixed(1)}:1 ${leadLagRatioValue > 3 ? 'indicates strong' : 'needs improvement in'} safety culture.`);
    }

    insights.status.push(`Safety Index at ${safetyIndex}% ${safetyIndex > 60 ? 'shows positive trend' : 'requires focused improvement'}.`);

    if (highSeverityTotal > 0) {
        insights.priorities.network.push('Conduct deep-dive investigations for all Severity A/B events with C-suite review.');
    }
    insights.priorities.network.push(`Address primary root cause: ${topRootCause} through targeted interventions.`);
    insights.priorities.network.push('Standardize safety practices across all sites with focus on high-performing locations.');

    insights.priorities.shortTerm.push('Implement daily safety walks with structured observation cards.');
    insights.priorities.shortTerm.push('Launch "See Something, Say Something" campaign to increase reporting.');
    insights.priorities.shortTerm.push('Deploy rapid improvement teams to address top 3 risk areas.');

    insights.priorities.strategic.push('Integrate AI-powered video analytics for proactive hazard detection.');
    insights.priorities.strategic.push('Establish predictive model using leading indicators for injury prevention.');
    insights.priorities.strategic.push('Create digital twin simulations for high-risk process optimization.');
    insights.priorities.strategic.push('Develop comprehensive contractor safety management system.');

    return insights;
}

function generatePDFReport(type) {
    if (type === 'injury') {
        generateInjuryReport();
    } else if (type === 'nearmiss') {
        generateNearMissReport();
    } else {
        generateWBRReport();
    }
}
// Initialize Application
document.addEventListener('DOMContentLoaded', function() {
    console.log('Safety Analytics Platform - Amazon WHS Austria');
    console.log('Developed by Erwin Esener @eeesener');
    initializeCharts();
    setupEventListeners();
    createRiskMatrices();
    setupTableSorting('injury');
    setupTableSorting('nearMiss');
    initializeChartCaptureButtons();

    // Check for saved theme preference
    const savedTheme = localStorage.getItem('theme') || 'light';
    if (savedTheme === 'dark') {
        toggleTheme();
    }
});

// Standardized and categorized chart options for all views
const CHART_OPTIONS = {
    injury: [
        // Distribution & Overview
        { value: 'severity', label: 'üìä Severity Distribution', category: 'distribution' },
        { value: 'site', label: 'üè¢ Site Comparison', category: 'distribution' },
        { value: 'recordableDistribution', label: 'üìù Recordable vs Non-Recordable', category: 'distribution' },

        // Trends
        { value: 'trend', label: 'üìà Monthly Injury Trend', category: 'trends' },
        { value: 'recordableTrend', label: 'üìä Recordable Rate Trend', category: 'trends' },
        { value: 'severityTrend', label: 'üéØ Severity Trend Over Time', category: 'trends' },

        // Body Part Analysis (Injury-specific)
        { value: 'bodyPart', label: 'ü¶¥ Body Parts Affected', category: 'anatomy' },
        { value: 'bodyPartTrend', label: 'üìä Body Part Trends', category: 'anatomy' },
        { value: 'bodyPartHeatmap', label: 'üî• Body Part by Severity', category: 'anatomy' },
        { value: 'bodyPartBySite', label: 'üè¢ Body Parts by Site', category: 'anatomy' },

        // Type & Mechanism (Injury-specific)
        { value: 'injuryType', label: 'üè• Injury Types', category: 'type' },
        { value: 'mechanismOfInjury', label: '‚öôÔ∏è How Injuries Occur', category: 'type' },
        { value: 'injuryTypeByProcess', label: 'üîÑ Injury Type by Process', category: 'type' },

        // Process & Operations
        { value: 'processPath', label: 'üîÑ Process Path Analysis', category: 'operations' },
        { value: 'shiftAnalysis', label: 'üïê Injuries by Shift', category: 'operations' },
        { value: 'departmentAnalysis', label: 'üè≠ Department Analysis', category: 'operations' },

        // Root Cause & Contributing Factors
        { value: 'rootCause', label: 'üîç Root Cause Analysis', category: 'causation' },
        { value: 'contributingFactors', label: 'üîó Contributing Factors', category: 'causation' },
        { value: 'rootCauseBySite', label: 'üè¢ Root Causes by Site', category: 'causation' },
        { value: 'rootCauseTrend', label: 'üìà Root Cause Trends', category: 'causation' },

        // Performance Metrics (Injury-specific)
        { value: 'recordableRate', label: 'üìä Recordable Rate by Site', category: 'metrics' },
        { value: 'dafwAnalysis', label: 'üìÖ Days Away From Work', category: 'metrics' },
        { value: 'dafwDistribution', label: 'üìä DAFW Distribution', category: 'metrics' },
        { value: 'otrAnalysis', label: 'üöó OTR vs UTR Analysis', category: 'metrics' },
        { value: 'lostTimeAnalysis', label: '‚è±Ô∏è Lost Time Analysis', category: 'metrics' },

        // Advanced Analytics
        { value: 'severityPrediction', label: 'üîÆ Severity Patterns', category: 'advanced' },
        { value: 'recoveryTimeAnalysis', label: 'üè• Recovery Time Analysis', category: 'advanced' },
        { value: 'costImpactAnalysis', label: 'üí∞ Cost Impact Analysis', category: 'advanced' }
    ],

    nearMiss: [
        // Distribution & Overview
        { value: 'severity', label: 'üìä Potential Severity Distribution', category: 'distribution' },
        { value: 'site', label: 'üè¢ Site Comparison', category: 'distribution' },
        { value: 'statusDistribution', label: 'üìã Status Overview', category: 'distribution' },

        // Trends
        { value: 'trend', label: 'üìà Near Miss Trend', category: 'trends' },
        { value: 'riskTrend', label: 'üé≤ Risk Score Trend', category: 'trends' },
        { value: 'severityTrend', label: 'üéØ Severity Trend Over Time', category: 'trends' },

        // Location Analysis (Near Miss-specific)
        { value: 'location', label: 'üìç Top Incident Locations', category: 'location' },
        { value: 'locationHeatmap', label: 'üî• Location Risk Heat Map', category: 'location' },
        { value: 'locationTrend', label: 'üìà Location Trends', category: 'location' },
        { value: 'locationBySeverity', label: 'üéØ Location by Severity', category: 'location' },

        // Impact Analysis (Near Miss-specific)
        { value: 'impact', label: 'üí• Primary Impact Types', category: 'impact' },
        { value: 'impactSeverity', label: 'üéØ Impact vs Severity', category: 'impact' },
        { value: 'impactByLocation', label: 'üìç Impact by Location', category: 'impact' },
        { value: 'impactTrend', label: 'üìà Impact Type Trends', category: 'impact' },

        // Process & Operations
        { value: 'processPath', label: 'üîÑ Process Path Analysis', category: 'operations' },
        { value: 'processRisk', label: '‚ö†Ô∏è Process Risk Score', category: 'operations' },
        { value: 'processHeatmap', label: 'üî• Process Risk Heat Map', category: 'operations' },

        // Risk Analysis (Near Miss-specific)
        { value: 'riskScore', label: 'üé≤ Risk Score Distribution', category: 'risk' },
        { value: 'riskMatrix', label: '‚¨ú Risk Matrix Overview', category: 'risk' },
        { value: 'likelihood', label: 'üìä Likelihood Analysis', category: 'risk' },
        { value: 'likelihoodTrend', label: 'üìà Likelihood Trends', category: 'risk' },

        // Contributing Factors
        { value: 'contributingFactors', label: 'üîó Contributing Factors', category: 'causation' },
        { value: 'rootCause', label: 'üîç Root Cause Analysis', category: 'causation' },
        { value: 'hazardCategories', label: '‚ö†Ô∏è Hazard Categories', category: 'causation' },

        // Prevention & Mitigation
        { value: 'preventionEffectiveness', label: 'üõ°Ô∏è Prevention Opportunities', category: 'prevention' },
        { value: 'mitigationStatus', label: '‚úÖ Mitigation Status', category: 'prevention' },
        { value: 'closureAnalysis', label: 'üìä Closure Rate Analysis', category: 'prevention' },

        // Advanced Analytics
        { value: 'nearMissToInjuryRatio', label: 'üìä Near Miss/Injury Correlation', category: 'advanced' },
        { value: 'predictiveRisk', label: 'üîÆ Predictive Risk Areas', category: 'advanced' },
        { value: 'hotspotAnalysis', label: 'üî• Risk Hotspot Analysis', category: 'advanced' }
    ]
};

// Theme Toggle
function toggleTheme() {
    const body = document.body;
    const themeIcon = document.getElementById('themeIcon');
    const themeText = document.getElementById('themeText');
    
    if (body.getAttribute('data-theme') === 'dark') {
        body.removeAttribute('data-theme');
        themeIcon.textContent = 'üåô';
        themeText.textContent = 'Dark Mode';
        state.theme = 'light';
    } else {
        body.setAttribute('data-theme', 'dark');
        themeIcon.textContent = '‚òÄÔ∏è';
        themeText.textContent = 'Light Mode';
        state.theme = 'dark';
    }
    
    localStorage.setItem('theme', state.theme);
    updateAllCharts();
}

// Module Switching
function switchModule(module, evt) {
    document.querySelectorAll('.nav-tab').forEach(tab => {
        tab.classList.remove('active');
    });
    if (evt) {
        const navTab = evt.target.closest('.nav-tab');
        if (navTab) navTab.classList.add('active');
    } else {
        const navTab = document.querySelector(`.nav-tab[data-module="${module}"]`);
        if (navTab) navTab.classList.add('active');
    }

    document.querySelectorAll('.tab-content').forEach(content => {
        content.classList.remove('active');
    });

    document.getElementById(module).classList.add('active');
    state.currentModule = module;

    if (module === 'injury') {
        updateInjuryDashboard();
        updateInjuryTable();
        updateInjuryCharts();
    } else if (module === 'nearmiss') {
        updateNearMissDashboard();
        updateNearMissTable();
        updateNearMissCharts();
    } else if (module === 'combined') {
        updateCombinedAnalytics();
    } else if (module === 'inspections') {
        updateInspectionDashboard();
        updateInspectionTable();
        updateInspectionCharts();
        checkOverdueInspections();
    } else if (module === 'actions') {
        updateActionItems();
    }
}

// Sub-view switching for Injury module
function switchInjuryView(view) {
    document.querySelectorAll('#injury .sub-nav-item').forEach(item => {
        item.classList.remove('active');
    });
    event.target.classList.add('active');
    
    document.querySelectorAll('.injury-view').forEach(v => {
        v.classList.add('hidden');
    });
    
    document.getElementById('injury' + view.charAt(0).toUpperCase() + view.slice(1)).classList.remove('hidden');
    
    if (view === 'timeline') {
        updateInjuryTimeline();
    } else if (view === 'analytics') {
        updateInjuryAdvancedAnalytics();
    } else if (view === 'riskMatrix') {
        updateInjuryRiskMatrix();
    } else if (view === 'quality') {
        updateInjuryQualityMetrics();
    }
}

// Sub-view switching for Near Miss module
function switchNearMissView(view) {
    document.querySelectorAll('#nearmiss .sub-nav-item').forEach(item => {
        item.classList.remove('active');
    });
    event.target.classList.add('active');
    
    document.querySelectorAll('.nearmiss-view').forEach(v => {
        v.classList.add('hidden');
    });
    
    document.getElementById('nearMiss' + view.charAt(0).toUpperCase() + view.slice(1)).classList.remove('hidden');
    
    if (view === 'timeline') {
        updateNearMissTimeline();
    } else if (view === 'analytics') {
        updateNearMissAdvancedAnalytics();
    } else if (view === 'riskMatrix') {
        updateNearMissRiskMatrix();
    } else if (view === 'quality') {
        updateNearMissQualityMetrics();
    }
}

// File Handling
function handleFileUpload(event, type) {
    const file = event.target.files[0];
    if (!file) return;

    showStatus(`Processing ${type} file...`, 'info');

    const reader = new FileReader();
    reader.onload = function(e) {
        const text = e.target.result;
        if (type === 'inspections') {
            parseCSV(text, type);
            return;
        }

        const headerLine = text.split(/\r?\n/)[0].toLowerCase();
        const injuryIndicators = ['incident_date', 'case_number', 'recordable'];
        const nearMissIndicators = ['nearmiss_date', 'incident_id', 'primary_impact'];
        const hasIndicator = (line, arr) => arr.some(ind => line.includes(ind));
        const looksInjury = hasIndicator(headerLine, injuryIndicators);
        const looksNearMiss = hasIndicator(headerLine, nearMissIndicators);

        if (type === 'injury' && looksNearMiss && !looksInjury) {
            showStatus('It looks like you uploaded a Near Miss CSV to the Injury uploader. Please choose the correct file.', 'error');
            return;
        }
        if (type === 'nearmiss' && looksInjury && !looksNearMiss) {
            showStatus('It looks like you uploaded an Injury CSV to the Near Miss uploader. Please choose the correct file.', 'error');
            return;
        }

        parseCSV(text, type);
    };
    reader.onerror = function() {
        showStatus('Error reading file', 'error');
    };
    reader.readAsText(file);
}

// Drag and Drop
function handleDrop(event, type) {
    event.preventDefault();
    event.stopPropagation();
    
    const uploadArea = event.target.closest('.upload-area');
    uploadArea.classList.remove('dragging');
    
    const files = event.dataTransfer.files;
    if (files.length > 0) {
        const file = files[0];
        if (file.type === 'text/csv' || file.name.endsWith('.csv')) {
            const input = type === 'injury' ?
                document.getElementById('injuryFile') :
                type === 'nearmiss' ?
                    document.getElementById('nearMissFile') :
                    document.getElementById('inspectionsUpload');
            
            const dataTransfer = new DataTransfer();
            dataTransfer.items.add(file);
            input.files = dataTransfer.files;
            
            handleFileUpload({ target: input }, type);
        } else {
            showStatus('Please upload a CSV file', 'error');
        }
    }
}

function handleDragOver(event) {
    event.preventDefault();
    event.stopPropagation();
    event.target.closest('.upload-area').classList.add('dragging');
}

function handleDragLeave(event) {
    event.preventDefault();
    event.stopPropagation();
    event.target.closest('.upload-area').classList.remove('dragging');
}

// CSV Parsing
function parseCSV(csvText, type) {
    Papa.parse(csvText, {
        header: true,
        dynamicTyping: true,
        skipEmptyLines: true,
        complete: function(results) {
            if (type === 'injury') {
                state.injury.rawData = results.data;
                processInjuryData();
                populateInjuryFilters();
                applyFilters('injury');
                calculateQualityMetrics('injury');
                showStatus(`Loaded ${results.data.length} injury records successfully!`, 'success');
                initializeChartSelections();
            } else if (type === 'nearmiss') {
                state.nearMiss.rawData = results.data;
                processNearMissData();
                populateNearMissFilters();
                applyFilters('nearmiss');
                calculateQualityMetrics('nearmiss');
                showStatus(`Loaded ${results.data.length} near miss records successfully!`, 'success');
                initializeChartSelections();
            } else if (type === 'inspections') {
                state.inspections.rawData = processInspectionsData(results.data);
                state.inspections.filteredData = [...state.inspections.rawData];
                populateInspectionFilters();
                applyFilters('inspections');
                showStatus(`Loaded ${state.inspections.rawData.length} inspection records successfully!`, 'success');
            }

            updateOverview();
        },
        error: function(error) {
            showStatus('Failed to parse CSV: ' + error.message, 'error');
        }
    });
}

// Initialize chart selections with categorized options
function initializeChartSelections() {
    // Helper function to create categorized dropdown HTML
    const createCategorizedOptions = (options) => {
        const categories = {};

        // Group options by category
        options.forEach(option => {
            if (!categories[option.category]) {
                categories[option.category] = [];
            }
            categories[option.category].push(option);
        });

        // Build HTML with optgroups
        let html = '';
        const categoryLabels = {
            'distribution': 'üìä Distribution & Overview',
            'trends': 'üìà Trend Analysis',
            'anatomy': 'ü¶¥ Body Part Analysis',
            'type': 'üè• Injury Type Analysis',
            'location': 'üìç Location Analysis',
            'impact': 'üí• Impact Analysis',
            'operations': 'üîÑ Operations & Process',
            'causation': 'üîç Root Cause Analysis',
            'metrics': 'üìä Performance Metrics',
            'risk': 'üé≤ Risk Analysis',
            'prevention': 'üõ°Ô∏è Prevention & Mitigation',
            'advanced': 'üî¨ Advanced Analytics'
        };

        Object.entries(categories).forEach(([category, categoryOptions]) => {
            html += `<optgroup label="${categoryLabels[category] || category}">`;
            categoryOptions.forEach(opt => {
                html += `<option value="${opt.value}">${opt.label}</option>`;
            });
            html += '</optgroup>';
        });

        return html;
    };

    // Update Injury chart selectors
    const injuryOptionsHTML = createCategorizedOptions(CHART_OPTIONS.injury);
    const injurySelectors = document.querySelectorAll('#injury .chart-header select');
    injurySelectors.forEach((selector, index) => {
        selector.innerHTML = injuryOptionsHTML;
        // Set different default values for each view
        const injuryDefaults = ['severity', 'bodyPart', 'rootCause', 'trend'];
        selector.value = injuryDefaults[index] || 'severity';
    });

    // Update Near Miss chart selectors
    const nearMissOptionsHTML = createCategorizedOptions(CHART_OPTIONS.nearMiss);
    const nearMissSelectors = document.querySelectorAll('#nearmiss .chart-header select');
    nearMissSelectors.forEach((selector, index) => {
        selector.innerHTML = nearMissOptionsHTML;
        // Set different defaults for near miss
        const nearMissDefaults = ['severity', 'location', 'impact', 'riskTrend'];
        selector.value = nearMissDefaults[index] || 'severity';
    });
}

// Data Processing - Injury
function processInjuryData() {
    state.injury.rawData.forEach((row, index) => {
        // Parse dates
        if (row.incident_date) {
            row.parsedDate = new Date(row.incident_date);
        }
        
        // Standardize severity
        row.severity = standardizeSeverity(row.severity || row.potential_severity);
        
        // Ensure numeric values
        row.recordable = parseInt(row.recordable) || 0;
        row.total_dafw_days = parseInt(row.total_dafw_days) || 0;
        row.total_rwa_days = parseInt(row.total_rwa_days) || 0;
        
        // Generate ID if needed
        if (!row.case_number) {
            row.case_number = `CASE-${index + 1}`;
        }
        
        // Extract body part
        row.bodyPart = row.initial_info_principal_body_part || 
                      row.initial_info_detailed_body_part || 
                      'Unknown';
        
        // Extract OTR status
        if (row.initial_info_incident_on_the_road === true) {
            row.otr = 'yes';
        } else if (row.initial_info_incident_on_the_road === false) {
            row.otr = 'no';
        } else {
            row.otr = row.initial_info_incident_on_the_road || 'no';
            if (typeof row.otr === 'string') {
                row.otr = row.otr.toLowerCase();
            }
            if (row.otr === '1' || row.otr === 'true' || row.otr === 'yes' || row.otr === 'y') {
                row.otr = 'yes';
            } else {
                row.otr = 'no';
            }
        }
        
        // Extract root cause
        row.rootCause = row.rca_primary_cause || 'Under Investigation';
        
        // Extract contributing factors
        row.contributingFactor = row.rca_contributing_factor_category || 'Unknown';
        
        // Process path
        row.processPath = row.initial_info_process_path || 'Unknown';
        
        // Extract Austin URL - check multiple possible column names
        row.austin_url = row.austin_url || 
                        row.austin_case_study_url || 
                        row.austin_link || 
                        row.case_study_url ||
                        row.austin_case_url ||
                        row.incident_url ||
                        '#'; // Fallback to # if no URL found
        
        // Validate URL format
        if (row.austin_url && row.austin_url !== '#') {
            if (!row.austin_url.startsWith('http://') && !row.austin_url.startsWith('https://')) {
                row.austin_url = 'https://' + row.austin_url;
            }
        }
        
        // Standardize likelihood
        row.standardized_likelihood = standardizeLikelihood(row.initial_risk_assessment_likeliness);
        
        // Extract impact type
        row.impactType = row.initial_info_impact_type_primary || row.type || 'Unknown';
    });
}

// Data Processing - Near Miss
function processNearMissData() {
    state.nearMiss.rawData.forEach((row, index) => {
        // Parse dates
        if (row.nearmiss_date) {
            row.parsedDate = new Date(row.nearmiss_date);
        }
        
        // Use potential_severity
        row.severity = standardizeSeverity(row.potential_severity || row.severity);
        
        // Standardize likelihood
        row.standardized_likelihood = standardizeLikelihood(row.initial_risk_assessment_likeliness);
        
        // Calculate risk score if not present
        if (!row.risk || row.risk === '' || row.risk === 0) {
            row.risk = calculateRiskScore(row);
        }
        
        // Generate ID if needed
        if (!row.incident_id) {
            const date = row.parsedDate || new Date();
            const site = (row.site && row.site.trim()) ? row.site.trim() : 'XX';
            const year = date.getFullYear();
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const seq = String(index + 1).padStart(3, '0');
            row.incident_id = `NM-${site}-${year}${month}-${seq}`;
        }
        
        // Extract primary impact
        row.primaryImpact = row.initial_info_primary_impact || 'Unknown';
        row.impactType = row.primaryImpact; // Standardize for chart compatibility

        // Extract location
        row.location = row.initial_info_location_event || 'Unknown';
        
        // Process path
        row.processPath = row.initial_info_process_path || 'Unknown';

        // Extract Austin URL - check multiple possible column names
        row.austin_url = row.austin_url || 
                        row.austin_case_study_url || 
                        row.austin_link || 
                        row.case_study_url ||
                        row.austin_case_url ||
                        row.incident_url ||
                        row.case_url ||
                        row.link ||
                        '#'; // Fallback to # if no URL found

        // Validate URL format
        if (row.austin_url && row.austin_url !== '#') {
            if (!row.austin_url.startsWith('http://') && !row.austin_url.startsWith('https://')) {
                row.austin_url = 'https://' + row.austin_url;
            }
        }

        // Contributing factors
        row.contributingFactor = row.rca_contributing_factor_category || 'Unknown';
        
        // Root cause (for standardization with injury)
        row.rootCause = row.rca_primary_cause || 'Under Investigation';
    });
}

// Austin Inspection processing -------------------------------------------------
function processInspectionsData(rows) {
    if (!Array.isArray(rows)) return [];

    return rows
        .filter(row => row && Object.keys(row).length > 0)
        .map((row, index) => {
            const site = (row.Site || row.site || row.Location || '').toString().trim() || 'Unknown';
            const inspectionName = (row.Inspection || row.inspection || row['Inspection Type'] || row.type || '').toString().trim();
            const type = (row.Type || row.type || inspectionName.split('-')[0] || '').toString().trim() || 'General';
            const dueDateValue = row['Due Date'] || row.due_date || row.dueDate || row.due || row.Due;
            const dueDate = dueDateValue ? new Date(dueDateValue) : null;
            if (dueDate instanceof Date && !isNaN(dueDate)) {
                dueDate.setHours(0, 0, 0, 0);
            }
            const completeValue = parseInt(row.Complete ?? row.complete ?? row.Completed ?? row.StatusComplete ?? 0, 10);
            const complete = Number.isNaN(completeValue) ? 0 : completeValue;
            const owner = (row.Owner || row.owner || row['Action Owner'] || '').toString().trim() || 'TBD';
            const id = (row.ID || row.Id || row.id || row['Inspection ID'] || '').toString().trim() || `INSP-${index + 1}`;
            const status = determineInspectionStatus({ complete, dueDate });
            const daysUntilDue = calculateDaysUntilDue(dueDate);

            return {
                id,
                site,
                inspection: inspectionName || type,
                type,
                dueDate,
                dueDateRaw: dueDateValue || '',
                complete,
                status,
                daysUntilDue,
                owner,
                sourceRow: row
            };
        });
}

function determineInspectionStatus({ complete, dueDate }) {
    if (complete === 1 || complete === true) return 'completed';
    if (!(dueDate instanceof Date) || isNaN(dueDate)) return 'scheduled';

    const days = calculateDaysUntilDue(dueDate);
    if (days < 0) return 'overdue';
    if (days <= 7) return 'upcoming';
    return 'scheduled';
}

function calculateDaysUntilDue(dueDate) {
    if (!(dueDate instanceof Date) || isNaN(dueDate)) return 0;
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    const due = new Date(dueDate.getTime());
    due.setHours(0, 0, 0, 0);
    const diff = (due - today) / (1000 * 60 * 60 * 24);
    return Math.round(diff);
}

function populateInspectionFilters() {
    const siteFilter = document.getElementById('inspectionSiteFilter');
    const typeFilter = document.getElementById('inspectionTypeFilter');

    if (siteFilter) {
        const current = siteFilter.value;
        siteFilter.innerHTML = '<option value="">All Sites</option>';
        const sites = Array.from(new Set(state.inspections.rawData.map(row => row.site).filter(Boolean))).sort();
        sites.forEach(site => {
            const option = document.createElement('option');
            option.value = site;
            option.textContent = site;
            siteFilter.appendChild(option);
        });
        if (current) {
            siteFilter.value = current;
        }
    }

    if (typeFilter) {
        const current = typeFilter.value;
        typeFilter.innerHTML = '<option value="">All Types</option>';
        const types = Array.from(new Set(state.inspections.rawData.map(row => row.type).filter(Boolean))).sort();
        types.forEach(type => {
            const option = document.createElement('option');
            option.value = type;
            option.textContent = type;
            typeFilter.appendChild(option);
        });
        if (current) {
            typeFilter.value = current;
        }
    }
}

function updateInspectionDashboard() {
    const data = Array.isArray(state.inspections.filteredData) ? state.inspections.filteredData : [];
    const total = data.length;
    const overdue = data.filter(item => item.status === 'overdue').length;
    const upcoming = data.filter(item => item.status === 'upcoming').length;
    const completed = data.filter(item => item.status === 'completed').length;
    const completionRate = total > 0 ? Math.round((completed / total) * 100) : 0;

    state.inspections.overdueCount = overdue;
    state.inspections.upcomingCount = upcoming;
    state.inspections.completedCount = completed;

    const overdueEl = document.getElementById('overdueInspections');
    const upcomingEl = document.getElementById('upcomingInspections');
    const completionRateEl = document.getElementById('completionRate');
    const completionTrendEl = document.getElementById('completionTrend');
    const totalEl = document.getElementById('totalInspections');

    if (overdueEl) overdueEl.textContent = overdue;
    if (upcomingEl) upcomingEl.textContent = upcoming;
    if (completionRateEl) completionRateEl.textContent = `${completionRate}%`;
    if (totalEl) totalEl.textContent = total;

    const compliance = calculateInspectionCompliance();
    if (completionTrendEl) {
        if (compliance.total > 0) {
            completionTrendEl.textContent = `MTD: ${compliance.completed}/${compliance.total} completed`;
        } else {
            completionTrendEl.textContent = 'MTD Performance';
        }
    }

    if (overdue === 0) {
        const alertDiv = document.getElementById('overdueAlert');
        if (alertDiv) {
            alertDiv.style.display = 'none';
            const listDiv = document.getElementById('overdueList');
            if (listDiv) listDiv.innerHTML = '';
        }
    }

    updateNotificationBadge(overdue);
}

function formatDaysUntilDue(days) {
    if (days > 0) return `${days} day${days === 1 ? '' : 's'}`;
    if (days < 0) return `${Math.abs(days)} day${Math.abs(days) === 1 ? '' : 's'} overdue`;
    return 'Due today';
}

function getInspectionStatusClass(status) {
    switch (status) {
        case 'overdue':
            return 'status-overdue';
        case 'upcoming':
            return 'status-upcoming';
        case 'completed':
            return 'status-completed';
        default:
            return 'status-scheduled';
    }
}

function updateInspectionTable() {
    const tbody = document.querySelector('#inspectionsTable tbody');
    if (!tbody) return;

    const data = Array.isArray(state.inspections.filteredData) ? state.inspections.filteredData : [];
    const totalPages = Math.max(1, Math.ceil(data.length / state.itemsPerPage));
    if (state.inspections.currentPage > totalPages) {
        state.inspections.currentPage = totalPages;
    }
    if (state.inspections.currentPage < 1) {
        state.inspections.currentPage = 1;
    }

    const startIndex = (state.inspections.currentPage - 1) * state.itemsPerPage;
    const pageData = data.slice(startIndex, startIndex + state.itemsPerPage);

    if (pageData.length === 0) {
        tbody.innerHTML = '<tr><td colspan="7" style="text-align:center; padding:2rem;">No inspections match the current filters.</td></tr>';
        updatePaginationInfo('inspections', 0, 0);
        return;
    }

    tbody.innerHTML = pageData.map(row => {
        const dueDateText = (row.dueDate instanceof Date && !isNaN(row.dueDate)) ?
            row.dueDate.toLocaleDateString() :
            (row.dueDateRaw || 'N/A');
        const statusClass = getInspectionStatusClass(row.status);
        return `
            <tr>
                <td>${row.site || 'Unknown'}</td>
                <td>${row.inspection || 'N/A'}</td>
                <td>${dueDateText}</td>
                <td><span class="inspection-status-badge ${statusClass}">${row.status.charAt(0).toUpperCase() + row.status.slice(1)}</span></td>
                <td>${formatDaysUntilDue(row.daysUntilDue)}</td>
                <td>${row.owner || 'TBD'}</td>
                <td>
                    <button class="btn btn-sm btn-outline" onclick="viewDetails('inspections', '${row.id}')">View</button>
                </td>
            </tr>
        `;
    }).join('');

    updatePaginationInfo('inspections', state.inspections.currentPage, totalPages);
}

function renderInspectionChart(chartId, type, chartData) {
    const canvas = document.getElementById(chartId);
    if (!canvas) return;
    const ctx = canvas.getContext('2d');

    if (!state.inspections.charts[chartId]) {
        state.inspections.charts[chartId] = new Chart(ctx, {
            type,
            data: { labels: [], datasets: [] },
            options: getChartOptions(type)
        });
    }

    const chart = state.inspections.charts[chartId];
    if (chart.config.type !== type) {
        chart.config.type = type;
    }

    chart.options = getChartOptions(type);
    chart.data.labels = chartData.labels || [];
    chart.data.datasets = chartData.datasets || [];
    chart.update();
}

function updateInspectionCharts() {
    const data = Array.isArray(state.inspections.filteredData) ? state.inspections.filteredData : [];
    if (data.length === 0) {
        ['inspectionsBySite', 'inspectionStatus', 'inspectionTrend', 'inspectionTypes'].forEach(id => {
            if (state.inspections.charts[id]) {
                state.inspections.charts[id].data.labels = [];
                state.inspections.charts[id].data.datasets = [];
                state.inspections.charts[id].update();
            }
        });
        return;
    }

    const siteCounts = {};
    const siteCompleted = {};
    const siteOverdue = {};

    data.forEach(item => {
        if (!siteCounts[item.site]) {
            siteCounts[item.site] = 0;
        }
        siteCounts[item.site] += 1;

        if (item.complete === 1) {
            siteCompleted[item.site] = (siteCompleted[item.site] || 0) + 1;
        }
        if (item.status === 'overdue') {
            siteOverdue[item.site] = (siteOverdue[item.site] || 0) + 1;
        }
    });

    const siteLabels = Object.keys(siteCounts);
    renderInspectionChart('inspectionsBySite', 'bar', {
        labels: siteLabels,
        datasets: [
            {
                label: 'Total',
                data: siteLabels.map(site => siteCounts[site] || 0),
                backgroundColor: AMAZON_COLORS.darkBlue
            },
            {
                label: 'Completed',
                data: siteLabels.map(site => siteCompleted[site] || 0),
                backgroundColor: '#4CAF50'
            },
            {
                label: 'Overdue',
                data: siteLabels.map(site => siteOverdue[site] || 0),
                backgroundColor: '#B71C1C'
            }
        ]
    });

    const statusCounts = {
        Completed: data.filter(i => i.status === 'completed').length,
        Upcoming: data.filter(i => i.status === 'upcoming').length,
        Overdue: data.filter(i => i.status === 'overdue').length,
        Scheduled: data.filter(i => i.status === 'scheduled').length
    };

    renderInspectionChart('inspectionStatus', 'doughnut', {
        labels: Object.keys(statusCounts),
        datasets: [
            {
                data: Object.values(statusCounts),
                backgroundColor: ['#4CAF50', '#FFC107', '#B71C1C', '#2196F3']
            }
        ]
    });

    const weeklyTrend = generateWeeklyInspectionTrend(data);
    renderInspectionChart('inspectionTrend', 'line', {
        labels: weeklyTrend.labels,
        datasets: weeklyTrend.datasets
    });

    const typeCounts = {};
    data.forEach(item => {
        const type = item.type || (item.inspection || '').split('-')[0].trim() || 'General';
        typeCounts[type] = (typeCounts[type] || 0) + 1;
    });

    const topTypes = Object.entries(typeCounts)
        .sort((a, b) => b[1] - a[1])
        .slice(0, 6);

    renderInspectionChart('inspectionTypes', 'pie', {
        labels: topTypes.map(([type]) => type),
        datasets: [
            {
                data: topTypes.map(([, count]) => count),
                backgroundColor: generateColorPalette(topTypes.length)
            }
        ]
    });
}

function generateWeeklyInspectionTrend(data) {
    const weekly = {};

    data.forEach(item => {
        if (!(item.dueDate instanceof Date) || isNaN(item.dueDate)) return;
        const week = getISOWeek(item.dueDate);
        const year = item.dueDate.getFullYear();
        const key = `${year}-W${week}`;
        if (!weekly[key]) {
            weekly[key] = { label: `CW${week} ${year}`, total: 0, completed: 0, overdue: 0 };
        }
        weekly[key].total += 1;
        if (item.status === 'completed') weekly[key].completed += 1;
        if (item.status === 'overdue') weekly[key].overdue += 1;
    });

    const sortedKeys = Object.keys(weekly)
        .sort((a, b) => {
            const [yearA, weekA] = a.split('-W').map(Number);
            const [yearB, weekB] = b.split('-W').map(Number);
            if (yearA === yearB) return weekA - weekB;
            return yearA - yearB;
        })
        .slice(-10);

    return {
        labels: sortedKeys.map(key => weekly[key].label),
        datasets: [
            {
                label: 'Total',
                data: sortedKeys.map(key => weekly[key].total),
                borderColor: AMAZON_COLORS.darkBlue,
                backgroundColor: 'rgba(35,47,62,0.1)',
                fill: false,
                tension: 0.3
            },
            {
                label: 'Completed',
                data: sortedKeys.map(key => weekly[key].completed),
                borderColor: '#4CAF50',
                backgroundColor: 'rgba(76,175,80,0.1)',
                fill: false,
                tension: 0.3
            },
            {
                label: 'Overdue',
                data: sortedKeys.map(key => weekly[key].overdue),
                borderColor: '#B71C1C',
                backgroundColor: 'rgba(183,28,28,0.1)',
                fill: false,
                tension: 0.3
            }
        ]
    };
}

function generateColorPalette(count) {
    const palette = ['#232F3E', '#FF9900', '#4CAF50', '#2196F3', '#B71C1C', '#FFC107', '#9C27B0', '#00ACC1'];
    if (count <= palette.length) {
        return palette.slice(0, count);
    }
    const colors = [];
    for (let i = 0; i < count; i++) {
        colors.push(palette[i % palette.length]);
    }
    return colors;
}

function calculateFirstAidersCoverage() {
    const coverage = {
        'DVI1': 14.52,
        'DVI2': 14.29,
        'DVI3': 18.25,
        'DAP5': 21.43,
        'DAP8': 12.21
    };
    const values = Object.values(coverage);
    const average = values.length ? values.reduce((a, b) => a + b, 0) / values.length : 0;
    return average.toFixed(2);
}

function calculateFireMarshallsCoverage() {
    const coverage = {
        'DVI1': 12.37,
        'DVI2': 10.88,
        'DVI3': 11.68,
        'DAP5': 10.2,
        'DAP8': 6.87
    };
    const values = Object.values(coverage);
    const average = values.length ? values.reduce((a, b) => a + b, 0) / values.length : 0;
    return average.toFixed(2);
}

function getNearMissHighlights() {
    const highlights = [];
    const nearMisses = state.nearMiss.filteredData.slice(0, 5);

    nearMisses.forEach(nm => {
        const riskLevel = nm.risk >= 7 ? 'üî¥ High Risk' : nm.risk >= 4 ? 'üü° Medium Risk' : 'üü¢ Low Risk';
        const status = nm.status || 'In Progress';
        highlights.push(`${nm.site || 'Unknown'}: ${nm.initial_info_nearmiss_type || 'Incident'} (${riskLevel}, ${status})`);
    });

    return highlights.join('<br>') || 'No recent near misses';
}

function calculateSiteFirstAiders(site) {
    const coverage = {
        'DVI1': 14.52,
        'DVI2': 14.29,
        'DVI3': 18.25,
        'DAP5': 21.43,
        'DAP8': 12.21
    };
    return (coverage[site] ?? 10).toFixed(2);
}

function calculateSiteFireMarshalls(site) {
    const coverage = {
        'DVI1': 12.37,
        'DVI2': 10.88,
        'DVI3': 11.68,
        'DAP5': 10.2,
        'DAP8': 6.87
    };
    return (coverage[site] ?? 8).toFixed(2);
}

function determineOverallStatus(site) {
    const firstAid = parseFloat(calculateSiteFirstAiders(site));
    const fireMarshall = parseFloat(calculateSiteFireMarshalls(site));
    if (firstAid < 10 || fireMarshall < 10) return '‚ö†Ô∏è Attention';
    return '‚úÖ On Track';
}

function generateSiteBreakdown() {
    const sites = ['DVI1', 'DVI2', 'DVI3', 'DAP5', 'DAP8'];
    const breakdown = {};

    sites.forEach(site => {
        const siteInjuries = state.injury.filteredData.filter(i => i.site === site);
        const siteNearMisses = state.nearMiss.filteredData.filter(n => n.site === site);
        const siteInspections = state.inspections.filteredData.filter(i => i.site === site);

        breakdown[site] = {
            firstAiders: calculateSiteFirstAiders(site),
            fireMarshalls: calculateSiteFireMarshalls(site),
            nearMisses: siteNearMisses.length,
            safetyObs: siteInspections.filter(i => (i.inspection || '').includes('CSO')).length,
            openActions: siteInspections.filter(i => i.status === 'overdue').length,
            openAudits: siteInspections.filter(i => i.status === 'overdue' && (i.inspection || '').toLowerCase().includes('audit')).length,
            status: determineOverallStatus(site)
        };
    });

    return breakdown;
}

function calculateOpenActions() {
    return state.inspections.filteredData.filter(item => item.status !== 'completed').length;
}

function identifyBridgesRequired() {
    const needsBridge = state.inspections.filteredData.some(item => item.status === 'overdue' && (item.inspection || '').toLowerCase().includes('bridge'));
    return needsBridge ? 'Yes' : 'No';
}

function generateOpenActionsList() {
    return state.inspections.filteredData
        .filter(item => item.status === 'overdue' || item.status === 'upcoming')
        .map(item => ({
            site: item.site,
            action: item.inspection,
            owner: item.owner,
            dueDate: (item.dueDate instanceof Date && !isNaN(item.dueDate)) ? item.dueDate.toISOString().split('T')[0] : (item.dueDateRaw || 'N/A'),
            status: item.status
        }));
}

function generateRiskMatrix() {
    return state.nearMiss.filteredData
        .sort((a, b) => (parseFloat(b.risk) || 0) - (parseFloat(a.risk) || 0))
        .slice(0, 5)
        .map(item => ({
            site: item.site || 'Unknown',
            area: item.location || 'General',
            mitigation: item.mitigation_plan || item.corrective_action || 'Mitigation plan pending',
            owner: item.owner || 'WHS Team',
            status: item.status || 'Open'
        }));
}

function generateLeadershipAsks() {
    const overdue = state.inspections.filteredData.filter(item => item.status === 'overdue');
    if (overdue.length === 0) {
        return [
            { site: 'All', request: 'Maintain inspection cadence', context: 'Ensure resources remain allocated for weekly audits.' }
        ];
    }

    return overdue.slice(0, 5).map(item => ({
        site: item.site,
        request: `Support completion of ${item.inspection}`,
        context: `${formatDaysUntilDue(item.daysUntilDue)} remaining`
    }));
}

function generateUpcomingEvents() {
    return state.inspections.filteredData
        .filter(item => item.status === 'upcoming')
        .slice(0, 5)
        .map(item => ({
            site: item.site,
            event: item.inspection,
            date: (item.dueDate instanceof Date && !isNaN(item.dueDate)) ? item.dueDate.toLocaleDateString() : (item.dueDateRaw || 'TBD')
        }));
}

function generateSiteTableRows(siteData) {
    return Object.entries(siteData).map(([site, data]) => `
        <tr>
            <td>${site}</td>
            <td>${data.firstAiders}%</td>
            <td>${data.fireMarshalls}%</td>
            <td>${data.nearMisses}</td>
            <td>${data.safetyObs}</td>
            <td>${data.openActions}</td>
            <td>${data.openAudits}</td>
            <td>${data.status}</td>
        </tr>
    `).join('');
}

function generateActionTableRows(actions) {
    if (!actions.length) {
        return '<tr><td colspan="5" style="text-align:center;">No open actions üéâ</td></tr>';
    }

    return actions.map(action => `
        <tr>
            <td>${action.site}</td>
            <td>${action.action}</td>
            <td>${action.owner}</td>
            <td>${action.dueDate}</td>
            <td>${action.status}</td>
        </tr>
    `).join('');
}

function generateRiskTableRows(risks) {
    if (!risks.length) {
        return '<tr><td colspan="5" style="text-align:center;">No critical risks identified</td></tr>';
    }

    return risks.map(risk => `
        <tr>
            <td>${risk.site}</td>
            <td>${risk.area}</td>
            <td>${risk.mitigation}</td>
            <td>${risk.owner}</td>
            <td>${risk.status}</td>
        </tr>
    `).join('');
}

function generateLeadershipAskRows(asks) {
    if (!asks.length) {
        return '<tr><td colspan="3" style="text-align:center;">No leadership requests this week</td></tr>';
    }

    return asks.map(ask => `
        <tr>
            <td>${ask.site}</td>
            <td>${ask.request}</td>
            <td>${ask.context}</td>
        </tr>
    `).join('');
}

function generateEventRows(events) {
    if (!events.length) {
        return '<tr><td colspan="3" style="text-align:center;">No scheduled events</td></tr>';
    }

    return events.map(event => `
        <tr>
            <td>${event.site}</td>
            <td>${event.event}</td>
            <td>${event.date}</td>
        </tr>
    `).join('');
}

function getWeekDateRange(referenceDate = new Date()) {
    const date = new Date(referenceDate.getTime());
    const day = date.getDay();
    const diffToMonday = (day === 0 ? -6 : 1) - day;
    const monday = new Date(date);
    monday.setDate(date.getDate() + diffToMonday);
    const sunday = new Date(monday);
    sunday.setDate(monday.getDate() + 6);
    return `${monday.toLocaleDateString()} - ${sunday.toLocaleDateString()}`;
}

function generateWBRSummaryData() {
    const injuryCount = state.injury.filteredData.length;
    const nearMissCount = state.nearMiss.filteredData.length;
    const inspectionCount = state.inspections.filteredData.length;
    return [
        {
            Metric: 'Injuries Loaded',
            Value: injuryCount
        },
        {
            Metric: 'Near Misses Loaded',
            Value: nearMissCount
        },
        {
            Metric: 'Inspections Loaded',
            Value: inspectionCount
        },
        {
            Metric: 'Overdue Inspections',
            Value: state.inspections.filteredData.filter(item => item.status === 'overdue').length
        }
    ];
}

function calculateInspectionCompliance() {
    const inspections = state.inspections.filteredData || [];
    const today = new Date();
    const thisMonth = today.getMonth();
    const thisYear = today.getFullYear();

    const monthlyInspections = inspections.filter(item => {
        if (!(item.dueDate instanceof Date) || isNaN(item.dueDate)) return false;
        return item.dueDate.getMonth() === thisMonth && item.dueDate.getFullYear() === thisYear;
    });

    const completed = monthlyInspections.filter(item => item.complete === 1 || item.status === 'completed').length;
    const total = monthlyInspections.length;
    const overdue = monthlyInspections.filter(item => item.status === 'overdue').length;
    const rate = total > 0 ? ((completed / total) * 100).toFixed(1) : 0;

    return {
        completed,
        total,
        rate,
        overdue
    };
}

function checkOverdueInspections() {
    const overdue = state.inspections.filteredData.filter(i => i.status === 'overdue');
    const alertDiv = document.getElementById('overdueAlert');
    const listDiv = document.getElementById('overdueList');

    if (!alertDiv || !listDiv) return;

    if (overdue.length === 0) {
        alertDiv.style.display = 'none';
        listDiv.innerHTML = '';
        updateNotificationBadge(0);
        return;
    }

    let html = '<ul class="overdue-list">';
    overdue.forEach(inspection => {
        html += `
            <li>
                <span><strong>${inspection.site}</strong> - ${inspection.inspection}</span>
                <span class="overdue-days">${formatDaysUntilDue(inspection.daysUntilDue)}</span>
                <span class="owner">Owner: ${inspection.owner}</span>
            </li>
        `;
    });
    html += '</ul>';

    listDiv.innerHTML = html;
    alertDiv.style.display = 'block';
    updateNotificationBadge(overdue.length);
}

function updateNotificationBadge(count) {
    const navTab = document.querySelector('.nav-tab[data-module="inspections"]');
    if (!navTab) return;

    let badge = navTab.querySelector('.notification-badge');
    if (!badge) {
        badge = document.createElement('span');
        badge.className = 'notification-badge';
        navTab.appendChild(badge);
    }

    badge.textContent = count;
    badge.style.display = count > 0 ? 'inline-flex' : 'none';
}

function generateWBRReport() {
    const injuryData = state.injury.filteredData || [];
    const nearMissData = state.nearMiss.filteredData || [];
    const inspectionData = state.inspections.filteredData || [];

    if (injuryData.length === 0 && nearMissData.length === 0 && inspectionData.length === 0) {
        showStatus('Please load injury, near miss, or inspection data before generating the Safety WBR.', 'warning');
        return;
    }

    const now = new Date();
    const currentWeek = getISOWeek(now);
    const currentYear = now.getFullYear();

    const wbrData = {
        weekNumber: currentWeek,
        year: currentYear,
        dateRange: getWeekDateRange(now),
        overview: {
            firstAidersCoverage: calculateFirstAidersCoverage(),
            fireMarshallsCoverage: calculateFireMarshallsCoverage(),
            austinAuditsOpen: inspectionData.filter(i => i.status === 'overdue').length,
            austinActionsOpen: calculateOpenActions(),
            overdueActions: inspectionData.filter(i => i.status === 'overdue').length,
            overdueAudits: inspectionData.filter(i => i.status === 'overdue' && (i.inspection || '').toLowerCase().includes('audit')).length,
            bridgeRequired: identifyBridgesRequired(),
            incidentsYTD: {
                recordable: injuryData.filter(i => Number(i.recordable) === 1).length,
                seriousNearMiss: nearMissData.filter(n => (n.severity || '').toUpperCase() === 'A').length
            },
            nearMissReporting: {
                target: 40,
                actual: nearMissData.length
            },
            safetyObservations: {
                target: 120,
                actual: inspectionData.filter(i => (i.inspection || '').toUpperCase().includes('CSO')).length
            },
            nearMissHighlights: getNearMissHighlights()
        },
        siteData: generateSiteBreakdown(),
        openActions: generateOpenActionsList(),
        risks: generateRiskMatrix(),
        leadershipAsks: generateLeadershipAsks(),
        upcomingEvents: generateUpcomingEvents()
    };

    generateWBRHTML(wbrData);
}

function generateWBRHTML(data) {
    const html = `
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Safety WBR - Austria CW${data.weekNumber}-${data.year}</title>
    <style>
        body { font-family: 'Segoe UI', Arial, sans-serif; margin: 20px; background: #f5f5f5; color: #232F3E; }
        .header { background: #FF9900; color: white; padding: 20px; border-radius: 8px; margin-bottom: 20px; }
        .header h1 { margin: 0; font-size: 24px; }
        .section { background: white; padding: 20px; margin-bottom: 20px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        .section h2 { color: #232F3E; border-bottom: 2px solid #FF9900; padding-bottom: 10px; }
        table { width: 100%; border-collapse: collapse; margin-top: 15px; }
        th { background: #232F3E; color: white; padding: 12px; text-align: left; }
        td { padding: 10px; border-bottom: 1px solid #e0e0e0; vertical-align: top; }
        tr:hover { background: #f9f9f9; }
        .metric { display: inline-block; margin: 10px 20px 10px 0; }
        .metric-label { color: #666; font-size: 12px; }
        .metric-value { font-size: 24px; font-weight: bold; color: #232F3E; }
        .status-green { color: #4CAF50; }
        .status-yellow { color: #FFC107; }
        .status-red { color: #B71C1C; }
        .emoji { font-size: 20px; margin-right: 8px; }
        .flag-emoji { font-size: 24px; margin-right: 10px; }
        .kpi-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin: 20px 0; }
        .kpi-card { background: #f8f9fa; padding: 15px; border-radius: 8px; border-left: 4px solid #FF9900; }
        @media print {
            body { background: white; }
            .section { page-break-inside: avoid; }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1><span class="flag-emoji">üá¶üáπ</span>Safety WBR ‚Äì Austria (CW${data.weekNumber}-${data.year})</h1>
        <p style="margin: 5px 0; opacity: 0.9;">${data.dateRange}</p>
    </div>

    <div class="section">
        <h2><span class="emoji">üìä</span>Austria Overview</h2>
        <table>
            <tr>
                <th width="25%">Category</th>
                <th>Details</th>
            </tr>
            <tr>
                <td><strong>Compliance</strong></td>
                <td>
                    First Aiders Coverage (FA): <span class="${data.overview.firstAidersCoverage >= 10 ? 'status-green' : 'status-red'}">${data.overview.firstAidersCoverage}%</span> (Target 10%)<br>
                    Fire Marshalls Coverage (FM): <span class="${data.overview.fireMarshallsCoverage >= 10 ? 'status-green' : 'status-red'}">${data.overview.fireMarshallsCoverage}%</span> (Target 10%)<br>
                    Austin Audits Open: <span class="${data.overview.austinAuditsOpen === 0 ? 'status-green' : 'status-red'}">${data.overview.austinAuditsOpen}</span><br>
                    Austin Actions Open: ${data.overview.austinActionsOpen}<br>
                    Overdue Actions: <span class="${data.overview.overdueActions === 0 ? 'status-green' : 'status-red'}">${data.overview.overdueActions}</span><br>
                    Overdue Audits: <span class="${data.overview.overdueAudits === 0 ? 'status-green' : 'status-red'}">${data.overview.overdueAudits}</span><br>
                    Bridge required: ${data.overview.bridgeRequired}
                </td>
            </tr>
            <tr>
                <td><strong>Education</strong></td>
                <td>
                    Incidents: ${data.overview.incidentsYTD.recordable} RI and ${data.overview.incidentsYTD.seriousNearMiss} SNM YTD<br>
                    Near Miss Reporting: Target ${data.overview.nearMissReporting.target} vs Actual <span class="${data.overview.nearMissReporting.actual >= data.overview.nearMissReporting.target ? 'status-green' : 'status-yellow'}">${data.overview.nearMissReporting.actual}</span><br>
                    Safety Observations: Target ${data.overview.safetyObservations.target} vs Actual <span class="${data.overview.safetyObservations.actual >= data.overview.safetyObservations.target ? 'status-green' : 'status-yellow'}">${data.overview.safetyObservations.actual}</span>
                </td>
            </tr>
            <tr>
                <td><strong>Near Misses</strong></td>
                <td>${data.overview.nearMissHighlights}</td>
            </tr>
        </table>
    </div>

    <div class="section">
        <h2><span class="emoji">üè≠</span>Compliance Breakdown per Station</h2>
        <table>
            <thead>
                <tr>
                    <th>Station</th>
                    <th>FA Coverage</th>
                    <th>FM Coverage</th>
                    <th>Near Misses</th>
                    <th>Safety Obs</th>
                    <th>Open Actions</th>
                    <th>Open Audits</th>
                    <th>Status</th>
                </tr>
            </thead>
            <tbody>
                ${generateSiteTableRows(data.siteData)}
            </tbody>
        </table>
    </div>

    <div class="section">
        <h2><span class="emoji">üìã</span>Open Actions</h2>
        <table>
            <thead>
                <tr>
                    <th>Station</th>
                    <th>Action</th>
                    <th>Owner</th>
                    <th>Due Date</th>
                    <th>Status</th>
                </tr>
            </thead>
            <tbody>
                ${generateActionTableRows(data.openActions)}
            </tbody>
        </table>
    </div>

    <div class="section">
        <h2><span class="emoji">‚ö†Ô∏è</span>Key Risks</h2>
        <table>
            <thead>
                <tr>
                    <th>Station</th>
                    <th>Risk Area</th>
                    <th>Mitigation Plan</th>
                    <th>Owner</th>
                    <th>Status</th>
                </tr>
            </thead>
            <tbody>
                ${generateRiskTableRows(data.risks)}
            </tbody>
        </table>
    </div>

    <div class="section">
        <h2><span class="emoji">üìå</span>Leadership Ask (Austria)</h2>
        <table>
            <thead>
                <tr>
                    <th>Site</th>
                    <th>Request</th>
                    <th>Reason / Context</th>
                </tr>
            </thead>
            <tbody>
                ${generateLeadershipAskRows(data.leadershipAsks)}
            </tbody>
        </table>
    </div>

    <div class="section">
        <h2><span class="emoji">üìÖ</span>Upcoming Events</h2>
        <table>
            <thead>
                <tr>
                    <th>Site</th>
                    <th>Event</th>
                    <th>Date</th>
                </tr>
            </thead>
            <tbody>
                ${generateEventRows(data.upcomingEvents)}
            </tbody>
        </table>
    </div>

    <div style="text-align: center; color: #666; margin-top: 40px; padding: 20px; border-top: 1px solid #e0e0e0;">
        <p>Generated by Safety Analytics Platform | ${new Date().toLocaleString()}</p>
        <p style="font-size: 12px;">This report contains placeholder data where actual metrics are unavailable. Please update with actual values before distribution.</p>
    </div>
</body>
</html>`;

    const blob = new Blob([html], { type: 'text/html' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `Safety_WBR_Austria_CW${data.weekNumber}_${data.year}.html`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);

    showStatus('Weekly Safety WBR report generated successfully', 'success');
}

// String similarity using Levenshtein distance
function levenshtein(a, b) {
    if (!a) return b.length;
    if (!b) return a.length;
    const matrix = Array.from({ length: b.length + 1 }, (_, i) => [i]);
    for (let j = 0; j <= a.length; j++) {
        matrix[0][j] = j;
    }
    for (let i = 1; i <= b.length; i++) {
        for (let j = 1; j <= a.length; j++) {
            if (b.charAt(i - 1) === a.charAt(j - 1)) {
                matrix[i][j] = matrix[i - 1][j - 1];
            } else {
                matrix[i][j] = Math.min(
                    matrix[i - 1][j] + 1,
                    matrix[i][j - 1] + 1,
                    matrix[i - 1][j - 1] + 1
                );
            }
        }
    }
    return matrix[b.length][a.length];
}

function stringSimilarity(a, b) {
    if (!a || !b) return 0;
    const longer = a.length > b.length ? a : b;
    const shorter = a.length > b.length ? b : a;
    const longerLength = longer.length;
    if (longerLength === 0) return 1;
    const distance = levenshtein(longer.toLowerCase(), shorter.toLowerCase());
    return (longerLength - distance) / longerLength;
}

// Calculate text similarity using Jaccard index
function calculateTextSimilarity(text1, text2) {
    if (!text1 || !text2) return 0;

    // Convert to lowercase and clean
    const clean1 = text1.toLowerCase().replace(/[^\w\s]/g, ' ').trim();
    const clean2 = text2.toLowerCase().replace(/[^\w\s]/g, ' ').trim();

    if (clean1 === clean2) return 1;

    // Create word sets
    const words1 = new Set(clean1.split(/\s+/).filter(w => w.length > 2));
    const words2 = new Set(clean2.split(/\s+/).filter(w => w.length > 2));

    // Calculate Jaccard similarity
    const intersection = new Set([...words1].filter(x => words2.has(x)));
    const union = new Set([...words1, ...words2]);

    return union.size === 0 ? 0 : intersection.size / union.size;
}

// Calculate Quality Metrics
function calculateQualityMetrics(type) {
    const data = type === 'injury' ? state.injury.filteredData : state.nearMiss.filteredData;
    const metrics = {
        totalRecords: data.length,
        duplicates: 0,
        missingCriticalFields: 0,
        dataCompleteness: 0,
        qualityScore: 0,
        duplicateDetails: [],
        duplicateCreators: [],
        missingFieldsDetails: {},
        recommendations: [],
        // Add word analysis metrics
        wordAnalysis: {
            totalWords: 0,
            averageWords: 0,
            minWords: Infinity,
            maxWords: 0,
            distribution: {}
        }
    };

    // Check for duplicates
    if (type === 'nearmiss') {
        const processed = new Set();
        const creatorCounts = {};

        data.forEach((row, index) => {
            if (processed.has(index)) return;

            const currentDesc = row.initial_info_incident_description || '';
            if (!currentDesc || currentDesc.trim().length < 10) return;

            const similarIndices = [index];
            processed.add(index);

            // Compare with remaining unprocessed items
            for (let j = index + 1; j < data.length; j++) {
                if (processed.has(j)) continue;

                const compareDesc = data[j].initial_info_incident_description || '';
                if (!compareDesc || compareDesc.trim().length < 10) continue;

                // Check if same site and within 30 days
                const sameContext = data[j].site === row.site;
                const dateDiff = Math.abs(new Date(data[j].nearmiss_date) - new Date(row.nearmiss_date)) / (1000 * 60 * 60 * 24);
                const withinTimeframe = dateDiff <= 30;

                if (sameContext && withinTimeframe) {
                    const similarity = calculateTextSimilarity(currentDesc, compareDesc);
                    if (similarity >= 0.9) {
                        similarIndices.push(j);
                        processed.add(j);
                    }
                }
            }

            // Only create duplicate group if we found similar records
            if (similarIndices.length > 1) {
                metrics.duplicates += similarIndices.length - 1;
                metrics.duplicateDetails.push({
                    key: `similarity-group-${metrics.duplicateDetails.length}`,
                    indices: similarIndices,
                    data: {
                        date: row.nearmiss_date,
                        site: row.site,
                        location: row.location || row.initial_info_location_event || 'Unknown',
                        similarity: 'Description-based grouping'
                    }
                });

                // Track duplicate creators (excluding the base record)
                similarIndices.slice(1).forEach(idx => {
                    const rec = data[idx];
                    const creator = rec.created_by || rec.creator || rec.reportedBy || rec.initial_info_reporter || 'Unknown';
                    creatorCounts[creator] = (creatorCounts[creator] || 0) + 1;
                });
            }
        });

        metrics.duplicateCreators = Object.entries(creatorCounts)
            .sort((a, b) => b[1] - a[1])
            .slice(0, 3)
            .map(([creator, count]) => ({ creator, count }));
    }

    // Word count analysis for near miss
    if (type === 'nearmiss') {
        data.forEach(row => {
            let wordCount = 0;
            // Count words in description and other text fields
            const textFields = [
                row.initial_info_incident_description,
                row.initial_info_nearmiss_type,
                row.rca_comments,
                row.investigation_evidence_near_incident_location
            ];

            textFields.forEach(field => {
                if (field && typeof field === 'string') {
                    const words = field.trim().split(/\s+/).filter(w => w.length > 0);
                    wordCount += words.length;
                }
            });

            metrics.wordAnalysis.totalWords += wordCount;
            metrics.wordAnalysis.minWords = Math.min(metrics.wordAnalysis.minWords, wordCount);
            metrics.wordAnalysis.maxWords = Math.max(metrics.wordAnalysis.maxWords, wordCount);

            // Word count distribution
            const range = wordCount === 0 ? '0' :
                         wordCount <= 10 ? '1-10' :
                         wordCount <= 25 ? '11-25' :
                         wordCount <= 50 ? '26-50' : '50+';
            metrics.wordAnalysis.distribution[range] = (metrics.wordAnalysis.distribution[range] || 0) + 1;
        });

        metrics.wordAnalysis.averageWords = data.length > 0 ? 
            Math.round(metrics.wordAnalysis.totalWords / data.length) : 0;

        if (metrics.wordAnalysis.minWords === Infinity) {
            metrics.wordAnalysis.minWords = 0;
        }
    }

    // Check critical fields
    const criticalFields = type === 'injury' ? 
        ['incident_date', 'site', 'severity', 'bodyPart', 'recordable'] :
        ['nearmiss_date', 'site', 'severity', 'location', 'risk'];

    criticalFields.forEach(field => {
        metrics.missingFieldsDetails[field] = 0;
    });

    data.forEach(row => {
        criticalFields.forEach(field => {
            const value = field === 'bodyPart' ? row.bodyPart : 
                         field === 'location' ? row.location :
                         row[field];

            if (!value || value === 'Unknown' || value === '') {
                metrics.missingFieldsDetails[field]++;
                metrics.missingCriticalFields++;
            }
        });
    });

    // Calculate completeness
    const totalFields = data.length * criticalFields.length;
    const filledFields = totalFields - metrics.missingCriticalFields;
    metrics.dataCompleteness = totalFields > 0 ? 
        Math.round((filledFields / totalFields) * 100) : 0;

    // Calculate quality score for near miss with word count consideration
    if (type === 'nearmiss') {
        const duplicatePenalty = metrics.totalRecords > 0
            ? Math.max(0, 100 - (metrics.duplicates / metrics.totalRecords) * 100)
            : 100;
        const completenessPenalty = metrics.dataCompleteness;
        const wordCountScore = metrics.wordAnalysis.averageWords >= 15 ? 100 :
                              metrics.wordAnalysis.averageWords >= 10 ? 80 :
                              metrics.wordAnalysis.averageWords >= 5 ? 60 : 40;

        metrics.qualityScore = Math.round((duplicatePenalty + completenessPenalty + wordCountScore) / 3);
    } else {
        metrics.qualityScore = metrics.dataCompleteness;
    }

    // Generate recommendations
    if (type === 'nearmiss') {
        if (metrics.duplicates > 0) {
            metrics.recommendations.push({
                type: 'warning',
                text: `Found ${metrics.duplicates} potential duplicate records. Review and consolidate.`,
                icon: 'üîÑ'
            });
        }

        if (metrics.wordAnalysis.averageWords < 10) {
            metrics.recommendations.push({
                type: 'critical',
                text: `Low description quality: Average ${metrics.wordAnalysis.averageWords} words per record. Aim for 15+ words.`,
                icon: 'üìù'
            });
        }

        if (metrics.dataCompleteness < 80) {
            metrics.recommendations.push({
                type: 'warning',
                text: `Data completeness is ${metrics.dataCompleteness}%. Fill in missing location and risk data.`,
                icon: '‚ö†Ô∏è'
            });
        }

        const lowWordCount = metrics.wordAnalysis.distribution['0'] || 0;
        if (lowWordCount > data.length * 0.2) {
            metrics.recommendations.push({
                type: 'critical',
                text: `${lowWordCount} records (${Math.round(lowWordCount/data.length*100)}%) have no description.`,
                icon: '‚ùå'
            });
        }
    }

    // Store metrics
    if (type === 'injury') {
        state.injury.qualityMetrics = metrics;
    } else {
        state.nearMiss.qualityMetrics = metrics;
    }

    return metrics;
}

// Update Quality Metrics Display
function updateInjuryQualityMetrics() {
    const metrics = state.injury.qualityMetrics;
    updateQualityDisplay('injury', metrics);
}

function updateNearMissQualityMetrics() {
    const metrics = state.nearMiss.qualityMetrics;
    updateQualityDisplay('nearmiss', metrics);
}

function updateQualityDisplay(type, metrics) {
    const containerId = type === 'nearmiss' ? 'nearMissQuality' : `${type}Quality`;
    const container = document.getElementById(containerId);
    if (!container || !metrics || !metrics.totalRecords) {
        if (container) {
            container.innerHTML = '<p style="text-align: center; padding: 2rem;">No data loaded for quality analysis.</p>';
        }
        return;
    }

    const qualityClass = metrics.qualityScore >= 90 ? 'excellent' : 
                        metrics.qualityScore >= 70 ? 'good' : 
                        metrics.qualityScore >= 50 ? 'warning' : 'poor';

    const qualityEmoji = metrics.qualityScore >= 90 ? 'üåü' : 
                        metrics.qualityScore >= 70 ? '‚úÖ' : 
                        metrics.qualityScore >= 50 ? '‚ö†Ô∏è' : '‚ùå';

    // Enhanced HTML with better visual design
    container.innerHTML = `
        <div class="quality-metrics-container">
            <!-- Main Score Card -->
            <div class="quality-score-card-enhanced">
                <div class="quality-score-visual">
                    <div class="quality-score-circle ${qualityClass}">
                        <div class="quality-score-inner">
                            <div class="quality-emoji">${qualityEmoji}</div>
                            <div class="quality-score-value">${metrics.qualityScore}%</div>
                            <div class="quality-score-label">Overall Quality</div>
                        </div>
                    </div>
                    <div class="quality-score-ring">
                        <svg viewBox="0 0 200 200">
                            <circle cx="100" cy="100" r="90" fill="none" stroke="#e0e0e0" stroke-width="10"/>
                            <circle cx="100" cy="100" r="90" fill="none" 
                                stroke="${qualityClass === 'excellent' ? '#4CAF50' : 
                                         qualityClass === 'good' ? '#FFC107' : 
                                         qualityClass === 'warning' ? '#FF9800' : '#FF5722'}"
                                stroke-width="10"
                                stroke-dasharray="${metrics.qualityScore * 5.65} 565"
                                stroke-dashoffset="0"
                                transform="rotate(-90 100 100)"
                                style="transition: stroke-dasharray 1s ease;"/>
                        </svg>
                    </div>
                </div>
                
                ${type === 'nearmiss' ? `
                <!-- Word Analysis Summary -->
                <div class="word-analysis-summary">
                    <h4>üìù Description Quality</h4>
                    <div class="word-stats-grid">
                        <div class="word-stat">
                            <div class="word-stat-value">${metrics.wordAnalysis.averageWords}</div>
                            <div class="word-stat-label">Avg Words</div>
                        </div>
                        <div class="word-stat">
                            <div class="word-stat-value">${metrics.wordAnalysis.minWords}-${metrics.wordAnalysis.maxWords}</div>
                            <div class="word-stat-label">Range</div>
                        </div>
                        <div class="word-stat">
                            <div class="word-stat-value">${metrics.totalRecords}</div>
                            <div class="word-stat-label">Records</div>
                        </div>
                    </div>
                </div>
                ` : ''}
            </div>
            
            <!-- Key Metrics Cards -->
            <div class="quality-metrics-grid">
                <div class="quality-metric-card">
                    <div class="metric-icon-large">üìä</div>
                    <div class="metric-content">
                        <div class="metric-value">${metrics.totalRecords}</div>
                        <div class="metric-label">Total Records</div>
                    </div>
                </div>
                
                ${type === 'nearmiss' ? `
                <div class="quality-metric-card ${metrics.duplicates > 0 ? 'has-issue' : ''}">
                    <div class="metric-icon-large">üîÑ</div>
                    <div class="metric-content">
                        <div class="metric-value">${metrics.duplicates}</div>
                        <div class="metric-label">Duplicates Found</div>
                    </div>
                </div>
                
                <div class="quality-metric-card">
                    <div class="metric-icon-large">üìù</div>
                    <div class="metric-content">
                        <div class="metric-value">${metrics.wordAnalysis.totalWords}</div>
                        <div class="metric-label">Total Words</div>
                    </div>
                </div>
                ` : `
                <div class="quality-metric-card">
                    <div class="metric-icon-large">‚ö†Ô∏è</div>
                    <div class="metric-content">
                        <div class="metric-value">${metrics.missingCriticalFields}</div>
                        <div class="metric-label">Missing Fields</div>
                    </div>
                </div>
                `}
                
                <div class="quality-metric-card">
                    <div class="metric-icon-large">‚úÖ</div>
                    <div class="metric-content">
                        <div class="metric-value">${metrics.dataCompleteness}%</div>
                        <div class="metric-label">Completeness</div>
                    </div>
                </div>
            </div>
            
            ${type === 'nearmiss' && metrics.duplicateDetails.length > 0 ? `
            <!-- Duplicate Records Section -->
            <div class="quality-section duplicate-section">
                <div class="section-header">
                    <h4><span class="section-icon">üîÑ</span> Duplicate Records Detected</h4>
                    <div style="display:flex; align-items:center; gap:0.5rem;">
                        <span class="duplicate-count">${metrics.duplicateDetails.length} groups</span>
                        <button class="btn btn-sm btn-primary" onclick="exportNearMissDuplicatesPDF()">Export PDF</button>
                    </div>
                </div>
                <div class="duplicate-list">
                    ${metrics.duplicateDetails.slice(0, 5).map((dup, index) => `
                        <div class="duplicate-item">
                            <div class="duplicate-number">${index + 1}</div>
                            <div class="duplicate-content">
                                <div class="duplicate-key">
                                    <span class="dup-field"><i>üìÖ</i> ${dup.data.date || 'No date'}</span>
                                    <span class="dup-field"><i>üè¢</i> ${dup.data.site}</span>
                                    <span class="dup-field"><i>üìç</i> ${dup.data.location}</span>
                                </div>
                                <div class="duplicate-rows">
                                    Rows: ${dup.indices.map(i => `<span class="row-badge">#${i + 1}</span>`).join(' ')}
                                    <span class="duplicate-action" onclick="showDuplicateDetails(${index}, '${type}')">‚Üí Review</span>
                                </div>
                            </div>
                        </div>
                    `).join('')}
                    ${metrics.duplicateDetails.length > 5 ?
                        `<div class="more-duplicates" onclick="showAllDuplicates('${type}')">
                            <i>‚ûï</i> ${metrics.duplicateDetails.length - 5} more duplicate groups...
                        </div>` : ''}
                </div>
                ${metrics.duplicateCreators && metrics.duplicateCreators.length ? `
                <div class="duplicate-creators" style="margin-top:1rem;">
                    <h5>Top Duplicate Creators</h5>
                    <ol>
                        ${metrics.duplicateCreators.map(dc => `<li>${dc.creator}: ${dc.count}</li>`).join('')}
                    </ol>
                </div>
                ` : ''}
            </div>
            ` : ''}
            
            ${type === 'nearmiss' ? `
            <!-- Word Count Distribution -->
            <div class="quality-section">
                <h4><span class="section-icon">üìä</span> Description Word Count Distribution</h4>
                <div class="word-distribution">
                    ${Object.entries(metrics.wordAnalysis.distribution).map(([range, count]) => {
                        const percentage = (count / metrics.totalRecords * 100).toFixed(1);
                        const barClass = range === '0' ? 'bar-critical' : 
                                       range === '1-10' ? 'bar-warning' : 
                                       range === '11-25' ? 'bar-good' : 'bar-excellent';
                        return `
                            <div class="distribution-row">
                                <div class="dist-label">${range} words</div>
                                <div class="dist-bar-container">
                                    <div class="dist-bar ${barClass}" style="width: ${percentage}%"></div>
                                    <span class="dist-value">${count} (${percentage}%)</span>
                                </div>
                            </div>
                        `;
                    }).join('')}
                </div>
            </div>
            
            <!-- Word Heat Map -->
            <div class="quality-section">
                <h4><span class="section-icon">üî•</span> Most Common Words</h4>
                <div id="nearMissWordHeatMap" class="word-heatmap-enhanced"></div>
            </div>
            ` : `
            <!-- Missing Fields Chart -->
            <div class="quality-section">
                <h4><span class="section-icon">üìä</span> Missing Fields Analysis</h4>
                <div class="missing-fields-chart chart-container" data-capture-title="${type === 'injury' ? 'Injury Missing Fields Analysis' : 'Near Miss Missing Fields Analysis'}">
                    <canvas id="${type}MissingFieldsChart"></canvas>
                </div>
            </div>
            `}
            
            <!-- Recommendations -->
            <div class="quality-section recommendations-section">
                <h4><span class="section-icon">üí°</span> Quality Improvement Recommendations</h4>
                <div class="recommendations-list">
                    ${metrics.recommendations.map(rec => `
                        <div class="recommendation-item ${rec.type}">
                            <div class="rec-icon">${rec.icon || (rec.type === 'critical' ? 'üö®' : '‚ö†Ô∏è')}</div>
                            <div class="rec-content">
                                <div class="rec-text">${rec.text}</div>
                                ${rec.type === 'critical' ? 
                                    '<div class="rec-priority">High Priority</div>' : ''}
                            </div>
                        </div>
                    `).join('')}
                    ${metrics.recommendations.length === 0 ? 
                        '<div class="recommendation-item success"><div class="rec-icon">üéâ</div><div class="rec-content"><div class="rec-text">Excellent data quality! Keep up the good work.</div></div></div>' : ''}
                </div>
            </div>
        </div>
    `;

    initializeChartCaptureButtons();
    
    // Add enhanced CSS styles
    const styleId = 'quality-enhancement-styles';
    if (!document.getElementById(styleId)) {
        const style = document.createElement('style');
        style.id = styleId;
        style.textContent = `
            .quality-score-card-enhanced {
                background: linear-gradient(135deg, #f5f5f5 0%, #ffffff 100%);
                border-radius: 16px;
                padding: 2rem;
                margin-bottom: 2rem;
                box-shadow: 0 4px 20px rgba(0,0,0,0.08);
                display: flex;
                gap: 3rem;
                align-items: center;
            }
            
            [data-theme="dark"] .quality-score-card-enhanced {
                background: linear-gradient(135deg, #2d2d2d 0%, #1a1a1a 100%);
            }
            
            .quality-score-visual {
                position: relative;
                width: 200px;
                height: 200px;
            }
            
            .quality-score-circle {
                width: 180px;
                height: 180px;
                border-radius: 50%;
                display: flex;
                align-items: center;
                justify-content: center;
                position: absolute;
                top: 10px;
                left: 10px;
                background: white;
                z-index: 2;
            }
            
            [data-theme="dark"] .quality-score-circle {
                background: #1a1a1a;
            }
            
            .quality-score-ring {
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                z-index: 1;
            }
            
            .quality-score-inner {
                text-align: center;
            }
            
            .quality-emoji {
                font-size: 3rem;
                margin-bottom: 0.5rem;
            }
            
            .quality-score-value {
                font-size: 2.5rem;
                font-weight: 700;
                margin: 0;
            }
            
            .quality-score-circle.excellent { color: #4CAF50; }
            .quality-score-circle.good { color: #FFC107; }
            .quality-score-circle.warning { color: #FF9800; }
            .quality-score-circle.poor { color: #FF5722; }
            
            .word-analysis-summary {
                flex: 1;
                background: rgba(255, 153, 0, 0.05);
                border-radius: 12px;
                padding: 1.5rem;
                border: 1px solid rgba(255, 153, 0, 0.2);
            }
            
            .word-analysis-summary h4 {
                margin: 0 0 1rem 0;
                color: var(--amazon-orange);
            }
            
            .word-stats-grid {
                display: grid;
                grid-template-columns: repeat(3, 1fr);
                gap: 1rem;
            }
            
            .word-stat {
                text-align: center;
            }
            
            .word-stat-value {
                font-size: 1.5rem;
                font-weight: 700;
                color: var(--text-primary);
            }
            
            .word-stat-label {
                font-size: 0.8rem;
                color: var(--text-secondary);
                margin-top: 0.25rem;
            }
            
            .quality-metrics-grid {
                display: grid;
                grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
                gap: 1rem;
                margin-bottom: 2rem;
            }
            
            .quality-metric-card {
                background: white;
                border-radius: 12px;
                padding: 1.5rem;
                display: flex;
                align-items: center;
                gap: 1rem;
                box-shadow: 0 2px 8px rgba(0,0,0,0.06);
                transition: all 0.3s ease;
                border: 1px solid transparent;
            }
            
            [data-theme="dark"] .quality-metric-card {
                background: #2d2d2d;
            }
            
            .quality-metric-card:hover {
                transform: translateY(-2px);
                box-shadow: 0 4px 16px rgba(0,0,0,0.1);
            }
            
            .quality-metric-card.has-issue {
                border-color: var(--danger);
                background: rgba(255, 87, 34, 0.05);
            }
            
            .metric-icon-large {
                font-size: 2.5rem;
            }
            
            .metric-content {
                flex: 1;
            }
            
            .duplicate-section {
                background: rgba(255, 87, 34, 0.05);
                border: 1px solid rgba(255, 87, 34, 0.2);
                border-radius: 12px;
                padding: 1.5rem;
                margin: 1.5rem 0;
            }
            
            .section-header {
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 1rem;
            }
            
            .section-header h4 {
                margin: 0;
                display: flex;
                align-items: center;
                gap: 0.5rem;
                color: var(--danger);
            }
            
            .section-icon {
                font-size: 1.2rem;
            }
            
            .duplicate-count {
                background: var(--danger);
                color: white;
                padding: 0.25rem 0.75rem;
                border-radius: 20px;
                font-size: 0.85rem;
                font-weight: 600;
            }
            
            .duplicate-list {
                display: grid;
                gap: 0.75rem;
            }
            
            .duplicate-item {
                background: white;
                border-radius: 8px;
                padding: 1rem;
                display: flex;
                gap: 1rem;
                align-items: center;
                border: 1px solid rgba(0,0,0,0.1);
            }
            
            [data-theme="dark"] .duplicate-item {
                background: #1a1a1a;
            }
            
            .duplicate-number {
                width: 32px;
                height: 32px;
                background: var(--danger);
                color: white;
                border-radius: 50%;
                display: flex;
                align-items: center;
                justify-content: center;
                font-weight: 700;
                flex-shrink: 0;
            }
            
            .duplicate-content {
                flex: 1;
            }
            
            .duplicate-key {
                display: flex;
                gap: 1rem;
                margin-bottom: 0.5rem;
                flex-wrap: wrap;
            }
            
            .dup-field {
                font-size: 0.85rem;
                color: var(--text-secondary);
                display: flex;
                align-items: center;
                gap: 0.25rem;
            }
            
            .dup-field i {
                font-style: normal;
                opacity: 0.7;
            }
            
            .duplicate-rows {
                font-size: 0.8rem;
                color: var(--text-secondary);
                display: flex;
                align-items: center;
                gap: 0.5rem;
            }
            
            .row-badge {
                background: var(--bg-secondary);
                padding: 0.15rem 0.5rem;
                border-radius: 10px;
                font-weight: 600;
            }
            
            .duplicate-action {
                margin-left: auto;
                color: var(--amazon-orange);
                font-weight: 600;
                cursor: pointer;
            }
            
            .more-duplicates {
                text-align: center;
                color: var(--text-secondary);
                font-size: 0.85rem;
                padding: 1rem;
                border-top: 1px dashed rgba(0,0,0,0.1);
                cursor: pointer;
            }
            
            .word-distribution {
                margin-top: 1rem;
            }
            
            .distribution-row {
                display: flex;
                align-items: center;
                gap: 1rem;
                margin-bottom: 0.75rem;
            }
            
            .dist-label {
                width: 80px;
                font-size: 0.85rem;
                color: var(--text-secondary);
            }
            
            .dist-bar-container {
                flex: 1;
                background: var(--bg-secondary);
                border-radius: 20px;
                height: 24px;
                position: relative;
                overflow: hidden;
            }
            
            .dist-bar {
                height: 100%;
                border-radius: 20px;
                transition: width 1s ease;
                position: relative;
            }
            
            .dist-value {
                position: absolute;
                right: 10px;
                top: 50%;
                transform: translateY(-50%);
                font-size: 0.75rem;
                font-weight: 600;
                color: var(--text-primary);
            }
            
            .bar-critical { background: var(--danger); }
            .bar-warning { background: var(--warning); }
            .bar-good { background: #2196F3; }
            .bar-excellent { background: var(--success); }
            
            .word-heatmap-enhanced {
                display: flex;
                flex-wrap: wrap;
                gap: 0.5rem;
                margin-top: 1rem;
            }
            
            .word-heatmap-enhanced .heatmap-item {
                padding: 0.5rem 1rem;
                border-radius: 20px;
                color: white;
                font-size: 0.85rem;
                font-weight: 600;
                transition: all 0.2s ease;
                cursor: pointer;
            }
            
            .word-heatmap-enhanced .heatmap-item:hover {
                transform: scale(1.05);
                box-shadow: 0 2px 8px rgba(0,0,0,0.2);
            }
            
            .recommendations-section {
                margin-top: 2rem;
            }
            
            .recommendations-list {
                display: grid;
                gap: 0.75rem;
                margin-top: 1rem;
            }
            
            .recommendation-item {
                display: flex;
                align-items: flex-start;
                gap: 1rem;
                padding: 1rem;
                border-radius: 8px;
                background: white;
                border: 1px solid transparent;
                transition: all 0.2s ease;
            }
            
            [data-theme="dark"] .recommendation-item {
                background: #2d2d2d;
            }
            
            .recommendation-item.critical {
                border-color: var(--critical);
                background: rgba(183, 28, 28, 0.05);
            }
            
            .recommendation-item.warning {
                border-color: var(--warning);
                background: rgba(255, 193, 7, 0.05);
            }
            
            .recommendation-item.success {
                border-color: var(--success);
                background: rgba(76, 175, 80, 0.05);
            }
            
            .rec-icon {
                font-size: 1.5rem;
                flex-shrink: 0;
            }
            
            .rec-content {
                flex: 1;
            }
            
            .rec-text {
                color: var(--text-primary);
                font-size: 0.9rem;
                line-height: 1.5;
            }
            
            .rec-priority {
                margin-top: 0.25rem;
                font-size: 0.75rem;
                color: var(--critical);
                font-weight: 600;
                text-transform: uppercase;
            }
        `;
        document.head.appendChild(style);
    }
    
    // Update charts and word analysis after a short delay
    setTimeout(() => {
        if (type === 'injury') {
            const ctx = document.getElementById(`${type}MissingFieldsChart`);
            if (ctx) {
                new Chart(ctx.getContext('2d'), {
                    type: 'bar',
                    data: {
                        labels: Object.keys(metrics.missingFieldsDetails),
                        datasets: [{
                            label: 'Missing Records',
                            data: Object.values(metrics.missingFieldsDetails),
                            backgroundColor: AMAZON_COLORS.orange,
                            borderColor: AMAZON_COLORS.darkBlue,
                            borderWidth: 1
                        }]
                    },
                    options: {
                        ...getChartOptions('bar'),
                        scales: {
                            y: {
                                beginAtZero: true,
                                title: {
                                    display: true,
                                    text: 'Number of Records'
                                }
                            }
                        }
                    }
                });
            }
        }
        
        if (type === 'nearmiss') {
            updateNearMissWordHeatMap(metrics);
        }
    }, 100);
}

// Enhanced word heat map function
function updateNearMissWordHeatMap(metrics) {
    const words = [];
    state.nearMiss.filteredData.forEach(row => {
        ['initial_info_incident_description', 'initial_info_nearmiss_type', 'initial_info_primary_impact'].forEach(field => {
            const text = row[field];
            if (text && typeof text === 'string') {
                text.split(/\s+/).forEach(word => {
                    const cleaned = word.toLowerCase().replace(/[^a-z0-9]/g, '');
                    if (cleaned && cleaned.length > 3) words.push(cleaned);
                });
            }
        });
    });
    
    const wordCounts = {};
    words.forEach(w => {
        wordCounts[w] = (wordCounts[w] || 0) + 1;
    });
    
    // Filter out common words
    const commonWords = ['that', 'this', 'with', 'from', 'have', 'been', 'were', 'their'];
    const topWords = Object.entries(wordCounts)
        .filter(([word]) => !commonWords.includes(word))
        .sort((a, b) => b[1] - a[1])
        .slice(0, 20);
    
    const container = document.getElementById('nearMissWordHeatMap');
    if (container) {
        const maxCount = Math.max(...topWords.map(entry => entry[1]));
        const minCount = Math.min(...topWords.map(entry => entry[1]));
        
        container.innerHTML = topWords.map(([word, count]) => {
            const intensity = (count - minCount) / (maxCount - minCount);
            const size = 0.8 + (intensity * 0.6);
            const colors = [
                '#FFE0B2', '#FFCC80', '#FFB74D', '#FFA726',
                '#FF9800', '#FB8C00', '#F57C00', '#EF6C00'
            ];
            const colorIndex = Math.floor(intensity * (colors.length - 1));
            
            return `<div class="heatmap-item" 
                style="background: ${colors[colorIndex]}; 
                       color: ${intensity > 0.5 ? '#fff' : '#333'};
                       font-size: ${size}rem;"
                title="${count} occurrences">
                ${word} (${count})
            </div>`;
        }).join('');
    }
}

// Standardize severity
function standardizeSeverity(severity) {
    if (!severity) return 'Unknown';
    const severityStr = String(severity).toUpperCase().trim();
    
    if (['A', 'B', 'C', 'D'].includes(severityStr)) {
        return severityStr;
    }
    
    const lower = severityStr.toLowerCase();
    if (lower.includes('critical') || lower.includes('severe')) return 'A';
    if (lower.includes('high') || lower.includes('major')) return 'B';
    if (lower.includes('medium') || lower.includes('moderate')) return 'C';
    if (lower.includes('low') || lower.includes('minor')) return 'D';
    
    return 'Unknown';
}

// Standardize likelihood
function standardizeLikelihood(likelihood) {
    if (!likelihood) return 'Possible';
    
    const likelihoodStr = String(likelihood).toLowerCase().trim();
    
    if (likelihoodStr.includes('rare')) return 'Rare';
    if (likelihoodStr.includes('unlikely')) return 'Unlikely';
    if (likelihoodStr.includes('possible')) return 'Possible';
    if (likelihoodStr.includes('likely') && !likelihoodStr.includes('unlikely')) {
        if (likelihoodStr.includes('almost') || likelihoodStr.includes('certain')) {
            return 'Almost Certain';
        }
        return 'Likely';
    }
    if (likelihoodStr.includes('certain')) return 'Almost Certain';
    
    const numValue = parseInt(likelihoodStr);
    if (!isNaN(numValue)) {
        switch(numValue) {
            case 1: return 'Rare';
            case 2: return 'Unlikely';
            case 3: return 'Possible';
            case 4: return 'Likely';
            case 5: return 'Almost Certain';
        }
    }
    
    return 'Possible';
}

// Calculate risk score
function calculateRiskScore(row) {
    const severityMap = { 'A': 5, 'B': 4, 'C': 3, 'D': 2, 'Unknown': 1 };
    const likelihoodMap = { 
        'Rare': 1, 
        'Unlikely': 2, 
        'Possible': 3, 
        'Likely': 4, 
        'Almost Certain': 5 
    };
    
    const severity = severityMap[row.severity] || 1;
    const likelihood = likelihoodMap[row.standardized_likelihood] || 3;
    
    return ((severity * likelihood) / 5 * 2).toFixed(1);
}

// Populate Filters
function populateInjuryFilters() {
    // Sites
    const sites = [...new Set(state.injury.rawData.map(r => r.site).filter(Boolean))];
    const siteFilter = document.getElementById('injurySiteFilter');
    siteFilter.innerHTML = '<option value="">All Sites</option>';
    sites.sort().forEach(site => {
        siteFilter.innerHTML += `<option value="${site}">${site}</option>`;
    });
    
    // Body Parts
    const bodyParts = [...new Set(state.injury.rawData.map(r => r.bodyPart).filter(Boolean))];
    const bodyPartFilter = document.getElementById('injuryBodyPartFilter');
    bodyPartFilter.innerHTML = '<option value="">All Body Parts</option>';
    bodyParts.sort().slice(0, 20).forEach(part => {
        const truncated = part.length > 30 ? part.substring(0, 30) + '...' : part;
        bodyPartFilter.innerHTML += `<option value="${part}">${truncated}</option>`;
    });
    
    // Root Causes
    const rootCauses = [...new Set(state.injury.rawData.map(r => r.rootCause).filter(Boolean))];
    const rootCauseFilter = document.getElementById('injuryRootCauseFilter');
    rootCauseFilter.innerHTML = '<option value="">All Causes</option>';
    rootCauses.sort().forEach(cause => {
        const truncated = cause.length > 30 ? cause.substring(0, 30) + '...' : cause;
        rootCauseFilter.innerHTML += `<option value="${cause}">${truncated}</option>`;
    });
}

function populateNearMissFilters() {
    // Sites
    const siteFilter = document.getElementById('nearMissSiteFilter');
    if (siteFilter) {
        siteFilter.innerHTML = '';
        const defaultOption = document.createElement('option');
        defaultOption.value = '';
        defaultOption.textContent = 'All Sites';
        siteFilter.appendChild(defaultOption);

        const sites = [...new Set(state.nearMiss.rawData.map(r => r.site).filter(Boolean))].sort();
        sites.forEach(site => {
            const option = document.createElement('option');
            option.value = site;
            option.textContent = site;
            siteFilter.appendChild(option);
        });
    }

    // Primary Impacts
    const impactFilter = document.getElementById('nearMissPrimaryImpactFilter');
    if (impactFilter) {
        impactFilter.innerHTML = '';
        const defaultImpact = document.createElement('option');
        defaultImpact.value = '';
        defaultImpact.textContent = 'All Impacts';
        impactFilter.appendChild(defaultImpact);

        const impacts = [...new Set(state.nearMiss.rawData.map(r => r.primaryImpact).filter(Boolean))].sort();
        impacts.forEach(impact => {
            const option = document.createElement('option');
            option.value = impact;
            option.textContent = impact;
            impactFilter.appendChild(option);
        });
    }

    // Locations
    const locationFilter = document.getElementById('nearMissLocationFilter');
    if (locationFilter) {
        locationFilter.innerHTML = '';
        const defaultLocation = document.createElement('option');
        defaultLocation.value = '';
        defaultLocation.textContent = 'All Locations';
        locationFilter.appendChild(defaultLocation);

        const locations = [...new Set(state.nearMiss.rawData.map(r => r.location).filter(Boolean))]
            .sort()
            .slice(0, 20);
        locations.forEach(location => {
            const option = document.createElement('option');
            option.value = location;
            option.textContent = location.length > 30 ? location.substring(0, 30) + '...' : location;
            locationFilter.appendChild(option);
        });
    }

    // Process Paths
    const processFilter = document.getElementById('nearMissProcessFilter');
    if (processFilter) {
        processFilter.innerHTML = '';
        const defaultProcess = document.createElement('option');
        defaultProcess.value = '';
        defaultProcess.textContent = 'All Processes';
        processFilter.appendChild(defaultProcess);

        const processes = [...new Set(state.nearMiss.rawData.map(r => r.processPath).filter(Boolean))].sort();
        processes.forEach(process => {
            const option = document.createElement('option');
            option.value = process;
            option.textContent = process;
            processFilter.appendChild(option);
        });
    }
}

// Apply Filters
function applyFilters(type) {
    if (type === 'inspections') {
        const siteFilter = document.getElementById('inspectionSiteFilter')?.value || '';
        const statusFilter = document.getElementById('inspectionStatusFilter')?.value || '';
        const typeFilter = document.getElementById('inspectionTypeFilter')?.value || '';
        const dateFromVal = document.getElementById('inspectionDateFrom')?.value;
        const dateToVal = document.getElementById('inspectionDateTo')?.value;

        const dateFrom = dateFromVal ? new Date(dateFromVal) : null;
        const dateTo = dateToVal ? new Date(dateToVal) : null;
        if (dateFrom) dateFrom.setHours(0, 0, 0, 0);
        if (dateTo) dateTo.setHours(23, 59, 59, 999);

        state.inspections.filteredData = state.inspections.rawData.filter(row => {
            if (siteFilter && row.site !== siteFilter) return false;
            if (statusFilter && row.status !== statusFilter) return false;
            if (typeFilter && row.type !== typeFilter) return false;

            if ((dateFrom || dateTo) && row.dueDate instanceof Date && !isNaN(row.dueDate)) {
                const dueTime = row.dueDate.getTime();
                if (dateFrom && dueTime < dateFrom.getTime()) return false;
                if (dateTo && dueTime > dateTo.getTime()) return false;
            }
            return true;
        });

        state.inspections.filteredData.sort((a, b) => {
            const aTime = a.dueDate instanceof Date && !isNaN(a.dueDate) ? a.dueDate.getTime() : Infinity;
            const bTime = b.dueDate instanceof Date && !isNaN(b.dueDate) ? b.dueDate.getTime() : Infinity;
            return aTime - bTime;
        });

        state.inspections.currentPage = 1;
        updateInspectionDashboard();
        updateInspectionTable();
        updateInspectionCharts();
        checkOverdueInspections();
        updateOverview();
        return;
    }

    if (type === 'injury') {
        const siteFilter = document.getElementById('injurySiteFilter').value;
        const severityFilter = document.getElementById('injurySeverityFilter').value;
        const recordableFilter = document.getElementById('injuryRecordableFilter').value;
        const otrFilter = document.getElementById('injuryOTRFilter').value;
        const bodyPartFilter = document.getElementById('injuryBodyPartFilter').value;
        const rootCauseFilter = document.getElementById('injuryRootCauseFilter').value;
        const dateFrom = document.getElementById('injuryDateFrom').value;
        const dateTo = document.getElementById('injuryDateTo').value;
        
        state.injury.filteredData = state.injury.rawData.filter(row => {
            if (siteFilter && row.site !== siteFilter) return false;
            if (severityFilter && row.severity !== severityFilter) return false;
            if (recordableFilter !== '' && row.recordable != recordableFilter) return false;
            if (otrFilter && row.otr !== otrFilter) return false;
            if (bodyPartFilter && row.bodyPart !== bodyPartFilter) return false;
            if (rootCauseFilter && row.rootCause !== rootCauseFilter) return false;
            
            if (dateFrom || dateTo) {
                const rowDate = row.parsedDate;
                if (!rowDate || isNaN(rowDate)) return false;
                if (dateFrom && rowDate < new Date(dateFrom)) return false;
                if (dateTo && rowDate > new Date(dateTo)) return false;
            }
            
            return true;
        });

        sortData('injury');
        updateSortIndicators('injury');

        state.injury.currentPage = 1;
        updateInjuryDashboard();
        updateInjuryTable();
        updateInjuryCharts();
    } else {
        const siteFilter = document.getElementById('nearMissSiteFilter').value;
        const severityFilter = document.getElementById('nearMissSeverityFilter').value;
        const impactFilter = document.getElementById('nearMissPrimaryImpactFilter').value;
        const locationFilter = document.getElementById('nearMissLocationFilter').value;
        const processFilter = document.getElementById('nearMissProcessFilter').value;
        const likelihoodFilter = document.getElementById('nearMissLikelihoodFilter').value;
        const dateFrom = document.getElementById('nearMissDateFrom').value;
        const dateTo = document.getElementById('nearMissDateTo').value;
        
        state.nearMiss.filteredData = state.nearMiss.rawData.filter(row => {
            if (siteFilter && row.site !== siteFilter) return false;
            if (severityFilter && row.severity !== severityFilter) return false;
            if (impactFilter && row.primaryImpact !== impactFilter) return false;
            if (locationFilter && row.location !== locationFilter) return false;
            if (processFilter && row.processPath !== processFilter) return false;
            if (likelihoodFilter && row.standardized_likelihood !== likelihoodFilter) return false;
            
            if (dateFrom || dateTo) {
                const rowDate = row.parsedDate;
                if (!rowDate || isNaN(rowDate)) return false;
                if (dateFrom && rowDate < new Date(dateFrom)) return false;
                if (dateTo && rowDate > new Date(dateTo)) return false;
            }
            
            return true;
        });

        sortData('nearMiss');
        updateSortIndicators('nearMiss');

        state.nearMiss.currentPage = 1;
        updateNearMissDashboard();
        updateNearMissTable();
        updateNearMissCharts();
    }
    
    updateOverview();
    updateKPIs();
    // Ensure the combined analytics reflect the latest filtered data
    updateCombinedAnalytics();

    // Recalculate data quality metrics based on the filtered dataset
    calculateQualityMetrics(type);
    if (type === 'injury') {
        updateInjuryQualityMetrics();
    } else {
        updateNearMissQualityMetrics();
    }
}

// Populate overview filter options based on loaded data
function populateOverviewFilters() {
    const siteSelect = document.getElementById('overviewSiteFilter');
    if (!siteSelect) return;
    // If options already populated beyond default, skip
    if (siteSelect.options.length > 1) return;
    const sites = new Set();
    state.injury.rawData.forEach(row => {
        if (row.site) sites.add(row.site);
    });
    state.nearMiss.rawData.forEach(row => {
        if (row.site) sites.add(row.site);
    });
    sites.forEach(site => {
        const option = document.createElement('option');
        option.value = site;
        option.textContent = site;
        siteSelect.appendChild(option);
    });

    // Populate body part options (from injury data)
    const bodySelect = document.getElementById('overviewBodyPartFilter');
    if (bodySelect && bodySelect.options.length <= 1) {
        const parts = new Set();
        state.injury.rawData.forEach(row => {
            if (row.bodyPart) parts.add(row.bodyPart);
        });
        parts.forEach(part => {
            const opt = document.createElement('option');
            opt.value = part;
            opt.textContent = part;
            bodySelect.appendChild(opt);
        });
    }

    // Populate impact options (from near miss data)
    const impactSelect = document.getElementById('overviewImpactFilter');
    if (impactSelect && impactSelect.options.length <= 1) {
        const impacts = new Set();
        state.nearMiss.rawData.forEach(row => {
            if (row.primaryImpact) impacts.add(row.primaryImpact);
        });
        impacts.forEach(impact => {
            const opt = document.createElement('option');
            opt.value = impact;
            opt.textContent = impact;
            impactSelect.appendChild(opt);
        });
    }

    // Populate location options (from near miss data)
    const locationSelect = document.getElementById('overviewLocationFilter');
    if (locationSelect && locationSelect.options.length <= 1) {
        const locations = new Set();
        state.nearMiss.rawData.forEach(row => {
            if (row.location) locations.add(row.location);
        });
        locations.forEach(loc => {
            const opt = document.createElement('option');
            opt.value = loc;
            opt.textContent = loc;
            locationSelect.appendChild(opt);
        });
    }

    // Populate process path options (from near miss data)
    const processSelect = document.getElementById('overviewProcessFilter');
    if (processSelect && processSelect.options.length <= 1) {
        const processes = new Set();
        state.nearMiss.rawData.forEach(row => {
            if (row.processPath) processes.add(row.processPath);
        });
        processes.forEach(proc => {
            const opt = document.createElement('option');
            opt.value = proc;
            opt.textContent = proc;
            processSelect.appendChild(opt);
        });
    }

    // Populate likelihood options (from near miss data)
    const likelihoodSelect = document.getElementById('overviewLikelihoodFilter');
    if (likelihoodSelect && likelihoodSelect.options.length <= 1) {
        const liks = new Set();
        state.nearMiss.rawData.forEach(row => {
            const val = row.standardized_likelihood || row.initial_risk_assessment_likeliness;
            if (val) liks.add(val);
        });
        liks.forEach(lk => {
            const opt = document.createElement('option');
            opt.value = lk;
            opt.textContent = lk;
            likelihoodSelect.appendChild(opt);
        });
    }
}

// Populate combined filter options based on loaded data.  This mirrors
// populateOverviewFilters but targets the combined-specific select
// elements.  It is invoked when updating the combined analytics and
// ensures the dropdowns only populate once data has been loaded.  To
// avoid redundant work, it checks whether options beyond the default
// already exist before appending new ones.
function populateCombinedFilters() {
    const siteSelect = document.getElementById('combinedSiteFilter');
    if (!siteSelect) return;
    // If options already populated beyond default, skip
    if (siteSelect.options.length > 1) return;
    const sites = new Set();
    state.injury.rawData.forEach(row => {
        if (row.site) sites.add(row.site);
    });
    state.nearMiss.rawData.forEach(row => {
        if (row.site) sites.add(row.site);
    });
    sites.forEach(site => {
        const option = document.createElement('option');
        option.value = site;
        option.textContent = site;
        siteSelect.appendChild(option);
    });

    // Populate body part options (from injury data)
    const bodySelect = document.getElementById('combinedBodyPartFilter');
    if (bodySelect && bodySelect.options.length <= 1) {
        const parts = new Set();
        state.injury.rawData.forEach(row => {
            if (row.bodyPart) parts.add(row.bodyPart);
        });
        parts.forEach(part => {
            const opt = document.createElement('option');
            opt.value = part;
            opt.textContent = part;
            bodySelect.appendChild(opt);
        });
    }

    // Populate impact options (from near miss data)
    const impactSelect = document.getElementById('combinedImpactFilter');
    if (impactSelect && impactSelect.options.length <= 1) {
        const impacts = new Set();
        state.nearMiss.rawData.forEach(row => {
            if (row.primaryImpact) impacts.add(row.primaryImpact);
        });
        impacts.forEach(im => {
            const opt = document.createElement('option');
            opt.value = im;
            opt.textContent = im;
            impactSelect.appendChild(opt);
        });
    }

    // Populate location options (from near miss data)
    const locationSelect = document.getElementById('combinedLocationFilter');
    if (locationSelect && locationSelect.options.length <= 1) {
        const locs = new Set();
        state.nearMiss.rawData.forEach(row => {
            if (row.location) locs.add(row.location);
        });
        locs.forEach(loc => {
            const opt = document.createElement('option');
            opt.value = loc;
            opt.textContent = loc;
            locationSelect.appendChild(opt);
        });
    }

    // Populate process options (from near miss data)
    const processSelect = document.getElementById('combinedProcessFilter');
    if (processSelect && processSelect.options.length <= 1) {
        const procs = new Set();
        state.nearMiss.rawData.forEach(row => {
            if (row.processPath) procs.add(row.processPath);
        });
        procs.forEach(proc => {
            const opt = document.createElement('option');
            opt.value = proc;
            opt.textContent = proc;
            processSelect.appendChild(opt);
        });
    }

    // Populate likelihood options (from near miss data).  If there are no
    // custom values we fall back to the defaults defined in the HTML.
    const likelihoodSelect = document.getElementById('combinedLikelihoodFilter');
    if (likelihoodSelect && likelihoodSelect.options.length <= 1) {
        const liks = new Set();
        state.nearMiss.rawData.forEach(row => {
            const val = row.standardized_likelihood || row.initial_risk_assessment_likeliness;
            if (val) liks.add(val);
        });
        liks.forEach(lk => {
            const opt = document.createElement('option');
            opt.value = lk;
            opt.textContent = lk;
            likelihoodSelect.appendChild(opt);
        });
    }
}

// Apply combined filters to both injury and near miss modules and refresh
// the overview and combined analytics.  This function reads values from
// the combined filter dropdowns, sets the corresponding values on
// underlying module-specific selects, and then triggers the same logic
// used by applyFilters() and applyOverviewFilters().
function applyCombinedFilters() {
    const site = document.getElementById('combinedSiteFilter').value;
    const severity = document.getElementById('combinedSeverityFilter').value;
    const dateFrom = document.getElementById('combinedDateFrom').value;
    const dateTo = document.getElementById('combinedDateTo').value;
    const bodyPart = document.getElementById('combinedBodyPartFilter') ? document.getElementById('combinedBodyPartFilter').value : '';
    const impact = document.getElementById('combinedImpactFilter') ? document.getElementById('combinedImpactFilter').value : '';
    const locationVal = document.getElementById('combinedLocationFilter') ? document.getElementById('combinedLocationFilter').value : '';
    const processVal = document.getElementById('combinedProcessFilter') ? document.getElementById('combinedProcessFilter').value : '';
    const likelihood = document.getElementById('combinedLikelihoodFilter') ? document.getElementById('combinedLikelihoodFilter').value : '';

    // Propagate selections to module-specific filters
    const injurySiteSel = document.getElementById('injurySiteFilter');
    const nearMissSiteSel = document.getElementById('nearMissSiteFilter');
    if (injurySiteSel) injurySiteSel.value = site;
    if (nearMissSiteSel) nearMissSiteSel.value = site;
    const injurySeveritySel = document.getElementById('injurySeverityFilter');
    const nearMissSeveritySel = document.getElementById('nearMissSeverityFilter');
    if (injurySeveritySel) injurySeveritySel.value = severity;
    if (nearMissSeveritySel) nearMissSeveritySel.value = severity;
    const injuryFrom = document.getElementById('injuryDateFrom');
    const injuryTo = document.getElementById('injuryDateTo');
    const nearMissFrom = document.getElementById('nearMissDateFrom');
    const nearMissTo = document.getElementById('nearMissDateTo');
    if (injuryFrom) injuryFrom.value = dateFrom;
    if (injuryTo) injuryTo.value = dateTo;
    if (nearMissFrom) nearMissFrom.value = dateFrom;
    if (nearMissTo) nearMissTo.value = dateTo;
    // Body part only applies to injury
    const injuryBodySel = document.getElementById('injuryBodyPartFilter');
    if (injuryBodySel) injuryBodySel.value = bodyPart;
    // Impact, location, process, likelihood apply to near miss
    const nearMissImpactSel = document.getElementById('nearMissPrimaryImpactFilter');
    if (nearMissImpactSel) nearMissImpactSel.value = impact;
    const nearMissLocationSel = document.getElementById('nearMissLocationFilter');
    if (nearMissLocationSel) nearMissLocationSel.value = locationVal;
    const nearMissProcessSel = document.getElementById('nearMissProcessFilter');
    if (nearMissProcessSel) nearMissProcessSel.value = processVal;
    const nearMissLikelihoodSel = document.getElementById('nearMissLikelihoodFilter');
    if (nearMissLikelihoodSel) nearMissLikelihoodSel.value = likelihood;

    // Also update the overview unified filters so the UI remains in sync
    const overviewSiteSel = document.getElementById('overviewSiteFilter');
    if (overviewSiteSel) overviewSiteSel.value = site;
    const overviewSeveritySel = document.getElementById('overviewSeverityFilter');
    if (overviewSeveritySel) overviewSeveritySel.value = severity;
    const overviewBodySel = document.getElementById('overviewBodyPartFilter');
    if (overviewBodySel) overviewBodySel.value = bodyPart;
    const overviewImpactSel = document.getElementById('overviewImpactFilter');
    if (overviewImpactSel) overviewImpactSel.value = impact;
    const overviewLocationSel = document.getElementById('overviewLocationFilter');
    if (overviewLocationSel) overviewLocationSel.value = locationVal;
    const overviewProcessSel = document.getElementById('overviewProcessFilter');
    if (overviewProcessSel) overviewProcessSel.value = processVal;
    const overviewLikelihoodSel = document.getElementById('overviewLikelihoodFilter');
    if (overviewLikelihoodSel) overviewLikelihoodSel.value = likelihood;
    const overviewFrom = document.getElementById('overviewDateFrom');
    const overviewTo = document.getElementById('overviewDateTo');
    if (overviewFrom) overviewFrom.value = dateFrom;
    if (overviewTo) overviewTo.value = dateTo;

    // Reapply filters on the underlying data and refresh the dashboards
    applyFilters('injury');
    applyFilters('nearmiss');
    // Explicitly update combined analytics in case the combined tab is active
    updateCombinedAnalytics();
    // Also refresh the overview KPI and charts so they reflect the selection
    updateOverview();
}

// Apply overview filters to both injury and near miss modules
function applyOverviewFilters() {
    const site = document.getElementById('overviewSiteFilter').value;
    const severity = document.getElementById('overviewSeverityFilter').value;
    const dateFrom = document.getElementById('overviewDateFrom').value;
    const dateTo = document.getElementById('overviewDateTo').value;

    // Additional filters
    const bodyPart = document.getElementById('overviewBodyPartFilter') ? document.getElementById('overviewBodyPartFilter').value : '';
    const impact = document.getElementById('overviewImpactFilter') ? document.getElementById('overviewImpactFilter').value : '';
    const locationVal = document.getElementById('overviewLocationFilter') ? document.getElementById('overviewLocationFilter').value : '';
    const processVal = document.getElementById('overviewProcessFilter') ? document.getElementById('overviewProcessFilter').value : '';
    const likelihood = document.getElementById('overviewLikelihoodFilter') ? document.getElementById('overviewLikelihoodFilter').value : '';
    // Update underlying module filters
    const injurySiteSel = document.getElementById('injurySiteFilter');
    const nearMissSiteSel = document.getElementById('nearMissSiteFilter');
    if (injurySiteSel) injurySiteSel.value = site;
    if (nearMissSiteSel) nearMissSiteSel.value = site;
    const injurySeveritySel = document.getElementById('injurySeverityFilter');
    const nearMissSeveritySel = document.getElementById('nearMissSeverityFilter');
    if (injurySeveritySel) injurySeveritySel.value = severity;
    if (nearMissSeveritySel) nearMissSeveritySel.value = severity;
    const injuryFrom = document.getElementById('injuryDateFrom');
    const injuryTo = document.getElementById('injuryDateTo');
    const nearMissFrom = document.getElementById('nearMissDateFrom');
    const nearMissTo = document.getElementById('nearMissDateTo');
    if (injuryFrom) injuryFrom.value = dateFrom;
    if (injuryTo) injuryTo.value = dateTo;
    if (nearMissFrom) nearMissFrom.value = dateFrom;
    if (nearMissTo) nearMissTo.value = dateTo;

    // Propagate body part filter to injury module
    const injuryBodySel = document.getElementById('injuryBodyPartFilter');
    if (injuryBodySel) injuryBodySel.value = bodyPart;
    // Propagate impact, location, process, likelihood to near miss module
    const nearMissImpactSel = document.getElementById('nearMissPrimaryImpactFilter');
    if (nearMissImpactSel) nearMissImpactSel.value = impact;
    const nearMissLocationSel = document.getElementById('nearMissLocationFilter');
    if (nearMissLocationSel) nearMissLocationSel.value = locationVal;
    const nearMissProcessSel = document.getElementById('nearMissProcessFilter');
    if (nearMissProcessSel) nearMissProcessSel.value = processVal;
    const nearMissLikelihoodSel = document.getElementById('nearMissLikelihoodFilter');
    if (nearMissLikelihoodSel) nearMissLikelihoodSel.value = likelihood;
    // Reapply filters for each module
    applyFilters('injury');
    applyFilters('nearmiss');
    // Refresh overview dashboard after filters propagate
    updateOverview();
    // Explicitly refresh combined analytics based on updated filters
    updateCombinedAnalytics();
}

// Update KPIs
function updateKPIs() {
    if (state.injury.rawData.length === 0 && state.nearMiss.rawData.length === 0) return;
    
    const hoursWorked = 200000;
    
    // TRIR
    const recordableCount = state.injury.filteredData.filter(r => r.recordable === 1).length;
    const trir = ((recordableCount / hoursWorked) * 200000).toFixed(2);
    document.getElementById('kpiTRIR').textContent = trir;
    
    // LTIR
    const lostTimeCount = state.injury.filteredData.filter(r => r.total_dafw_days > 0).length;
    const ltir = ((lostTimeCount / hoursWorked) * 200000).toFixed(2);
    document.getElementById('kpiLTIR').textContent = ltir;
    
    // DAFWR
    const totalDaysLost = state.injury.filteredData.reduce((sum, r) => sum + (r.total_dafw_days || 0), 0);
    const dafwr = ((totalDaysLost / hoursWorked) * 200000).toFixed(2);
    document.getElementById('kpiDAFWR').textContent = dafwr;
    
    // NMFR
    const nearMissCount = state.nearMiss.filteredData.length;
    const nmfr = ((nearMissCount / hoursWorked) * 200000).toFixed(2);
    document.getElementById('kpiNMFR').textContent = nmfr;
}

// Update Dashboards
function updateInjuryDashboard() {
    const data = state.injury.filteredData;
    
    document.getElementById('injuryTotal').textContent = data.length;
    document.getElementById('injuryRecordable').textContent = 
        data.filter(r => r.recordable === 1).length;
    document.getElementById('injuryLostTime').textContent = 
        data.filter(r => r.total_dafw_days > 0).length;
    document.getElementById('injuryDaysLost').textContent = 
        data.reduce((sum, r) => sum + (r.total_dafw_days || 0), 0);
    document.getElementById('injuryOTR').textContent = 
        data.filter(r => r.otr === 'yes').length;
    
    const recordableCount = data.filter(r => r.recordable === 1).length;
    const recordableRate = data.length > 0 ? 
        ((recordableCount / data.length) * 100).toFixed(1) : '0.0';
    document.getElementById('injuryRecordableRate').textContent = recordableRate + '%';
}

function updateNearMissDashboard() {
    const data = state.nearMiss.filteredData;
    
    document.getElementById('nearMissTotal').textContent = data.length;
    
    const risks = data.map(r => parseFloat(r.risk)).filter(r => !isNaN(r));
    const avgRisk = risks.length > 0 ? 
        (risks.reduce((a, b) => a + b, 0) / risks.length).toFixed(1) : '0.0';
    document.getElementById('nearMissRisk').textContent = avgRisk;
    
    document.getElementById('nearMissHigh').textContent = 
        data.filter(r => r.severity === 'A' || r.severity === 'B').length;
    
    // Calculate closure rate (more meaningful metric)
    const closedCount = data.filter(r => r.status === 'Closed' || r.status === 'Completed').length;
    const closureRate = data.length > 0 ? ((closedCount / data.length) * 100).toFixed(0) : '0';
    document.getElementById('nearMissRepeat').textContent = closureRate + '%';
    
    const actionableCount = data.filter(r => parseFloat(r.risk) >= 7).length;
    document.getElementById('nearMissActionable').textContent = actionableCount;
    
    const frequencyRate = data.length > 0 ? 
        (data.length / 30).toFixed(1) : '0.0';
    document.getElementById('nearMissFrequency').textContent = frequencyRate;
}

// Update Tables with Pagination
function updateInjuryTable() {
    const tbody = document.getElementById('injuryTableBody');
    const data = state.injury.filteredData;
    const currentPage = state.injury.currentPage;
    const startIndex = (currentPage - 1) * state.itemsPerPage;
    const endIndex = Math.min(startIndex + state.itemsPerPage, data.length);
    const pageData = data.slice(startIndex, endIndex);
    
    if (pageData.length === 0) {
        tbody.innerHTML = '<tr><td colspan="11" style="text-align: center; padding: 3rem;">No data matches the current filters.</td></tr>';
        updatePaginationInfo('injury', 0, 0);
        return;
    }
    
    tbody.innerHTML = pageData.map(row => {
        const austinUrl = row.austin_url && row.austin_url !== '#' ? row.austin_url : '#';
        const austinLinkHtml = austinUrl !== '#' ?
            `<a href="${austinUrl}" target="_blank" class="austin-link" title="Austin Link">
                <span>üìö</span>
            </a>` :
            `<span class="austin-link disabled" title="No Austin Link available">üìö</span>`;
        
        return `
            <tr>
                <td>${row.case_number || 'N/A'}</td>
                <td>${row.incident_date || 'N/A'}</td>
                <td>${row.site || 'N/A'}</td>
                <td title="${row.bodyPart || ''}">${(row.bodyPart || 'N/A').substring(0, 20)}${row.bodyPart?.length > 20 ? '...' : ''}</td>
                <td>${row.type || 'N/A'}</td>
                <td><span class="badge badge-${getSeverityClass(row.severity)}">${row.severity}</span></td>
                <td><span class="badge badge-${row.recordable === 1 ? 'danger' : 'success'}">${row.recordable === 1 ? 'Yes' : 'No'}</span></td>
                <td><span class="badge badge-${row.otr === 'yes' ? 'warning' : 'info'}">${row.otr === 'yes' ? 'Yes' : 'No'}</span></td>
                <td>${row.total_dafw_days || 0}</td>
                <td title="${row.rootCause || ''}">${(row.rootCause || 'N/A').substring(0, 20)}${row.rootCause?.length > 20 ? '...' : ''}</td>
                <td>
                    <button class="btn btn-sm btn-outline" onclick="viewDetails('injury', '${row.case_number}')">View</button>
                    ${austinLinkHtml}
                </td>
            </tr>
        `;
    }).join('');
    
    updatePaginationInfo('injury', currentPage, Math.ceil(data.length / state.itemsPerPage));
}

function updateNearMissTable() {
    const tbody = document.getElementById('nearMissTableBody');
    const data = state.nearMiss.filteredData;
    const currentPage = state.nearMiss.currentPage;
    const startIndex = (currentPage - 1) * state.itemsPerPage;
    const endIndex = Math.min(startIndex + state.itemsPerPage, data.length);
    const pageData = data.slice(startIndex, endIndex);
    
    if (pageData.length === 0) {
        tbody.innerHTML = '<tr><td colspan="10" style="text-align: center; padding: 3rem;">No data matches the current filters.</td></tr>';
        updatePaginationInfo('nearmiss', 0, 0);
        return;
    }
    
    tbody.innerHTML = pageData.map(row => {
        const austinUrl = row.austin_url && row.austin_url !== '#' ? row.austin_url : '#';
        const austinLinkHtml = austinUrl !== '#' ?
            `<a href="${austinUrl}" target="_blank" class="austin-link" title="Austin Link">
                <span>üìö</span>
            </a>` :
            `<span class="austin-link disabled" title="No Austin Link available">üìö</span>`;

        return `
        <tr>
            <td>${row.incident_id || 'N/A'}</td>
            <td>${row.nearmiss_date || 'N/A'}</td>
            <td>${row.site || 'N/A'}</td>
            <td title="${row.location || ''}">${(row.location || 'N/A').substring(0, 25)}${row.location?.length > 25 ? '...' : ''}</td>
            <td title="${row.processPath || ''}">${(row.processPath || 'N/A').substring(0, 20)}${row.processPath?.length > 20 ? '...' : ''}</td>
            <td title="${row.primaryImpact || ''}">${(row.primaryImpact || 'N/A').substring(0, 20)}${row.primaryImpact?.length > 20 ? '...' : ''}</td>
            <td><span class="badge badge-${getSeverityClass(row.severity)}">${row.severity}</span></td>
            <td><span class="badge badge-info">${row.standardized_likelihood || 'N/A'}</span></td>
            <td><span class="badge badge-${getRiskClass(row.risk)}">${row.risk || 'N/A'}</span></td>
            <td>
                <button class="btn btn-sm btn-outline" onclick="viewDetails('nearmiss', '${row.incident_id}')">View</button>
                ${austinLinkHtml}
            </td>
        </tr>
        `;
    }).join('');
    
    updatePaginationInfo('nearmiss', currentPage, Math.ceil(data.length / state.itemsPerPage));
}

// Pagination
function changePage(type, direction) {
    let data = [];
    if (type === 'injury') {
        data = state.injury.filteredData;
    } else if (type === 'nearmiss') {
        data = state.nearMiss.filteredData;
    } else {
        data = state.inspections.filteredData;
    }

    const totalPages = Math.max(1, Math.ceil(data.length / state.itemsPerPage));

    if (type === 'injury') {
        state.injury.currentPage += direction;
        if (state.injury.currentPage < 1) state.injury.currentPage = 1;
        if (state.injury.currentPage > totalPages) state.injury.currentPage = totalPages;
        updateInjuryTable();
    } else if (type === 'nearmiss') {
        state.nearMiss.currentPage += direction;
        if (state.nearMiss.currentPage < 1) state.nearMiss.currentPage = 1;
        if (state.nearMiss.currentPage > totalPages) state.nearMiss.currentPage = totalPages;
        updateNearMissTable();
    } else {
        state.inspections.currentPage += direction;
        if (state.inspections.currentPage < 1) state.inspections.currentPage = 1;
        if (state.inspections.currentPage > totalPages) state.inspections.currentPage = totalPages;
        updateInspectionTable();
    }
}

function updatePaginationInfo(type, currentPage, totalPages) {
    const pageInfo = document.getElementById(`${type}PageInfo`);
    const prevBtn = document.getElementById(`${type}PrevBtn`);
    const nextBtn = document.getElementById(`${type}NextBtn`);

    const pages = totalPages && totalPages > 0 ? totalPages : 1;
    const current = currentPage && currentPage > 0 ? currentPage : (totalPages > 0 ? 1 : 0);

    if (pageInfo) pageInfo.textContent = `Page ${current} of ${pages}`;
    if (prevBtn) prevBtn.disabled = current <= 1;
    if (nextBtn) nextBtn.disabled = current >= pages;
}

// Get severity class for badges
function getSeverityClass(severity) {
    switch(severity) {
        case 'A': return 'critical';
        case 'B': return 'danger';
        case 'C': return 'warning';
        case 'D': return 'success';
        default: return 'secondary';
    }
}

function getRiskClass(risk) {
    const riskValue = parseFloat(risk);
    if (riskValue >= 8) return 'critical';
    if (riskValue >= 6) return 'danger';
    if (riskValue >= 4) return 'warning';
    if (riskValue >= 2) return 'success';
    return 'info';
}

// Table Sorting Utilities
function sortData(type) {
    const sort = state[type].sort;
    const data = state[type].filteredData;
    const column = sort.column;
    const direction = sort.direction === 'asc' ? 1 : -1;
    data.sort((a, b) => {
        let valA = a[column];
        let valB = b[column];
        if (column === 'incident_date' || column === 'nearmiss_date') {
            valA = a.parsedDate;
            valB = b.parsedDate;
            if (valA === undefined || valA === null || isNaN(valA)) return -1 * direction;
            if (valB === undefined || valB === null || isNaN(valB)) return 1 * direction;
            return (valA - valB) * direction;
        }
        if (valA === undefined || valA === null) return -1 * direction;
        if (valB === undefined || valB === null) return 1 * direction;
        const numA = parseFloat(valA);
        const numB = parseFloat(valB);
        if (!isNaN(numA) && !isNaN(numB)) {
            return (numA - numB) * direction;
        }
        return valA.toString().localeCompare(valB.toString()) * direction;
    });
}

function toggleSort(type, column) {
    const sort = state[type].sort;
    if (sort.column === column) {
        sort.direction = sort.direction === 'asc' ? 'desc' : 'asc';
    } else {
        sort.column = column;
        sort.direction = column === 'incident_date' || column === 'nearmiss_date' ? 'desc' : 'asc';
    }
}

function updateSortIndicators(type) {
    const tableId = type === 'injury' ? 'injuryTable' : 'nearMissTable';
    const columns = type === 'injury' ?
        ['case_number','incident_date','site','bodyPart','type','severity','recordable','otr','total_dafw_days','rootCause'] :
        ['incident_id','nearmiss_date','site','location','processPath','primaryImpact','severity','standardized_likelihood','risk'];
    const headers = document.querySelectorAll(`#${tableId} thead th`);
    headers.forEach((th, index) => {
        if (index >= columns.length) return;
        const column = columns[index];
        const base = th.dataset.originalText || th.textContent;
        th.dataset.originalText = base;
        let text = base;
        const sort = state[type].sort;
        if (sort.column === column) {
            text += sort.direction === 'asc' ? ' ‚ñ≤' : ' ‚ñº';
        }
        th.textContent = text;
    });
}

function setupTableSorting(type) {
    const tableId = type === 'injury' ? 'injuryTable' : 'nearMissTable';
    const columns = type === 'injury' ?
        ['case_number','incident_date','site','bodyPart','type','severity','recordable','otr','total_dafw_days','rootCause'] :
        ['incident_id','nearmiss_date','site','location','processPath','primaryImpact','severity','standardized_likelihood','risk'];
    const headers = document.querySelectorAll(`#${tableId} thead th`);
    headers.forEach((th, index) => {
        if (index >= columns.length) return;
        const column = columns[index];
        th.style.cursor = 'pointer';
        th.addEventListener('click', () => {
            toggleSort(type, column);
            sortData(type);
            if (type === 'injury') {
                updateInjuryTable();
            } else {
                updateNearMissTable();
            }
            updateSortIndicators(type);
        });
    });
    updateSortIndicators(type);
}

// Initialize Charts
function initializeCharts() {
    // Injury Charts
    for (let i = 1; i <= 4; i++) {
        const ctx = document.getElementById(`injuryChart${i}`)?.getContext('2d');
        if (ctx) {
            state.injury.charts[`chart${i}`] = new Chart(ctx, {
                type: 'doughnut',
                data: { labels: [], datasets: [] },
                options: getChartOptions('doughnut')
            });
        }
    }
    
    // Near Miss Charts
    for (let i = 1; i <= 4; i++) {
        const ctx = document.getElementById(`nearMissChart${i}`)?.getContext('2d');
        if (ctx) {
            state.nearMiss.charts[`chart${i}`] = new Chart(ctx, {
                type: 'doughnut',
                data: { labels: [], datasets: [] },
                options: getChartOptions('doughnut')
            });
        }
    }

    initializeAdvancedCharts();
    initializeOverviewCharts();
    initializeCombinedCharts();
    initializeInspectionCharts();
}

function initializeAdvancedCharts() {
    const injuryAdvancedCharts = [
        { id: 'injurySeverityPatternChart', type: 'radar' },
        { id: 'injuryRecoveryTimeChart', type: 'bar' },
        { id: 'injuryCostImpactChart', type: 'line' }
    ];

    injuryAdvancedCharts.forEach(({ id, type }) => {
        const ctx = document.getElementById(id)?.getContext('2d');
        if (ctx) {
            state.injury.charts[id] = new Chart(ctx, {
                type,
                data: { labels: [], datasets: [] },
                options: getChartOptions(type)
            });
        }
    });

    const nearMissAdvancedCharts = [
        { id: 'nearMissToInjuryRatioChart', type: 'line' },
        { id: 'nearMissPredictiveRiskChart', type: 'bar' },
        { id: 'nearMissHotspotChart', type: 'bubble' }
    ];

    nearMissAdvancedCharts.forEach(({ id, type }) => {
        const ctx = document.getElementById(id)?.getContext('2d');
        if (ctx) {
            state.nearMiss.charts[id] = new Chart(ctx, {
                type,
                data: { labels: [], datasets: [] },
                options: getChartOptions(type)
            });
        }
    });
}

function initializeOverviewCharts() {
    const overviewTrendCtx = document.getElementById('overviewTrendChart')?.getContext('2d');
    if (overviewTrendCtx) {
        new Chart(overviewTrendCtx, {
            type: 'line',
            data: { labels: [], datasets: [] },
            options: getChartOptions('line')
        });
    }
    
    const overviewSiteCtx = document.getElementById('overviewSiteChart')?.getContext('2d');
    if (overviewSiteCtx) {
        new Chart(overviewSiteCtx, {
            type: 'bar',
            data: { labels: [], datasets: [] },
            options: getChartOptions('bar')
        });
    }
}

function initializeCombinedCharts() {
    const combinedChartIds = [
        'combinedTrendChart',
        'combinedSiteChart',
        'combinedSeverityChart',
        'combinedPreventionChart'
    ];

    combinedChartIds.forEach(chartId => {
        const ctx = document.getElementById(chartId)?.getContext('2d');
        if (ctx) {
            new Chart(ctx, {
                type: 'line',
                data: { labels: [], datasets: [] },
                options: getChartOptions('line')
            });
        }
    });
}

function initializeInspectionCharts() {
    const inspectionCharts = [
        { id: 'inspectionsBySite', type: 'bar' },
        { id: 'inspectionStatus', type: 'doughnut' },
        { id: 'inspectionTrend', type: 'line' },
        { id: 'inspectionTypes', type: 'pie' }
    ];

    inspectionCharts.forEach(({ id, type }) => {
        const ctx = document.getElementById(id)?.getContext('2d');
        if (ctx) {
            state.inspections.charts[id] = new Chart(ctx, {
                type,
                data: { labels: [], datasets: [] },
                options: getChartOptions(type)
            });
        }
    });
}

// Get chart options based on type
function getChartOptions(type) {
    const isDark = state.theme === 'dark';
    const textColor = isDark ? '#ffffff' : '#212121';
    const gridColor = isDark ? 'rgba(255, 255, 255, 0.1)' : 'rgba(0, 0, 0, 0.1)';
    
    const baseOptions = {
        responsive: true,
        maintainAspectRatio: false,
        plugins: {
            legend: {
                display: type === 'doughnut' || type === 'pie',
                position: 'bottom',
                labels: {
                    color: textColor,
                    padding: 15,
                    font: {
                        size: 11,
                        family: 'Amazon Ember, Arial, sans-serif'
                    }
                }
            },
            tooltip: {
                backgroundColor: isDark ? 'rgba(0, 0, 0, 0.9)' : 'rgba(255, 255, 255, 0.95)',
                titleColor: isDark ? '#ffffff' : '#212121',
                bodyColor: isDark ? '#ffffff' : '#212121',
                borderColor: AMAZON_COLORS.orange,
                borderWidth: 1,
                padding: 10,
                cornerRadius: 4,
                titleFont: {
                    size: 12,
                    weight: 'bold'
                },
                bodyFont: {
                    size: 11
                }
            }
        }
    };
    
    if (type === 'line' || type === 'bar') {
        baseOptions.scales = {
            x: {
                ticks: {
                    color: textColor,
                    font: {
                        size: 10
                    }
                },
                grid: {
                    color: gridColor,
                    lineWidth: 0.5
                }
            },
            y: {
                ticks: {
                    color: textColor,
                    font: {
                        size: 10
                    }
                },
                grid: {
                    color: gridColor,
                    lineWidth: 0.5
                },
                beginAtZero: true
            }
        };
    }
    
    return baseOptions;
}

// Update Charts
function updateInjuryCharts() {
    for (let i = 1; i <= 4; i++) {
        const selector = document.querySelector(`#injuryChart${i}`).parentElement.parentElement.querySelector('select');
        if (selector) {
            updateInjuryChart(i, selector.value);
        }
    }
}

function updateNearMissCharts() {
    for (let i = 1; i <= 4; i++) {
        const selector = document.querySelector(`#nearMissChart${i}`).parentElement.parentElement.querySelector('select');
        if (selector) {
            updateNearMissChart(i, selector.value);
        }
    }
}

function updateInjuryChart(chartNum, type) {
    const chart = state.injury.charts[`chart${chartNum}`];
    if (!chart || state.injury.filteredData.length === 0) return;
    
    const data = state.injury.filteredData;
    
    // Call the universal chart update function
    updateUniversalChart(chart, data, type, 'injury');
}

function updateNearMissChart(chartNum, type) {
    const chart = state.nearMiss.charts[`chart${chartNum}`];
    if (!chart || state.nearMiss.filteredData.length === 0) return;
    
    const data = state.nearMiss.filteredData;
    
    // Call the universal chart update function
    updateUniversalChart(chart, data, type, 'nearmiss');
}

// Universal chart update function
function updateUniversalChart(chart, data, type, module) {
    switch(type) {
        // Distribution & Overview
        case 'severity':
            updateSeverityChart(chart, data);
            break;
        case 'site':
            updateSiteChart(chart, data);
            break;
        case 'trend':
            updateTrendChart(chart, data, module);
            break;
        case 'recordableDistribution':
            updateRecordableDistributionChart(chart, data);
            break;
        case 'statusDistribution':
            updateStatusDistributionChart(chart, data);
            break;

        // Injury specific - Body Part
        case 'bodyPart':
            updateBodyPartChart(chart, data);
            break;
        case 'bodyPartTrend':
            updateBodyPartTrendChart(chart, data);
            break;
        case 'bodyPartHeatmap':
            updateBodyPartHeatmapChart(chart, data);
            break;
        case 'bodyPartBySite':
            updateBodyPartBySiteChart(chart, data);
            break;

        // Injury specific - Type & Mechanism
        case 'injuryType':
            updateInjuryTypeChart(chart, data);
            break;
        case 'mechanismOfInjury':
            updateMechanismOfInjuryChart(chart, data);
            break;
        case 'injuryTypeByProcess':
            updateInjuryTypeByProcessChart(chart, data);
            break;

        // Process & Operations
        case 'processPath':
            updateProcessPathChart(chart, data);
            break;
        case 'shiftAnalysis':
            updateShiftAnalysisChart(chart, data);
            break;
        case 'departmentAnalysis':
            updateDepartmentAnalysisChart(chart, data);
            break;
        case 'processRisk':
            updateProcessRiskChart(chart, data);
            break;
        case 'processHeatmap':
            updateProcessHeatmapChart(chart, data);
            break;

        // Root Cause & Contributing Factors
        case 'rootCause':
            updateRootCauseChart(chart, data);
            break;
        case 'contributingFactors':
            updateContributingFactorsChart(chart, data);
            break;
        case 'rootCauseBySite':
            updateRootCauseBySiteChart(chart, data);
            break;
        case 'rootCauseTrend':
            updateRootCauseTrendChart(chart, data);
            break;

        // Performance Metrics
        case 'recordableRate':
            updateRecordableRateChart(chart, data);
            break;
        case 'recordableTrend':
            updateRecordableTrendChart(chart, data);
            break;
        case 'dafwAnalysis':
        case 'dafwDistribution':
            updateDafwAnalysisChart(chart, data);
            break;
        case 'otrAnalysis':
            updateOtrAnalysisChart(chart, data);
            break;
        case 'lostTimeAnalysis':
            updateLostTimeAnalysisChart(chart, data);
            break;

        // Near Miss specific - Location
        case 'location':
            updateLocationChart(chart, data);
            break;
        case 'locationHeatmap':
            updateLocationHeatmapChart(chart, data);
            break;
        case 'locationTrend':
            updateLocationTrendChart(chart, data);
            break;
        case 'locationBySeverity':
            updateLocationBySeverityChart(chart, data);
            break;

        // Near Miss specific - Impact
        case 'impact':
        case 'impactType':
            updateImpactChart(chart, data);
            break;
        case 'impactSeverity':
            updateImpactSeverityChart(chart, data);
            break;
        case 'impactByLocation':
            updateImpactByLocationChart(chart, data);
            break;
        case 'impactTrend':
            updateImpactTrendChart(chart, data);
            break;

        // Risk Analysis
        case 'riskScore':
            updateRiskScoreChart(chart, data);
            break;
        case 'riskTrend':
            updateRiskTrendChart(chart, data);
            break;
        case 'riskMatrix':
            updateRiskMatrixChart(chart, data);
            break;
        case 'likelihood':
            updateLikelihoodChart(chart, data);
            break;
        case 'likelihoodTrend':
            updateLikelihoodTrendChart(chart, data);
            break;

        // Trends
        case 'severityTrend':
            updateSeverityTrendChart(chart, data);
            break;
        case 'weeklyTrend':
            updateWeeklyTrendChart(chart, data);
            break;

        // Prevention & Advanced
        case 'preventionEffectiveness':
        case 'preventionOpportunities':
            updatePreventionOpportunitiesChart(chart, data);
            break;
        case 'closureAnalysis':
            updateClosureAnalysisChart(chart, data);
            break;
        case 'mitigationStatus':
            updateMitigationStatusChart(chart, data);
            break;
        case 'hazardCategories':
            updateHazardCategoriesChart(chart, data);
            break;

        // Advanced Analytics
        case 'severityPrediction':
            updateSeverityPredictionChart(chart, data);
            break;
        case 'recoveryTimeAnalysis':
            updateRecoveryTimeAnalysisChart(chart, data);
            break;
        case 'costImpactAnalysis':
            updateCostImpactAnalysisChart(chart, data);
            break;
        case 'nearMissToInjuryRatio':
            updateNearMissToInjuryRatioChart(chart, data);
            break;
        case 'predictiveRisk':
            updatePredictiveRiskChart(chart, data);
            break;
        case 'hotspotAnalysis':
            updateHotspotAnalysisChart(chart, data);
            break;

        default:
            console.warn(`Unknown chart type: ${type}`);
            updateSeverityChart(chart, data); // Fallback
    }
}

// Chart Update Functions
function updateSeverityChart(chart, data) {
    const severityCounts = {
        'A': data.filter(r => r.severity === 'A').length,
        'B': data.filter(r => r.severity === 'B').length,
        'C': data.filter(r => r.severity === 'C').length,
        'D': data.filter(r => r.severity === 'D').length
    };
    
    const nonZero = Object.entries(severityCounts).filter(([_, count]) => count > 0);
    
    chart.config.type = 'doughnut';
    chart.data = {
        labels: nonZero.map(([severity]) => `Severity ${severity}`),
        datasets: [{
            data: nonZero.map(([, count]) => count),
            backgroundColor: nonZero.map(([severity]) => SEVERITY_COLORS[severity])
        }]
    };
    chart.options = getChartOptions('doughnut');
    chart.update();
}

function updateRootCauseChart(chart, data) {
    const causeCounts = {};
    data.forEach(row => {
        const cause = row.rootCause || 'Unknown';
        causeCounts[cause] = (causeCounts[cause] || 0) + 1;
    });
    
    const topCauses = Object.entries(causeCounts)
        .sort((a, b) => b[1] - a[1])
        .slice(0, 8);
    
    chart.config.type = 'bar';
    chart.data = {
        labels: topCauses.map(([cause]) => cause.substring(0, 25) + (cause.length > 25 ? '...' : '')),
        datasets: [{
            data: topCauses.map(([, count]) => count),
            backgroundColor: AMAZON_COLORS.orange,
            borderColor: AMAZON_COLORS.darkBlue,
            borderWidth: 1,
            label: 'Cases'
        }]
    };
    chart.options = getChartOptions('bar');
    chart.options.indexAxis = 'y';
    chart.update();
}

function updateProcessPathChart(chart, data) {
    const pathCounts = {};
    data.forEach(row => {
        const path = row.processPath || 'Unknown';
        pathCounts[path] = (pathCounts[path] || 0) + 1;
    });
    
    const topPaths = Object.entries(pathCounts)
        .sort((a, b) => b[1] - a[1])
        .slice(0, 8);
    
    chart.config.type = 'bar';
    chart.data = {
        labels: topPaths.map(([path]) => path),
        datasets: [{
            data: topPaths.map(([, count]) => count),
            backgroundColor: AMAZON_COLORS.darkBlue,
            borderColor: AMAZON_COLORS.orange,
            borderWidth: 1,
            label: 'Cases'
        }]
    };
    chart.options = getChartOptions('bar');
    chart.update();
}

function updateContributingFactorsChart(chart, data) {
    const factorCounts = {};
    data.forEach(row => {
        const factor = row.contributingFactor || 'Unknown';
        factorCounts[factor] = (factorCounts[factor] || 0) + 1;
    });
    
    const topFactors = Object.entries(factorCounts)
        .sort((a, b) => b[1] - a[1])
        .slice(0, 6);
    
    chart.config.type = 'doughnut';
    chart.data = {
        labels: topFactors.map(([factor]) => factor),
        datasets: [{
            data: topFactors.map(([, count]) => count),
            backgroundColor: [
                AMAZON_COLORS.orange,
                AMAZON_COLORS.darkBlue,
                AMAZON_COLORS.lightBlue,
                '#FF5722',
                '#4CAF50',
                '#2196F3'
            ],
            label: 'Cases'
        }]
    };
    chart.options = getChartOptions('doughnut');
    chart.update();
}

function updateTrendChart(chart, data, type) {
    const monthlyData = {};
    data.forEach(row => {
        if (row.parsedDate && !isNaN(row.parsedDate)) {
            const monthKey = `${row.parsedDate.getFullYear()}-${String(row.parsedDate.getMonth() + 1).padStart(2, '0')}`;
            monthlyData[monthKey] = (monthlyData[monthKey] || 0) + 1;
        }
    });
    
    const sortedMonths = Object.keys(monthlyData).sort();
    const monthNames = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
    
    chart.config.type = 'line';
    chart.data = {
        labels: sortedMonths.map(m => {
            const [year, month] = m.split('-');
            return `${monthNames[parseInt(month)-1]} ${year}`;
        }),
        datasets: [{
            label: type === 'injury' ? 'Injuries' : 'Near Misses',
            data: sortedMonths.map(m => monthlyData[m]),
            borderColor: AMAZON_COLORS.orange,
            backgroundColor: `${AMAZON_COLORS.orange}20`,
            tension: 0.3,
            borderWidth: 2
        }]
    };
    chart.options = getChartOptions('line');
    chart.update();
}

function updateRecordableRateChart(chart, data) {
    const siteData = {};
    data.forEach(row => {
        const site = row.site || 'Unknown';
        if (!siteData[site]) {
            siteData[site] = { total: 0, recordable: 0 };
        }
        siteData[site].total++;
        if (row.recordable === 1) {
            siteData[site].recordable++;
        }
    });
    
    const siteRates = Object.entries(siteData)
        .map(([site, data]) => ({
            site,
            rate: data.total > 0 ? ((data.recordable / data.total) * 100).toFixed(1) : 0
        }))
        .sort((a, b) => b.rate - a.rate);
    
    chart.config.type = 'bar';
    chart.data = {
        labels: siteRates.map(s => s.site),
        datasets: [{
            data: siteRates.map(s => parseFloat(s.rate)),
            backgroundColor: '#FF5722',
            borderWidth: 1,
            label: 'Recordable Rate %'
        }]
    };
    chart.options = getChartOptions('bar');
    chart.options.scales.y.max = 100;
    chart.update();
}

function updateSiteChart(chart, data) {
    const siteCounts = {};
    data.forEach(row => {
        const site = row.site || 'Unknown';
        siteCounts[site] = (siteCounts[site] || 0) + 1;
    });
    
    const sites = Object.entries(siteCounts)
        .sort((a, b) => b[1] - a[1]);
    
    chart.config.type = 'bar';
    chart.data = {
        labels: sites.map(([site]) => site),
        datasets: [{
            data: sites.map(([, count]) => count),
            backgroundColor: sites.map((_, i) => 
                i % 2 === 0 ? AMAZON_COLORS.orange : AMAZON_COLORS.darkBlue
            ),
            borderWidth: 1,
            label: 'Incidents'
        }]
    };
    chart.options = getChartOptions('bar');
    chart.update();
}

function updateImpactTypeChart(chart, data) {
    const impactCounts = {};
    data.forEach(row => {
        const impact = row.impactType || row.primaryImpact || row.type || 'Unknown';
        impactCounts[impact] = (impactCounts[impact] || 0) + 1;
    });
    
    const topImpacts = Object.entries(impactCounts)
        .sort((a, b) => b[1] - a[1])
        .slice(0, 6);
    
    chart.config.type = 'pie';
    chart.data = {
        labels: topImpacts.map(([impact]) => impact),
        datasets: [{
            data: topImpacts.map(([, count]) => count),
            backgroundColor: [
                AMAZON_COLORS.orange,
                AMAZON_COLORS.darkBlue,
                AMAZON_COLORS.lightBlue,
                '#FF5722',
                '#4CAF50',
                '#2196F3'
            ],
            label: 'Cases'
        }]
    };
    chart.options = getChartOptions('pie');
    chart.update();
}

function updateSeverityBySiteChart(chart, data) {
    const siteData = {};
    data.forEach(row => {
        const site = row.site || 'Unknown';
        if (!siteData[site]) {
            siteData[site] = { A: 0, B: 0, C: 0, D: 0 };
        }
        if (row.severity && siteData[site][row.severity] !== undefined) {
            siteData[site][row.severity]++;
        }
    });
    
    const sites = Object.keys(siteData).sort();
    
    chart.config.type = 'bar';
    chart.data = {
        labels: sites,
        datasets: [
            {
                label: 'Severity A',
                data: sites.map(site => siteData[site].A),
                backgroundColor: SEVERITY_COLORS.A
            },
            {
                label: 'Severity B',
                data: sites.map(site => siteData[site].B),
                backgroundColor: SEVERITY_COLORS.B
            },
            {
                label: 'Severity C',
                data: sites.map(site => siteData[site].C),
                backgroundColor: SEVERITY_COLORS.C
            },
            {
                label: 'Severity D',
                data: sites.map(site => siteData[site].D),
backgroundColor: SEVERITY_COLORS.D
            }
        ]
    };
    chart.options = getChartOptions('bar');
    chart.options.scales.x.stacked = true;
    chart.options.scales.y.stacked = true;
    chart.update();
}

function updateLocationHeatmapChart(chart, data) {
    const locationRisk = {};
    data.forEach(row => {
        const location = row.location || row.initial_info_location_event || 'Unknown';
        if (!locationRisk[location]) {
            locationRisk[location] = { total: 0, count: 0 };
        }
        const risk = parseFloat(row.risk || calculateRiskScore(row));
        if (!isNaN(risk)) {
            locationRisk[location].total += risk;
            locationRisk[location].count++;
        }
    });
    
    const topLocations = Object.entries(locationRisk)
        .map(([location, data]) => ({
            location,
            avgRisk: data.count > 0 ? (data.total / data.count).toFixed(1) : 0,
            count: data.count
        }))
        .sort((a, b) => b.avgRisk - a.avgRisk)
        .slice(0, 10);
    
    chart.config.type = 'bar';
    chart.data = {
        labels: topLocations.map(l => l.location.substring(0, 30) + (l.location.length > 30 ? '...' : '')),
        datasets: [{
            label: 'Average Risk Score',
            data: topLocations.map(l => parseFloat(l.avgRisk)),
            backgroundColor: topLocations.map(l => {
                const risk = parseFloat(l.avgRisk);
                if (risk >= 8) return SEVERITY_COLORS.A;
                if (risk >= 6) return SEVERITY_COLORS.B;
                if (risk >= 4) return SEVERITY_COLORS.C;
                return SEVERITY_COLORS.D;
            }),
            borderWidth: 1
        }]
    };
    chart.options = getChartOptions('bar');
    chart.options.indexAxis = 'y';
    chart.update();
}

function updateBodyPartHeatmapChart(chart, data) {
    const bodyPartSeverity = {};
    data.forEach(row => {
        const part = row.bodyPart || 'Unknown';
        if (!bodyPartSeverity[part]) {
            bodyPartSeverity[part] = { A: 0, B: 0, C: 0, D: 0, total: 0 };
        }
        if (row.severity && bodyPartSeverity[part][row.severity] !== undefined) {
            bodyPartSeverity[part][row.severity]++;
            bodyPartSeverity[part].total++;
        }
    });
    
    const topBodyParts = Object.entries(bodyPartSeverity)
        .sort((a, b) => b[1].total - a[1].total)
        .slice(0, 10);
    
    chart.config.type = 'bar';
    chart.data = {
        labels: topBodyParts.map(([part]) => part.substring(0, 20) + (part.length > 20 ? '...' : '')),
        datasets: [
            {
                label: 'Severity A',
                data: topBodyParts.map(([, data]) => data.A),
                backgroundColor: SEVERITY_COLORS.A
            },
            {
                label: 'Severity B',
                data: topBodyParts.map(([, data]) => data.B),
                backgroundColor: SEVERITY_COLORS.B
            },
            {
                label: 'Severity C',
                data: topBodyParts.map(([, data]) => data.C),
                backgroundColor: SEVERITY_COLORS.C
            },
            {
                label: 'Severity D',
                data: topBodyParts.map(([, data]) => data.D),
                backgroundColor: SEVERITY_COLORS.D
            }
        ]
    };
    chart.options = getChartOptions('bar');
    chart.options.indexAxis = 'y';
    chart.options.scales.x.stacked = true;
    chart.options.scales.y.stacked = true;
    chart.update();
}

function updateRiskTrendChart(chart, data) {
    const monthlyRisk = {};
    data.forEach(row => {
        if (row.parsedDate && !isNaN(row.parsedDate)) {
            const monthKey = `${row.parsedDate.getFullYear()}-${String(row.parsedDate.getMonth() + 1).padStart(2, '0')}`;
            if (!monthlyRisk[monthKey]) {
                monthlyRisk[monthKey] = { total: 0, count: 0 };
            }
            const risk = parseFloat(row.risk || calculateRiskScore(row));
            if (!isNaN(risk)) {
                monthlyRisk[monthKey].total += risk;
                monthlyRisk[monthKey].count++;
            }
        }
    });
    
    const sortedMonths = Object.keys(monthlyRisk).sort();
    const monthNames = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
    
    chart.config.type = 'line';
    chart.data = {
        labels: sortedMonths.map(m => {
            const [year, month] = m.split('-');
            return `${monthNames[parseInt(month)-1]} ${year}`;
        }),
        datasets: [{
            label: 'Average Risk Score',
            data: sortedMonths.map(m => 
                monthlyRisk[m].count > 0 ? (monthlyRisk[m].total / monthlyRisk[m].count).toFixed(1) : 0
            ),
            borderColor: AMAZON_COLORS.orange,
            backgroundColor: `${AMAZON_COLORS.orange}20`,
            tension: 0.3,
            borderWidth: 2
        }]
    };
    chart.options = getChartOptions('line');
    chart.update();
}

function updateHighRiskAreasChart(chart, data) {
    const highRiskData = data.filter(r => {
        const risk = parseFloat(r.risk || calculateRiskScore(r));
        return risk >= 7;
    });
    
    const areaCounts = {};
    highRiskData.forEach(row => {
        const key = `${row.location || row.bodyPart || 'Unknown'} - ${row.processPath || 'Unknown'}`;
        areaCounts[key] = (areaCounts[key] || 0) + 1;
    });
    
    const topAreas = Object.entries(areaCounts)
        .sort((a, b) => b[1] - a[1])
        .slice(0, 10);
    
    chart.config.type = 'bar';
    chart.data = {
        labels: topAreas.map(([area]) => area.substring(0, 40) + (area.length > 40 ? '...' : '')),
        datasets: [{
            label: 'High Risk Incidents',
            data: topAreas.map(([, count]) => count),
            backgroundColor: SEVERITY_COLORS.A,
            borderColor: SEVERITY_COLORS.B,
            borderWidth: 1
        }]
    };
    chart.options = getChartOptions('bar');
    chart.options.indexAxis = 'y';
    chart.update();
}

function updatePreventionOpportunitiesChart(chart, data) {
    const preventionData = {};
    
    data.forEach(row => {
        const factor = row.contributingFactor || 'Unknown';
        if (!preventionData[factor]) {
            preventionData[factor] = {
                total: 0,
                highSeverity: 0,
                preventable: 0
            };
        }
        preventionData[factor].total++;
        if (row.severity === 'A' || row.severity === 'B') {
            preventionData[factor].highSeverity++;
        }
        if (row.standardized_likelihood !== 'Rare') {
            preventionData[factor].preventable++;
        }
    });
    
    const topOpportunities = Object.entries(preventionData)
        .map(([factor, data]) => ({
            factor,
            preventionScore: (data.preventable / data.total) * (data.highSeverity + 1)
        }))
        .sort((a, b) => b.preventionScore - a.preventionScore)
        .slice(0, 8);
    
    chart.config.type = 'bar';
    chart.data = {
        labels: topOpportunities.map(o => o.factor),
        datasets: [{
            label: 'Prevention Priority Score',
            data: topOpportunities.map(o => o.preventionScore.toFixed(1)),
            backgroundColor: AMAZON_COLORS.orange,
            borderColor: AMAZON_COLORS.darkBlue,
            borderWidth: 1
        }]
    };
    chart.options = getChartOptions('bar');
    chart.update();
}

function updateQualityMetricsChart(chart, data, module) {
    const metrics = module === 'injury' ? state.injury.qualityMetrics : state.nearMiss.qualityMetrics;
    
    if (!metrics || !metrics.totalRecords) {
        chart.data = { labels: [], datasets: [] };
        chart.update();
        return;
    }
    
    chart.config.type = 'radar';
    chart.data = {
        labels: ['Completeness', 'Uniqueness', 'Accuracy', 'Consistency', 'Overall'],
        datasets: [{
            label: 'Data Quality Score',
            data: [
                metrics.dataCompleteness,
                Math.max(0, 100 - (metrics.duplicates * 5)),
                Math.max(0, 100 - (metrics.missingCriticalFields / metrics.totalRecords * 100)),
                85, // Placeholder for consistency
                metrics.qualityScore
            ],
            borderColor: AMAZON_COLORS.orange,
            backgroundColor: `${AMAZON_COLORS.orange}30`,
            borderWidth: 2
        }]
    };
    chart.options = {
        ...getChartOptions('radar'),
        scales: {
            r: {
                beginAtZero: true,
                max: 100,
                ticks: {
                    stepSize: 20
                }
            }
        }
    };
    chart.update();
}

function updateTrendForecastChart(chart, data, module) {
    const monthlyData = {};
    data.forEach(row => {
        if (row.parsedDate && !isNaN(row.parsedDate)) {
            const monthKey = `${row.parsedDate.getFullYear()}-${String(row.parsedDate.getMonth() + 1).padStart(2, '0')}`;
            monthlyData[monthKey] = (monthlyData[monthKey] || 0) + 1;
        }
    });
    
    const sortedMonths = Object.keys(monthlyData).sort();
    const monthNames = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
    
    // Simple linear regression for forecast
    const values = sortedMonths.map(m => monthlyData[m]);
    const n = values.length;
    const sumX = values.reduce((sum, _, i) => sum + i, 0);
    const sumY = values.reduce((sum, y) => sum + y, 0);
    const sumXY = values.reduce((sum, y, i) => sum + i * y, 0);
    const sumX2 = values.reduce((sum, _, i) => sum + i * i, 0);
    
    const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
    const intercept = (sumY - slope * sumX) / n;
    
    // Generate forecast for next 3 months
    const forecastMonths = [];
    const forecastValues = [];
    for (let i = 0; i < 3; i++) {
        const lastMonth = sortedMonths[sortedMonths.length - 1];
        const [year, month] = lastMonth.split('-');
        const nextDate = new Date(parseInt(year), parseInt(month) - 1 + i + 1);
        const nextMonth = `${nextDate.getFullYear()}-${String(nextDate.getMonth() + 1).padStart(2, '0')}`;
        forecastMonths.push(nextMonth);
        forecastValues.push(Math.max(0, Math.round(slope * (n + i) + intercept)));
    }
    
    chart.config.type = 'line';
    chart.data = {
        labels: [
            ...sortedMonths.map(m => {
                const [year, month] = m.split('-');
                return `${monthNames[parseInt(month)-1]} ${year}`;
            }),
            ...forecastMonths.map(m => {
                const [year, month] = m.split('-');
                return `${monthNames[parseInt(month)-1]} ${year} (Forecast)`;
            })
        ],
        datasets: [
            {
                label: 'Actual',
                data: [...values, ...Array(3).fill(null)],
                borderColor: AMAZON_COLORS.darkBlue,
                backgroundColor: `${AMAZON_COLORS.darkBlue}20`,
                tension: 0.3,
                borderWidth: 2
            },
            {
                label: 'Forecast',
                data: [...Array(values.length).fill(null), values[values.length - 1], ...forecastValues],
                borderColor: AMAZON_COLORS.orange,
                backgroundColor: `${AMAZON_COLORS.orange}20`,
                borderDash: [5, 5],
                tension: 0.3,
                borderWidth: 2
            }
        ]
    };
    chart.options = getChartOptions('line');
    chart.update();
}

function updateWeeklyTrendChart(chart, data) {
    const weeklyData = {};
    data.forEach(row => {
        if (row.parsedDate && !isNaN(row.parsedDate)) {
            const weekKey = getWeekNumber(row.parsedDate);
            weeklyData[weekKey] = (weeklyData[weekKey] || 0) + 1;
        }
    });
    
    const sortedWeeks = Object.keys(weeklyData).sort().slice(-12); // Last 12 weeks
    
    chart.config.type = 'line';
    chart.data = {
        labels: sortedWeeks.map(w => `Week ${w.split('-')[1]}`),
        datasets: [{
            label: 'Weekly Incidents',
            data: sortedWeeks.map(w => weeklyData[w]),
            borderColor: AMAZON_COLORS.orange,
            backgroundColor: `${AMAZON_COLORS.orange}20`,
            tension: 0.3
        }]
    };
    chart.options = getChartOptions('line');
    chart.update();
}

function updateBodyPartTrendChart(chart, data) {
    const monthlyBodyPart = {};
    
    data.forEach(row => {
        if (row.parsedDate && !isNaN(row.parsedDate) && row.bodyPart) {
            const monthKey = `${row.parsedDate.getFullYear()}-${String(row.parsedDate.getMonth() + 1).padStart(2, '0')}`;
            if (!monthlyBodyPart[monthKey]) {
                monthlyBodyPart[monthKey] = {};
            }
            const part = row.bodyPart;
            monthlyBodyPart[monthKey][part] = (monthlyBodyPart[monthKey][part] || 0) + 1;
        }
    });
    
    const months = Object.keys(monthlyBodyPart).sort().slice(-6);
    const topBodyParts = getTopBodyParts(data, 5);
    
    chart.config.type = 'line';
    chart.data = {
        labels: months.map(formatMonthLabel),
        datasets: topBodyParts.map((part, index) => ({
            label: part,
            data: months.map(month => monthlyBodyPart[month][part] || 0),
            borderColor: getColorByIndex(index),
            backgroundColor: `${getColorByIndex(index)}20`,
            tension: 0.3
        }))
    };
    chart.options = getChartOptions('line');
    chart.update();
}

function updateShiftAnalysisChart(chart, data) {
    const shiftData = {};
    data.forEach(row => {
        const shift = row.initial_info_shift || row.shift || 'Unknown';
        shiftData[shift] = (shiftData[shift] || 0) + 1;
    });
    
    chart.config.type = 'bar';
    chart.data = {
        labels: Object.keys(shiftData),
        datasets: [{
            label: 'Incidents by Shift',
            data: Object.values(shiftData),
            backgroundColor: AMAZON_COLORS.darkBlue,
            borderColor: AMAZON_COLORS.orange,
            borderWidth: 1
        }]
    };
    chart.options = getChartOptions('bar');
    chart.update();
}

function updateDafwAnalysisChart(chart, data) {
    const dafwRanges = {
        '0 Days': 0,
        '1-3 Days': 0,
        '4-7 Days': 0,
        '8-14 Days': 0,
        '15-30 Days': 0,
        '30+ Days': 0
    };
    
    data.forEach(row => {
        const days = row.total_dafw_days || 0;
        if (days === 0) dafwRanges['0 Days']++;
        else if (days <= 3) dafwRanges['1-3 Days']++;
        else if (days <= 7) dafwRanges['4-7 Days']++;
        else if (days <= 14) dafwRanges['8-14 Days']++;
        else if (days <= 30) dafwRanges['15-30 Days']++;
        else dafwRanges['30+ Days']++;
    });
    
    chart.config.type = 'doughnut';
    chart.data = {
        labels: Object.keys(dafwRanges),
        datasets: [{
            data: Object.values(dafwRanges),
            backgroundColor: [
                SEVERITY_COLORS.D,
                SEVERITY_COLORS.C,
                AMAZON_COLORS.orange,
                SEVERITY_COLORS.B,
                SEVERITY_COLORS.A,
                AMAZON_COLORS.darkBlue
            ]
        }]
    };
    chart.options = getChartOptions('doughnut');
    chart.update();
}

function updateOtrAnalysisChart(chart, data) {
    const otrData = data.filter(r => r.otr === 'yes');
    const nonOtrData = data.filter(r => r.otr === 'no');
    
    chart.config.type = 'pie';
    chart.data = {
        labels: ['On The Road', 'Under The Roof'],
        datasets: [{
            data: [otrData.length, nonOtrData.length],
            backgroundColor: [AMAZON_COLORS.orange, AMAZON_COLORS.darkBlue]
        }]
    };
    chart.options = getChartOptions('pie');
    chart.update();
}

function updateLocationChart(chart, data) {
    const locationCounts = {};
    data.forEach(row => {
        const location = row.location || row.initial_info_location_event || 'Unknown';
        locationCounts[location] = (locationCounts[location] || 0) + 1;
    });

    const topLocations = Object.entries(locationCounts)
        .sort((a, b) => b[1] - a[1])
        .slice(0, 10);

    chart.config.type = 'bar';
    chart.data = {
        labels: topLocations.map(([loc]) => loc.substring(0, 30) + (loc.length > 30 ? '...' : '')),
        datasets: [{
            label: 'Near Misses',
            data: topLocations.map(([, count]) => count),
            backgroundColor: AMAZON_COLORS.orange,
            borderWidth: 1
        }]
    };
    chart.options = getChartOptions('bar');
    chart.options.indexAxis = 'y';
    chart.update();
}

function updateImpactChart(chart, data) {
    const impactCounts = {};
    data.forEach(row => {
        const impact = row.primaryImpact || row.initial_info_primary_impact || 'Unknown';
        impactCounts[impact] = (impactCounts[impact] || 0) + 1;
    });

    const topImpacts = Object.entries(impactCounts)
        .sort((a, b) => b[1] - a[1])
        .slice(0, 8);

    chart.config.type = 'doughnut';
    chart.data = {
        labels: topImpacts.map(([impact]) => impact),
        datasets: [{
            data: topImpacts.map(([, count]) => count),
            backgroundColor: [
                AMAZON_COLORS.orange,
                AMAZON_COLORS.darkBlue,
                '#FF5722',
                '#4CAF50',
                '#2196F3',
                '#9C27B0',
                '#FFC107',
                '#795548'
            ]
        }]
    };
    chart.options = getChartOptions('doughnut');
    chart.update();
}

function updateLikelihoodChart(chart, data) {
    const likelihoodCounts = {
        'Rare': 0,
        'Unlikely': 0,
        'Possible': 0,
        'Likely': 0,
        'Almost Certain': 0
    };

    data.forEach(row => {
        const likelihood = row.standardized_likelihood || 'Possible';
        if (likelihoodCounts[likelihood] !== undefined) {
            likelihoodCounts[likelihood]++;
        }
    });

    chart.config.type = 'bar';
    chart.data = {
        labels: Object.keys(likelihoodCounts),
        datasets: [{
            label: 'Frequency',
            data: Object.values(likelihoodCounts),
            backgroundColor: [
                SEVERITY_COLORS.D,
                SEVERITY_COLORS.C,
                AMAZON_COLORS.orange,
                SEVERITY_COLORS.B,
                SEVERITY_COLORS.A
            ]
        }]
    };
    chart.options = getChartOptions('bar');
    chart.update();
}

function updateInjuryTypeChart(chart, data) {
    const typeCounts = {};
    data.forEach(row => {
        const type = row.type || row.injury_type || 'Unknown';
        typeCounts[type] = (typeCounts[type] || 0) + 1;
    });

    const topTypes = Object.entries(typeCounts)
        .sort((a, b) => b[1] - a[1])
        .slice(0, 8);

    chart.config.type = 'pie';
    chart.data = {
        labels: topTypes.map(([type]) => type),
        datasets: [{
            data: topTypes.map(([, count]) => count),
            backgroundColor: [
                '#FF6384',
                '#36A2EB',
                '#FFCE56',
                '#4BC0C0',
                '#9966FF',
                '#FF9F40',
                '#FF6384',
                '#C9CBCF'
            ]
        }]
    };
    chart.options = getChartOptions('pie');
    chart.update();
}

function updateRecordableDistributionChart(chart, data) {
    const recordable = data.filter(r => r.recordable === 1).length;
    const nonRecordable = data.filter(r => r.recordable === 0).length;

    chart.config.type = 'doughnut';
    chart.data = {
        labels: ['Recordable', 'Non-Recordable'],
        datasets: [{
            data: [recordable, nonRecordable],
            backgroundColor: [SEVERITY_COLORS.B, SEVERITY_COLORS.D]
        }]
    };
    chart.options = getChartOptions('doughnut');
    chart.update();
}

function updateStatusDistributionChart(chart, data) {
    const statusCounts = {};
    data.forEach(row => {
        const status = row.status || 'Unknown';
        statusCounts[status] = (statusCounts[status] || 0) + 1;
    });

    chart.config.type = 'pie';
    chart.data = {
        labels: Object.keys(statusCounts),
        datasets: [{
            data: Object.values(statusCounts),
            backgroundColor: Object.keys(statusCounts).map((status, index) => {
                if (status === 'Closed' || status === 'Completed') return SEVERITY_COLORS.D;
                if (status === 'Open' || status === 'In Progress') return AMAZON_COLORS.orange;
                if (status === 'Pending') return SEVERITY_COLORS.C;
                return ['#9E9E9E', '#607D8B', '#795548'][index % 3];
            })
        }]
    };
    chart.options = getChartOptions('pie');
    chart.update();
}

function updateClosureAnalysisChart(chart, data) {
    const monthlyClosures = {};

    data.forEach(row => {
        if (row.parsedDate && !isNaN(row.parsedDate)) {
            const monthKey = `${row.parsedDate.getFullYear()}-${String(row.parsedDate.getMonth() + 1).padStart(2, '0')}`;
            if (!monthlyClosures[monthKey]) {
                monthlyClosures[monthKey] = { total: 0, closed: 0 };
            }
            monthlyClosures[monthKey].total++;
            if (row.status === 'Closed' || row.status === 'Completed') {
                monthlyClosures[monthKey].closed++;
            }
        }
    });

    const sortedMonths = Object.keys(monthlyClosures).sort();
    const monthNames = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];

    chart.config.type = 'line';
    chart.data = {
        labels: sortedMonths.map(m => {
            const [year, month] = m.split('-');
            return `${monthNames[parseInt(month)-1]} ${year}`;
        }),
        datasets: [{
            label: 'Closure Rate %',
            data: sortedMonths.map(m => {
                const data = monthlyClosures[m];
                return data.total > 0 ? ((data.closed / data.total) * 100).toFixed(1) : 0;
            }),
            borderColor: SEVERITY_COLORS.D,
            backgroundColor: `${SEVERITY_COLORS.D}20`,
            tension: 0.3
        }]
    };
    chart.options = getChartOptions('line');
    chart.options.scales.y.max = 100;
    chart.update();
}

function updateBodyPartBySiteChart(chart, data) {
    const siteBodyPart = {};
    
    data.forEach(row => {
        const site = row.site || 'Unknown';
        const bodyPart = row.bodyPart || row.initial_info_principal_body_part || 'Unknown';
        
        if (!siteBodyPart[site]) {
            siteBodyPart[site] = {};
        }
        siteBodyPart[site][bodyPart] = (siteBodyPart[site][bodyPart] || 0) + 1;
    });
    
    const sites = Object.keys(siteBodyPart).slice(0, 5);
    const bodyParts = [...new Set(data.map(r => r.bodyPart || r.initial_info_principal_body_part || 'Unknown'))]
        .slice(0, 5);
    
    chart.config.type = 'bar';
    chart.data = {
        labels: sites,
        datasets: bodyParts.map((part, index) => ({
            label: part.substring(0, 20),
            data: sites.map(site => siteBodyPart[site][part] || 0),
            backgroundColor: getColorByIndex(index)
        }))
    };
    chart.options = getChartOptions('bar');
    chart.options.scales.x.stacked = true;
    chart.options.scales.y.stacked = true;
    chart.update();
}

function updateMechanismOfInjuryChart(chart, data) {
    const mechanisms = {};
    
    data.forEach(row => {
        // Use impact type as mechanism proxy
        const mechanism = row.initial_info_impact_type_primary || row.type || 'Unknown';
        mechanisms[mechanism] = (mechanisms[mechanism] || 0) + 1;
    });
    
    const topMechanisms = Object.entries(mechanisms)
        .sort((a, b) => b[1] - a[1])
        .slice(0, 8);
    
    chart.config.type = 'doughnut';
    chart.data = {
        labels: topMechanisms.map(([mech]) => mech),
        datasets: [{
            data: topMechanisms.map(([, count]) => count),
            backgroundColor: [
                '#FF6384', '#36A2EB', '#FFCE56', '#4BC0C0',
                '#9966FF', '#FF9F40', '#FF6384', '#C9CBCF'
            ]
        }]
    };
    chart.options = getChartOptions('doughnut');
    chart.update();
}

function updateDepartmentAnalysisChart(chart, data) {
    const deptData = {};
    
    data.forEach(row => {
        const dept = row.initial_info_contractor_department || row.suborg || 'Unknown';
        deptData[dept] = (deptData[dept] || 0) + 1;
    });
    
    const topDepts = Object.entries(deptData)
        .sort((a, b) => b[1] - a[1])
        .slice(0, 10);
    
    chart.config.type = 'bar';
    chart.data = {
        labels: topDepts.map(([dept]) => dept.substring(0, 20)),
        datasets: [{
            label: 'Incidents',
            data: topDepts.map(([, count]) => count),
            backgroundColor: AMAZON_COLORS.darkBlue,
            borderColor: AMAZON_COLORS.orange,
            borderWidth: 1
        }]
    };
    chart.options = getChartOptions('bar');
    chart.update();
}

function updateRootCauseTrendChart(chart, data) {
    const monthlyRootCause = {};
    
    data.forEach(row => {
        if (row.parsedDate && !isNaN(row.parsedDate)) {
            const monthKey = `${row.parsedDate.getFullYear()}-${String(row.parsedDate.getMonth() + 1).padStart(2, '0')}`;
            const cause = row.rootCause || row.rca_primary_cause || 'Unknown';
            
            if (!monthlyRootCause[monthKey]) {
                monthlyRootCause[monthKey] = {};
            }
            monthlyRootCause[monthKey][cause] = (monthlyRootCause[monthKey][cause] || 0) + 1;
        }
    });
    
    const months = Object.keys(monthlyRootCause).sort().slice(-6);
    const topCauses = [...new Set(data.map(r => r.rootCause || r.rca_primary_cause || 'Unknown'))]
        .slice(0, 5);
    
    chart.config.type = 'line';
    chart.data = {
        labels: months.map(formatMonthLabel),
        datasets: topCauses.map((cause, index) => ({
            label: cause.substring(0, 30),
            data: months.map(month => monthlyRootCause[month][cause] || 0),
            borderColor: getColorByIndex(index),
            backgroundColor: `${getColorByIndex(index)}20`,
            tension: 0.3
        }))
    };
    chart.options = getChartOptions('line');
    chart.update();
}

function updateRecordableTrendChart(chart, data) {
    const monthlyData = {};
    
    data.forEach(row => {
        if (row.parsedDate && !isNaN(row.parsedDate)) {
            const monthKey = `${row.parsedDate.getFullYear()}-${String(row.parsedDate.getMonth() + 1).padStart(2, '0')}`;
            if (!monthlyData[monthKey]) {
                monthlyData[monthKey] = { total: 0, recordable: 0 };
            }
            monthlyData[monthKey].total++;
            if (row.recordable === 1) {
                monthlyData[monthKey].recordable++;
            }
        }
    });
    
    const sortedMonths = Object.keys(monthlyData).sort();
    
    chart.config.type = 'line';
    chart.data = {
        labels: sortedMonths.map(formatMonthLabel),
        datasets: [{
            label: 'Recordable Rate %',
            data: sortedMonths.map(m => {
                const data = monthlyData[m];
                return data.total > 0 ? ((data.recordable / data.total) * 100).toFixed(1) : 0;
            }),
            borderColor: SEVERITY_COLORS.B,
            backgroundColor: `${SEVERITY_COLORS.B}20`,
            tension: 0.3
        }]
    };
    chart.options = getChartOptions('line');
    chart.options.scales.y.max = 100;
    chart.update();
}

function updateLostTimeAnalysisChart(chart, data) {
    const lostTimeData = data.filter(r => r.total_dafw_days > 0);
    const siteLostTime = {};
    
    lostTimeData.forEach(row => {
        const site = row.site || 'Unknown';
        if (!siteLostTime[site]) {
            siteLostTime[site] = { count: 0, totalDays: 0 };
        }
        siteLostTime[site].count++;
        siteLostTime[site].totalDays += row.total_dafw_days;
    });
    
    const sites = Object.keys(siteLostTime);
    
    chart.config.type = 'bar';
    chart.data = {
        labels: sites,
        datasets: [
            {
                label: 'Lost Time Cases',
                data: sites.map(site => siteLostTime[site].count),
                backgroundColor: SEVERITY_COLORS.B,
                yAxisID: 'y'
            },
            {
                label: 'Total Days Lost',
                data: sites.map(site => siteLostTime[site].totalDays),
                backgroundColor: AMAZON_COLORS.orange,
                yAxisID: 'y1'
            }
        ]
    };
    chart.options = {
        ...getChartOptions('bar'),
        scales: {
            y: {
                type: 'linear',
                display: true,
                position: 'left',
                title: { display: true, text: 'Cases' }
            },
            y1: {
                type: 'linear',
                display: true,
                position: 'right',
                title: { display: true, text: 'Days' },
                grid: { drawOnChartArea: false }
            }
        }
    };
    chart.update();
}

// Near Miss specific functions

function updateLocationTrendChart(chart, data) {
    const monthlyLocation = {};
    
    data.forEach(row => {
        if (row.parsedDate && !isNaN(row.parsedDate)) {
            const monthKey = `${row.parsedDate.getFullYear()}-${String(row.parsedDate.getMonth() + 1).padStart(2, '0')}`;
            const location = row.location || row.initial_info_location_event || 'Unknown';
            
            if (!monthlyLocation[monthKey]) {
                monthlyLocation[monthKey] = {};
            }
            monthlyLocation[monthKey][location] = (monthlyLocation[monthKey][location] || 0) + 1;
        }
    });
    
    const months = Object.keys(monthlyLocation).sort().slice(-6);
    const topLocations = [...new Set(data.map(r => r.location || r.initial_info_location_event || 'Unknown'))]
        .slice(0, 5);
    
    chart.config.type = 'line';
    chart.data = {
        labels: months.map(formatMonthLabel),
        datasets: topLocations.map((location, index) => ({
            label: location.substring(0, 20),
            data: months.map(month => monthlyLocation[month][location] || 0),
            borderColor: getColorByIndex(index),
            backgroundColor: `${getColorByIndex(index)}20`,
            tension: 0.3
        }))
    };
    chart.options = getChartOptions('line');
    chart.update();
}

function updateLocationBySeverityChart(chart, data) {
    const locationSeverity = {};
    
    data.forEach(row => {
        const location = row.location || row.initial_info_location_event || 'Unknown';
        const severity = row.severity || row.potential_severity || 'Unknown';
        
        if (!locationSeverity[location]) {
            locationSeverity[location] = { A: 0, B: 0, C: 0, D: 0 };
        }
        if (locationSeverity[location][severity] !== undefined) {
            locationSeverity[location][severity]++;
        }
    });
    
    const topLocations = Object.entries(locationSeverity)
        .sort((a, b) => {
            const totalA = a[1].A + a[1].B + a[1].C + a[1].D;
            const totalB = b[1].A + b[1].B + b[1].C + b[1].D;
            return totalB - totalA;
        })
        .slice(0, 8);
    
    chart.config.type = 'bar';
    chart.data = {
        labels: topLocations.map(([loc]) => loc.substring(0, 25)),
        datasets: [
            {
                label: 'Severity A',
                data: topLocations.map(([, data]) => data.A),
                backgroundColor: SEVERITY_COLORS.A
            },
            {
                label: 'Severity B',
                data: topLocations.map(([, data]) => data.B),
                backgroundColor: SEVERITY_COLORS.B
            },
            {
                label: 'Severity C',
                data: topLocations.map(([, data]) => data.C),
                backgroundColor: SEVERITY_COLORS.C
            },
            {
                label: 'Severity D',
                data: topLocations.map(([, data]) => data.D),
                backgroundColor: SEVERITY_COLORS.D
            }
        ]
    };
    chart.options = getChartOptions('bar');
    chart.options.scales.x.stacked = true;
    chart.options.scales.y.stacked = true;
    chart.update();
}

function updateImpactSeverityChart(chart, data) {
    const impactSeverity = {};
    
    data.forEach(row => {
        const impact = row.primaryImpact || row.initial_info_primary_impact || 'Unknown';
        const severity = row.severity || row.potential_severity || 'Unknown';
        
        if (!impactSeverity[impact]) {
            impactSeverity[impact] = { A: 0, B: 0, C: 0, D: 0 };
        }
        if (impactSeverity[impact][severity] !== undefined) {
            impactSeverity[impact][severity]++;
        }
    });
    
    const topImpacts = Object.entries(impactSeverity)
        .sort((a, b) => {
            const totalA = a[1].A + a[1].B + a[1].C + a[1].D;
            const totalB = b[1].A + b[1].B + b[1].C + b[1].D;
            return totalB - totalA;
        })
        .slice(0, 6);
    
    chart.config.type = 'bar';
    chart.data = {
        labels: topImpacts.map(([impact]) => impact),
        datasets: [
            {
                label: 'Severity A',
                data: topImpacts.map(([, data]) => data.A),
                backgroundColor: SEVERITY_COLORS.A
            },
            {
                label: 'Severity B',
                data: topImpacts.map(([, data]) => data.B),
                backgroundColor: SEVERITY_COLORS.B
            },
            {
                label: 'Severity C',
                data: topImpacts.map(([, data]) => data.C),
                backgroundColor: SEVERITY_COLORS.C
            },
            {
                label: 'Severity D',
                data: topImpacts.map(([, data]) => data.D),
                backgroundColor: SEVERITY_COLORS.D
            }
        ]
    };
    chart.options = getChartOptions('bar');
    chart.options.scales.x.stacked = true;
    chart.options.scales.y.stacked = true;
    chart.update();
}

function updateRiskScoreChart(chart, data) {
    const riskRanges = {
        '0-2': 0,
        '2-4': 0,
        '4-6': 0,
        '6-8': 0,
        '8-10': 0
    };
    
    data.forEach(row => {
        const risk = parseFloat(row.risk || calculateRiskScore(row));
        if (risk <= 2) riskRanges['0-2']++;
        else if (risk <= 4) riskRanges['2-4']++;
        else if (risk <= 6) riskRanges['4-6']++;
        else if (risk <= 8) riskRanges['6-8']++;
        else riskRanges['8-10']++;
    });
    
    chart.config.type = 'bar';
    chart.data = {
        labels: Object.keys(riskRanges),
        datasets: [{
            label: 'Near Misses',
            data: Object.values(riskRanges),
            backgroundColor: [
                SEVERITY_COLORS.D,
                SEVERITY_COLORS.C,
                AMAZON_COLORS.orange,
                SEVERITY_COLORS.B,
                SEVERITY_COLORS.A
            ]
        }]
    };
    chart.options = getChartOptions('bar');
    chart.update();
}

function updateSeverityTrendChart(chart, data) {
    const monthlySeverity = {};
    
    data.forEach(row => {
        if (row.parsedDate && !isNaN(row.parsedDate)) {
            const monthKey = `${row.parsedDate.getFullYear()}-${String(row.parsedDate.getMonth() + 1).padStart(2, '0')}`;
            const severity = row.severity || row.potential_severity || 'Unknown';
            
            if (!monthlySeverity[monthKey]) {
                monthlySeverity[monthKey] = { A: 0, B: 0, C: 0, D: 0 };
            }
            if (monthlySeverity[monthKey][severity] !== undefined) {
                monthlySeverity[monthKey][severity]++;
            }
        }
    });
    
    const sortedMonths = Object.keys(monthlySeverity).sort();
    
    chart.config.type = 'line';
    chart.data = {
        labels: sortedMonths.map(formatMonthLabel),
        datasets: [
            {
                label: 'Severity A',
                data: sortedMonths.map(m => monthlySeverity[m].A),
                borderColor: SEVERITY_COLORS.A,
                backgroundColor: `${SEVERITY_COLORS.A}20`,
                tension: 0.3
            },
            {
                label: 'Severity B',
                data: sortedMonths.map(m => monthlySeverity[m].B),
                borderColor: SEVERITY_COLORS.B,
                backgroundColor: `${SEVERITY_COLORS.B}20`,
                tension: 0.3
            },
            {
                label: 'Severity C',
                data: sortedMonths.map(m => monthlySeverity[m].C),
                borderColor: SEVERITY_COLORS.C,
                backgroundColor: `${SEVERITY_COLORS.C}20`,
                tension: 0.3
            },
            {
                label: 'Severity D',
                data: sortedMonths.map(m => monthlySeverity[m].D),
                borderColor: SEVERITY_COLORS.D,
                backgroundColor: `${SEVERITY_COLORS.D}20`,
                tension: 0.3
            }
        ]
    };
    chart.options = getChartOptions('line');
    chart.update();
}

function updateBodyPartChart(chart, data) {
    const counts = {};
    data.forEach(row => {
        const part = row.bodyPart || row.initial_info_principal_body_part || 'Unknown';
        counts[part] = (counts[part] || 0) + 1;
    });

    const topParts = Object.entries(counts)
        .sort((a, b) => b[1] - a[1])
        .slice(0, 8);

    chart.config.type = 'bar';
    chart.data = {
        labels: topParts.map(([part]) => part),
        datasets: [{
            label: 'Cases',
            data: topParts.map(([, count]) => count),
            backgroundColor: AMAZON_COLORS.orange,
            borderWidth: 1
        }]
    };
    chart.options = getChartOptions('bar');
    chart.options.indexAxis = 'y';
    chart.update();
}

function updateInjuryTypeByProcessChart(chart, data) {
    const processTypes = {};
    data.forEach(row => {
        const process = row.processPath || 'Unknown';
        const type = row.injuryType || row.initial_info_injury_type || 'Unknown';
        if (!processTypes[process]) processTypes[process] = {};
        processTypes[process][type] = (processTypes[process][type] || 0) + 1;
    });

    const processes = Object.keys(processTypes).slice(0, 5);
    const types = [...new Set(data.map(r => r.injuryType || r.initial_info_injury_type || 'Unknown'))].slice(0, 5);

    chart.config.type = 'bar';
    chart.data = {
        labels: processes,
        datasets: types.map((t, idx) => ({
            label: t.substring(0, 20),
            data: processes.map(p => processTypes[p][t] || 0),
            backgroundColor: getColorByIndex(idx)
        }))
    };
    chart.options = getChartOptions('bar');
    chart.options.scales.x.stacked = true;
    chart.options.scales.y.stacked = true;
    chart.update();
}

function updateRootCauseBySiteChart(chart, data) {
    const siteCause = {};
    data.forEach(row => {
        const site = row.site || 'Unknown';
        const cause = row.rootCause || 'Unknown';
        if (!siteCause[site]) siteCause[site] = {};
        siteCause[site][cause] = (siteCause[site][cause] || 0) + 1;
    });

    const sites = Object.keys(siteCause).slice(0, 5);
    const causes = [...new Set(data.map(r => r.rootCause || 'Unknown'))].slice(0, 5);

    chart.config.type = 'bar';
    chart.data = {
        labels: sites,
        datasets: causes.map((c, idx) => ({
            label: c.substring(0, 20),
            data: sites.map(s => siteCause[s][c] || 0),
            backgroundColor: getColorByIndex(idx)
        }))
    };
    chart.options = getChartOptions('bar');
    chart.options.scales.x.stacked = true;
    chart.options.scales.y.stacked = true;
    chart.update();
}

function updateSeverityPredictionChart(chart, data) {
    updateSeverityChart(chart, data);
}

function updateCostImpactAnalysisChart(chart, data) {
    const ranges = { '0-100': 0, '100-500': 0, '500-1000': 0, '1000+': 0 };
    data.forEach(row => {
        const cost = parseFloat(row.estimatedCost || row.costImpact || 0);
        if (cost <= 100) ranges['0-100']++;
        else if (cost <= 500) ranges['100-500']++;
        else if (cost <= 1000) ranges['500-1000']++;
        else ranges['1000+']++;
    });

    chart.config.type = 'bar';
    chart.data = {
        labels: Object.keys(ranges),
        datasets: [{
            label: 'Cases',
            data: Object.values(ranges),
            backgroundColor: AMAZON_COLORS.darkBlue
        }]
    };
    chart.options = getChartOptions('bar');
    chart.update();
}

function updateRecoveryTimeAnalysisChart(chart, data) {
    const ranges = { '0-7': 0, '8-14': 0, '15-30': 0, '30+': 0 };
    data.forEach(row => {
        const days = parseFloat(row.recoveryTime || row.recoveryDays || row.total_dafw_days || 0);
        if (days <= 7) ranges['0-7']++;
        else if (days <= 14) ranges['8-14']++;
        else if (days <= 30) ranges['15-30']++;
        else ranges['30+']++;
    });

    chart.config.type = 'doughnut';
    chart.data = {
        labels: Object.keys(ranges),
        datasets: [{
            data: Object.values(ranges),
            backgroundColor: [SEVERITY_COLORS.D, SEVERITY_COLORS.C, AMAZON_COLORS.orange, SEVERITY_COLORS.B]
        }]
    };
    chart.options = getChartOptions('doughnut');
    chart.update();
}

function updateImpactByLocationChart(chart, data) {
    const locationImpact = {};
    data.forEach(row => {
        const location = row.location || row.initial_info_location_event || 'Unknown';
        const impact = row.primaryImpact || row.initial_info_primary_impact || 'Unknown';
        if (!locationImpact[location]) locationImpact[location] = {};
        locationImpact[location][impact] = (locationImpact[location][impact] || 0) + 1;
    });

    const locations = Object.keys(locationImpact).slice(0, 5);
    const impacts = [...new Set(data.map(r => r.primaryImpact || r.initial_info_primary_impact || 'Unknown'))].slice(0, 5);

    chart.config.type = 'bar';
    chart.data = {
        labels: locations,
        datasets: impacts.map((im, idx) => ({
            label: im.substring(0, 20),
            data: locations.map(loc => locationImpact[loc][im] || 0),
            backgroundColor: getColorByIndex(idx)
        }))
    };
    chart.options = getChartOptions('bar');
    chart.options.scales.x.stacked = true;
    chart.options.scales.y.stacked = true;
    chart.update();
}

function updateImpactTrendChart(chart, data) {
    const monthlyImpact = {};
    data.forEach(row => {
        if (row.parsedDate && !isNaN(row.parsedDate)) {
            const monthKey = `${row.parsedDate.getFullYear()}-${String(row.parsedDate.getMonth() + 1).padStart(2, '0')}`;
            const impact = row.primaryImpact || row.initial_info_primary_impact || 'Unknown';
            if (!monthlyImpact[monthKey]) monthlyImpact[monthKey] = {};
            monthlyImpact[monthKey][impact] = (monthlyImpact[monthKey][impact] || 0) + 1;
        }
    });

    const months = Object.keys(monthlyImpact).sort().slice(-6);
    const impacts = [...new Set(data.map(r => r.primaryImpact || r.initial_info_primary_impact || 'Unknown'))].slice(0, 5);

    chart.config.type = 'line';
    chart.data = {
        labels: months.map(formatMonthLabel),
        datasets: impacts.map((im, idx) => ({
            label: im,
            data: months.map(m => monthlyImpact[m][im] || 0),
            borderColor: getColorByIndex(idx),
            backgroundColor: `${getColorByIndex(idx)}20`,
            tension: 0.3
        }))
    };
    chart.options = getChartOptions('line');
    chart.update();
}

function updateProcessRiskChart(chart, data) {
    const processRisk = {};
    data.forEach(row => {
        const process = row.processPath || 'Unknown';
        const risk = parseFloat(row.risk || calculateRiskScore(row));
        if (!processRisk[process]) processRisk[process] = { total: 0, count: 0 };
        processRisk[process].total += risk;
        processRisk[process].count++;
    });

    const top = Object.entries(processRisk)
        .map(([p, v]) => [p, v.total / v.count])
        .sort((a, b) => b[1] - a[1])
        .slice(0, 8);

    chart.config.type = 'bar';
    chart.data = {
        labels: top.map(([p]) => p),
        datasets: [{
            label: 'Avg Risk',
            data: top.map(([, v]) => v),
            backgroundColor: AMAZON_COLORS.darkBlue
        }]
    };
    chart.options = getChartOptions('bar');
    chart.update();
}

function updateProcessHeatmapChart(chart, data) {
    const processSeverity = {};
    data.forEach(row => {
        const process = row.processPath || 'Unknown';
        const severity = row.severity || row.potential_severity || 'Unknown';
        if (!processSeverity[process]) processSeverity[process] = { A: 0, B: 0, C: 0, D: 0 };
        if (processSeverity[process][severity] !== undefined) processSeverity[process][severity]++;
    });

    const processes = Object.keys(processSeverity).slice(0, 5);
    const severities = ['A', 'B', 'C', 'D'];

    chart.config.type = 'bar';
    chart.data = {
        labels: processes,
        datasets: severities.map((s, idx) => ({
            label: `Severity ${s}`,
            data: processes.map(p => processSeverity[p][s] || 0),
            backgroundColor: getColorByIndex(idx)
        }))
    };
    chart.options = getChartOptions('bar');
    chart.options.scales.x.stacked = true;
    chart.options.scales.y.stacked = true;
    chart.update();
}

function updateRiskMatrixChart(chart, data) {
    const matrix = {};
    ['A','B','C','D'].forEach(sev => {
        ['Rare','Unlikely','Possible','Likely','Almost Certain'].forEach(lik => {
            matrix[`${sev}-${lik}`] = 0;
        });
    });

    data.forEach(row => {
        const severity = row.severity || row.potential_severity || 'Unknown';
        const likelihood = row.standardized_likelihood || row.likelihood || 'Unknown';
        const key = `${severity}-${likelihood}`;
        if (matrix[key] !== undefined) matrix[key]++;
    });

    const likelihoods = ['Rare','Unlikely','Possible','Likely','Almost Certain'];
    chart.config.type = 'bar';
    chart.data = {
        labels: likelihoods,
        datasets: ['A','B','C','D'].map((sev, idx) => ({
            label: `Severity ${sev}`,
            data: likelihoods.map(lik => matrix[`${sev}-${lik}`] || 0),
            backgroundColor: getColorByIndex(idx)
        }))
    };
    chart.options = getChartOptions('bar');
    chart.options.scales.x.stacked = true;
    chart.options.scales.y.stacked = true;
    chart.update();
}

function updateLikelihoodTrendChart(chart, data) {
    const monthlyLikelihood = {};
    data.forEach(row => {
        if (row.parsedDate && !isNaN(row.parsedDate)) {
            const monthKey = `${row.parsedDate.getFullYear()}-${String(row.parsedDate.getMonth() + 1).padStart(2, '0')}`;
            const likelihood = row.standardized_likelihood || row.likelihood || 'Unknown';
            if (!monthlyLikelihood[monthKey]) monthlyLikelihood[monthKey] = {};
            monthlyLikelihood[monthKey][likelihood] = (monthlyLikelihood[monthKey][likelihood] || 0) + 1;
        }
    });

    const months = Object.keys(monthlyLikelihood).sort().slice(-6);
    const likelihoods = [...new Set(data.map(r => r.standardized_likelihood || r.likelihood || 'Unknown'))];

    chart.config.type = 'line';
    chart.data = {
        labels: months.map(formatMonthLabel),
        datasets: likelihoods.map((lik, idx) => ({
            label: lik,
            data: months.map(m => monthlyLikelihood[m][lik] || 0),
            borderColor: getColorByIndex(idx),
            backgroundColor: `${getColorByIndex(idx)}20`,
            tension: 0.3
        }))
    };
    chart.options = getChartOptions('line');
    chart.update();
}

function updateHazardCategoriesChart(chart, data) {
    const counts = {};
    data.forEach(row => {
        const category = row.hazardCategory || row.hazard_category || 'Unknown';
        counts[category] = (counts[category] || 0) + 1;
    });

    const top = Object.entries(counts)
        .sort((a, b) => b[1] - a[1])
        .slice(0, 8);

    chart.config.type = 'doughnut';
    chart.data = {
        labels: top.map(([c]) => c),
        datasets: [{
            data: top.map(([, c]) => c),
            backgroundColor: top.map((_, i) => getColorByIndex(i))
        }]
    };
    chart.options = getChartOptions('doughnut');
    chart.update();
}

function updateMitigationStatusChart(chart, data) {
    const counts = {};
    data.forEach(row => {
        const status = row.mitigationStatus || row.mitigation_status || 'Unknown';
        counts[status] = (counts[status] || 0) + 1;
    });

    chart.config.type = 'pie';
    chart.data = {
        labels: Object.keys(counts),
        datasets: [{
            data: Object.values(counts),
            backgroundColor: Object.keys(counts).map((_, i) => getColorByIndex(i))
        }]
    };
    chart.options = getChartOptions('pie');
    chart.update();
}

function updateNearMissToInjuryRatioChart(chart, data) {
    const nearMissCount = state.nearMiss.filteredData ? state.nearMiss.filteredData.length : 0;
    const injuryCount = state.injury.filteredData ? state.injury.filteredData.length : 0;

    chart.config.type = 'bar';
    chart.data = {
        labels: ['Near Misses', 'Injuries'],
        datasets: [{
            label: 'Count',
            data: [nearMissCount, injuryCount],
            backgroundColor: [AMAZON_COLORS.orange, AMAZON_COLORS.darkBlue]
        }]
    };
    chart.options = getChartOptions('bar');
    chart.update();
}

function updatePredictiveRiskChart(chart, data) {
    updateRiskTrendChart(chart, data);
}

function updateHotspotAnalysisChart(chart, data) {
    updateLocationHeatmapChart(chart, data);
}

// Helper functions
function getWeekNumber(date) {
    const d = new Date(date);
    const year = d.getFullYear();
    const oneJan = new Date(year, 0, 1);
    const week = Math.ceil((((d - oneJan) / 86400000) + oneJan.getDay() + 1) / 7);
    return `${year}-${String(week).padStart(2, '0')}`;
}

function formatMonthLabel(monthKey) {
    const monthNames = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
    const [year, month] = monthKey.split('-');
    return `${monthNames[parseInt(month)-1]} ${year}`;
}

function getTopBodyParts(data, limit = 5) {
    const counts = {};
    data.forEach(row => {
        if (row.bodyPart) {
            counts[row.bodyPart] = (counts[row.bodyPart] || 0) + 1;
        }
    });
    return Object.entries(counts)
        .sort((a, b) => b[1] - a[1])
        .slice(0, limit)
        .map(([part]) => part);
}

function getColorByIndex(index) {
    const colors = [
        AMAZON_COLORS.orange,
        AMAZON_COLORS.darkBlue,
        '#FF5722',
        '#4CAF50',
        '#2196F3',
        '#9C27B0',
        '#FFC107',
        '#795548'
    ];
    return colors[index % colors.length];
}

// Update Overview
function updateOverview() {
    if (state.injury.rawData.length > 0 || state.nearMiss.rawData.length > 0) {
        // Hide welcome screen and show dashboards
        document.getElementById('welcomeScreen').style.display = 'none';
        document.getElementById('kpiDashboard').style.display = 'block';
        document.getElementById('overviewMetrics').style.display = 'grid';
        document.getElementById('overviewCharts').style.display = 'grid';
        // Show unified filters and populate options once
        const overviewFilters = document.getElementById('overviewFilters');
        if (overviewFilters) {
            populateOverviewFilters();
            overviewFilters.style.display = 'flex';
        }
        
        const totalIncidents = state.injury.filteredData.length + state.nearMiss.filteredData.length;
        document.getElementById('totalIncidents').textContent = totalIncidents;
        document.getElementById('injuryCount').textContent = state.injury.filteredData.length;
        document.getElementById('nearMissCount').textContent = state.nearMiss.filteredData.length;
        
        const allRisks = [
            ...state.injury.filteredData.map(r => parseFloat(calculateRiskScore(r))),
            ...state.nearMiss.filteredData.map(r => parseFloat(r.risk))
        ].filter(r => !isNaN(r));
        
        const avgRisk = allRisks.length > 0 ? 
            (allRisks.reduce((a, b) => a + b, 0) / allRisks.length).toFixed(1) : '0.0';
        document.getElementById('riskScore').textContent = avgRisk;
        
        updateKPIs();
        updateOverviewCharts();
    }
}

function updateOverviewCharts() {
    const trendChart = Chart.getChart("overviewTrendChart");
    if (trendChart) {
        const allData = [...state.injury.filteredData, ...state.nearMiss.filteredData];
        const monthlyData = {};
        
        allData.forEach(row => {
            if (row.parsedDate && !isNaN(row.parsedDate)) {
                const monthKey = `${row.parsedDate.getFullYear()}-${String(row.parsedDate.getMonth() + 1).padStart(2, '0')}`;
                if (!monthlyData[monthKey]) {
                    monthlyData[monthKey] = { injury: 0, nearMiss: 0 };
                }
                if (row.case_number) {
                    monthlyData[monthKey].injury++;
                } else {
                    monthlyData[monthKey].nearMiss++;
                }
            }
        });
        
        const sortedMonths = Object.keys(monthlyData).sort();
        const monthNames = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
        
        trendChart.data = {
            labels: sortedMonths.map(m => {
                const [year, month] = m.split('-');
                return `${monthNames[parseInt(month)-1]} ${year}`;
            }),
            datasets: [
                {
                    label: 'Injuries',
                    data: sortedMonths.map(m => monthlyData[m].injury),
                    borderColor: SEVERITY_COLORS.B,
                    backgroundColor: `${SEVERITY_COLORS.B}20`,
                    tension: 0.3
                },
                {
                    label: 'Near Misses',
                    data: sortedMonths.map(m => monthlyData[m].nearMiss),
                    borderColor: AMAZON_COLORS.orange,
                    backgroundColor: `${AMAZON_COLORS.orange}20`,
                    tension: 0.3
                }
            ]
        };
        trendChart.update();
    }
    
    const siteChart = Chart.getChart("overviewSiteChart");
    if (siteChart) {
        const siteCounts = {};
        
        state.injury.filteredData.forEach(row => {
            const site = row.site || 'Unknown';
            if (!siteCounts[site]) siteCounts[site] = { injury: 0, nearMiss: 0 };
            siteCounts[site].injury++;
        });
        
        state.nearMiss.filteredData.forEach(row => {
            const site = row.site || 'Unknown';
            if (!siteCounts[site]) siteCounts[site] = { injury: 0, nearMiss: 0 };
            siteCounts[site].nearMiss++;
        });
        
        const sites = Object.keys(siteCounts).sort();
        
        siteChart.data = {
            labels: sites,
            datasets: [
                {
                    label: 'Injuries',
                    data: sites.map(site => siteCounts[site].injury),
                    backgroundColor: SEVERITY_COLORS.B
                },
                {
                    label: 'Near Misses',
                    data: sites.map(site => siteCounts[site].nearMiss),
                    backgroundColor: AMAZON_COLORS.orange
                }
            ]
        };
        siteChart.update();
    }
}

// Risk Matrix Functions
function createRiskMatrices() {
    createRiskMatrix('injuryRiskMatrixGrid');
    createRiskMatrix('nearMissRiskMatrixGrid');
    createRiskMatrix('combinedRiskMatrix');
}

function createRiskMatrix(elementId) {
    const matrix = document.getElementById(elementId);
    if (!matrix) return;
    
    matrix.innerHTML = '';
    
    const severityLabels = ['', 'A', 'B', 'C', 'D'];
    const likelihoodLabels = ['', 'Rare', 'Unlikely', 'Possible', 'Likely', 'Almost Certain'];
    
    for (let s = 0; s < 6; s++) {
        for (let l = 0; l < 6; l++) {
            const cell = document.createElement('div');
            
            if (s === 0 && l === 0) {
                cell.className = 'matrix-label';
                cell.textContent = 'S/L';
            } else if (s === 0) {
                cell.className = 'matrix-label';
                cell.textContent = likelihoodLabels[l];
            } else if (l === 0) {
                cell.className = 'matrix-label';
                cell.textContent = severityLabels[s];
            } else {
                const risk = (5 - s) * l;
                let riskClass = 'risk-low';
                if (risk > 15) riskClass = 'risk-critical';
                else if (risk > 10) riskClass = 'risk-high';
                else if (risk > 5) riskClass = 'risk-medium';
                
                cell.className = `matrix-cell ${riskClass}`;
                cell.textContent = '0';
                cell.id = `${elementId}-${severityLabels[s]}-${likelihoodLabels[l]}`;
                cell.onclick = () => showMatrixDetails(severityLabels[s], likelihoodLabels[l], elementId);
            }
            
            matrix.appendChild(cell);
        }
    }
}

function updateInjuryRiskMatrix() {
    updateRiskMatrix(state.injury.filteredData, 'injuryRiskMatrixGrid');
}

function updateNearMissRiskMatrix() {
    updateRiskMatrix(state.nearMiss.filteredData, 'nearMissRiskMatrixGrid');
}

function updateRiskMatrix(data, matrixId) {
    const severityLabels = ['A', 'B', 'C', 'D'];
    const likelihoodLabels = ['Rare', 'Unlikely', 'Possible', 'Likely', 'Almost Certain'];
    
    severityLabels.forEach(severity => {
        likelihoodLabels.forEach(likelihood => {
            const cell = document.getElementById(`${matrixId}-${severity}-${likelihood}`);
            if (cell) {
                cell.textContent = '0';
                cell.style.fontWeight = 'normal';
            }
        });
    });
    
    const matrixCounts = {};
    
    data.forEach(incident => {
        const severity = incident.severity;
        const likelihood = incident.standardized_likelihood || 'Possible';
        
        if (['A', 'B', 'C', 'D'].includes(severity)) {
            const key = `${severity}-${likelihood}`;
            matrixCounts[key] = (matrixCounts[key] || 0) + 1;
        }
    });
    
    Object.entries(matrixCounts).forEach(([key, count]) => {
        const [severity, likelihood] = key.split('-');
        const cell = document.getElementById(`${matrixId}-${severity}-${likelihood}`);
        if (cell) {
            cell.textContent = count.toString();
            if (count > 0) {
                cell.style.fontWeight = 'bold';
                cell.style.fontSize = '1.1rem';
            }
        }
    });
}

function showMatrixDetails(severity, likelihood, matrixId) {
    let data;
    let type;
    
    if (matrixId.includes('injury')) {
        data = state.injury.filteredData;
        type = 'Injury';
    } else if (matrixId.includes('nearMiss')) {
        data = state.nearMiss.filteredData;
        type = 'Near Miss';
    } else {
        data = [...state.injury.filteredData, ...state.nearMiss.filteredData];
        type = 'Combined';
    }
    
    const incidents = data.filter(r => 
        r.severity === severity && 
        r.standardized_likelihood === likelihood
    );
    
    if (incidents.length === 0) {
        showStatus(`No ${type.toLowerCase()} incidents found with Severity ${severity} and Likelihood ${likelihood}`, 'info');
        return;
    }
    
    const modal = document.getElementById('detailModal');
    const title = document.getElementById('modalTitle');
    const body = document.getElementById('modalBody');
    
    title.textContent = `${type} Incidents: Severity ${severity}, ${likelihood}`;
    body.innerHTML = `
        <p style="margin-bottom: 1rem;">Total incidents: ${incidents.length}</p>
        <div style="max-height: 400px; overflow-y: auto;">
            ${incidents.map(incident => `
                <div style="padding: 1rem; border-bottom: 1px solid var(--bg-secondary);">
                    <strong>${incident.case_number || incident.incident_id}</strong><br>
                    <span style="color: var(--text-secondary);">
                        Date: ${incident.incident_date || incident.nearmiss_date || 'N/A'}<br>
                        Site: ${incident.site || 'N/A'}<br>
                        ${incident.bodyPart ? `Body Part: ${incident.bodyPart}<br>` : ''}
                        ${incident.location ? `Location: ${incident.location}<br>` : ''}
                        ${incident.processPath ? `Process: ${incident.processPath}<br>` : ''}
                    </span>
                    ${incident.austin_url && incident.austin_url !== '#' ? `<a href="${incident.austin_url}" target="_blank" class="austin-link" style="margin-top:0.5rem; display:inline-block;">Austin Link</a>` : ''}
                </div>
            `).join('')}
        </div>
    `;
    
    modal.style.display = 'block';
}

function showDuplicateDetails(groupIndex, type) {
    const metrics = type === 'nearmiss' ? state.nearMiss.qualityMetrics : state.injury.qualityMetrics;
    const group = metrics.duplicateDetails[groupIndex];
    if (!group) return;

    const source = type === 'nearmiss' ? state.nearMiss.filteredData : state.injury.filteredData;
    const records = group.indices.map(i => source[i]);

    const modal = document.getElementById('detailModal');
    const title = document.getElementById('modalTitle');
    const body = document.getElementById('modalBody');

    title.textContent = `Similar Records Review (${group.indices.length})`;
    body.innerHTML = `
        <p style="margin-bottom:1rem; color: var(--text-secondary);">
            <strong>Group:</strong> ${group.data.date || 'No date'} ‚Äì ${group.data.site} ‚Äì ${group.data.location}
            ${group.data.similarity ? `<br><strong>Grouping:</strong> ${group.data.similarity}` : ''}
        </p>
        <div style="max-height:500px; overflow-y:auto;">
            ${records.map((rec, idx) => {
                const description = rec.initial_info_incident_description || 'No description available';
                const similarity = idx > 0 ? 
                    (type === 'nearmiss' ? 
                        (calculateTextSimilarity(records[0].initial_info_incident_description || '', description) * 100).toFixed(1) + '% similar' 
                        : '') : 'Base record';
                
                return `
                <div style="padding:1.5rem; border-bottom:1px solid var(--bg-secondary); background: ${idx % 2 === 0 ? 'var(--bg-primary)' : 'var(--bg-secondary)'};">
                    <div style="display: flex; justify-content: space-between; margin-bottom: 0.5rem;">
                        <strong>${rec.case_number || rec.incident_id || 'Row #' + (group.indices[idx] + 1)}</strong>
                        ${type === 'nearmiss' && idx > 0 ? `<span style="color: var(--primary); font-size: 0.9rem;">${similarity}</span>` : ''}
                    </div>
                    <div style="color: var(--text-secondary); margin-bottom: 1rem;">
                        <div><strong>Date:</strong> ${rec.incident_date || rec.nearmiss_date || 'N/A'}</div>
                        <div><strong>Site:</strong> ${rec.site || 'N/A'}</div>
                        ${rec.location || rec.initial_info_location_event ? `<div><strong>Location:</strong> ${rec.location || rec.initial_info_location_event}</div>` : ''}
                ${rec.bodyPart ? `<div><strong>Body Part:</strong> ${rec.bodyPart}</div>` : ''}
                    </div>
                    ${type === 'nearmiss' ? `
                        <div style="background: var(--bg-tertiary); padding: 1rem; border-radius: 4px; margin-bottom: 1rem;">
                            <strong style="color: var(--primary);">Description:</strong><br>
                            <div style="margin-top: 0.5rem; line-height: 1.4; max-height: 120px; overflow-y: auto;">
                                ${description}
                            </div>
                        </div>` : ''}
                    ${rec.austin_url && rec.austin_url !== '#' ? `<a href="${rec.austin_url}" target="_blank" class="austin-link" style="display:inline-block; margin-top:0.5rem;">Austin Link</a>` : ''}
                </div>
            `}).join('')}
        </div>
        ${type === 'nearmiss' && records.length > 1 ? `
            <div style="margin-top: 1rem; padding: 1rem; background: var(--bg-secondary); border-radius: 4px;">
                <p style="color: var(--text-secondary); font-size: 0.9rem; margin: 0;">
                    <strong>Note:</strong> These records were grouped based on text similarity analysis. 
                    Review each description to determine if they represent the same incident or similar but separate events.
                </p>
            </div>` : ''}
    `;
    modal.style.display = 'block';
}

function showAllDuplicates(type) {
    const metrics = type === 'nearmiss' ? state.nearMiss.qualityMetrics : state.injury.qualityMetrics;
    if (!metrics.duplicateDetails.length) return;

    const modal = document.getElementById('detailModal');
    const title = document.getElementById('modalTitle');
    const body = document.getElementById('modalBody');

    title.textContent = 'All Duplicate Groups';
    body.innerHTML = `
        <div style="max-height:400px; overflow-y:auto;">
            ${metrics.duplicateDetails.map((dup, index) => `
                <div style="padding:1rem; border-bottom:1px solid var(--bg-secondary);">
                    <strong>Group ${index + 1}</strong><br>
                    <span style="color: var(--text-secondary);">
                        Date: ${dup.data.date || 'No date'}<br>
                        Site: ${dup.data.site}<br>
                        ${dup.data.location ? `Location: ${dup.data.location}<br>` : ''}
                    </span>
                    <div>Rows: ${dup.indices.map(i => `#${i + 1}`).join(', ')}</div>
                    <button class="btn btn-sm btn-primary" style="margin-top:0.5rem;" onclick="showDuplicateDetails(${index}, '${type}')">Review</button>
                </div>
            `).join('')}
        </div>
    `;
    modal.style.display = 'block';
}

// Timeline Functions
function updateInjuryTimeline() {
    const timelineContent = document.getElementById('injuryTimelineContent');
    const data = state.injury.filteredData
        .filter(r => r.parsedDate)
        .sort((a, b) => b.parsedDate - a.parsedDate);
    
    const currentPage = state.injury.timelinePage;
    const startIndex = (currentPage - 1) * 10;
    const endIndex = Math.min(startIndex + 10, data.length);
    const pageData = data.slice(startIndex, endIndex);
    
    if (pageData.length === 0) {
        timelineContent.innerHTML = '<p style="text-align: center; padding: 2rem;">No incidents to display.</p>';
        return;
    }
    
    timelineContent.innerHTML = pageData.map(incident => {
        const austinUrl = incident.austin_url && incident.austin_url !== '#' ? incident.austin_url : null;
        
        return `
            <div class="timeline-item">
                <div class="timeline-date">${incident.incident_date || 'N/A'}</div>
                <div class="timeline-content">
                    <h4>${incident.case_number}</h4>
                    <p><strong>Site:</strong> ${incident.site || 'N/A'}</p>
                    <p><strong>Body Part:</strong> ${incident.bodyPart || 'N/A'}</p>
                    <p><strong>Severity:</strong> <span class="badge badge-${getSeverityClass(incident.severity)}">${incident.severity}</span></p>
                    <p><strong>Recordable:</strong> <span class="badge badge-${incident.recordable === 1 ? 'danger' : 'success'}">${incident.recordable === 1 ? 'Yes' : 'No'}</span></p>
                    <p><strong>Description:</strong> ${incident.initial_info_incident_description || 'No description'}</p>
                    ${austinUrl ? `<a href="${austinUrl}" target="_blank" class="austin-link">Austin Link</a>` : ''}
                </div>
            </div>
        `;
    }).join('');
    
    const totalPages = Math.ceil(data.length / 10);
    const pageInfo = document.getElementById('injuryTimelinePageInfo');
    if (pageInfo) pageInfo.textContent = `Page ${currentPage} of ${totalPages || 1}`;
}

function updateNearMissTimeline() {
    const timelineContent = document.getElementById('nearMissTimelineContent');
    const data = state.nearMiss.filteredData
        .filter(r => r.parsedDate)
        .sort((a, b) => b.parsedDate - a.parsedDate);
    
    const currentPage = state.nearMiss.timelinePage;
    const startIndex = (currentPage - 1) * 10;
    const endIndex = Math.min(startIndex + 10, data.length);
    const pageData = data.slice(startIndex, endIndex);
    
    if (pageData.length === 0) {
        timelineContent.innerHTML = '<p style="text-align: center; padding: 2rem;">No near misses to display.</p>';
        return;
    }
    
    timelineContent.innerHTML = pageData.map(incident => {
        const austinUrl = incident.austin_url && incident.austin_url !== '#' ? incident.austin_url : null;

        return `
        <div class="timeline-item">
            <div class="timeline-date">${incident.nearmiss_date || 'N/A'}</div>
            <div class="timeline-content">
                <h4>${incident.incident_id}</h4>
                <p><strong>Site:</strong> ${incident.site || 'N/A'}</p>
                <p><strong>Location:</strong> ${incident.location || 'N/A'}</p>
                <p><strong>Process:</strong> ${incident.processPath || 'N/A'}</p>
                <p><strong>Severity:</strong> <span class="badge badge-${getSeverityClass(incident.severity)}">${incident.severity}</span></p>
                <p><strong>Risk Score:</strong> <span class="badge badge-${getRiskClass(incident.risk)}">${incident.risk}</span></p>
                <p><strong>Description:</strong> ${incident.initial_info_incident_description || 'No description'}</p>
                ${austinUrl ? `<a href="${austinUrl}" target="_blank" class="austin-link">Austin Link</a>` : ''}
            </div>
        </div>
        `;
    }).join('');
    
    const totalPages = Math.ceil(data.length / 10);
    const pageInfo = document.getElementById('nearMissTimelinePageInfo');
    if (pageInfo) pageInfo.textContent = `Page ${currentPage} of ${totalPages || 1}`;
}

function changeTimelinePage(type, direction) {
    const data = type === 'injury' ? 
        state.injury.filteredData.filter(r => r.parsedDate) : 
        state.nearMiss.filteredData.filter(r => r.parsedDate);
    
    const totalPages = Math.ceil(data.length / 10);
    
    if (type === 'injury') {
        state.injury.timelinePage += direction;
        if (state.injury.timelinePage < 1) state.injury.timelinePage = 1;
        if (state.injury.timelinePage > totalPages) state.injury.timelinePage = totalPages;
        updateInjuryTimeline();
    } else {
        state.nearMiss.timelinePage += direction;
        if (state.nearMiss.timelinePage < 1) state.nearMiss.timelinePage = 1;
        if (state.nearMiss.timelinePage > totalPages) state.nearMiss.timelinePage = totalPages;
        updateNearMissTimeline();
    }
}

// Advanced Analytics
function updateInjuryAdvancedAnalytics() {
    const severityPatternChart = state.injury.charts.injurySeverityPatternChart;
    if (severityPatternChart) {
        const severityCounts = { A: 0, B: 0, C: 0, D: 0 };
        state.injury.filteredData.forEach(row => {
            if (severityCounts[row.severity] !== undefined) {
                severityCounts[row.severity]++;
            }
        });

        severityPatternChart.config.type = 'radar';
        severityPatternChart.data = {
            labels: ['A - Critical', 'B - High', 'C - Medium', 'D - Low'],
            datasets: [{
                label: 'Incidents',
                data: Object.values(severityCounts),
                backgroundColor: 'rgba(54, 162, 235, 0.2)',
                borderColor: AMAZON_COLORS.darkBlue
            }]
        };
        severityPatternChart.options = getChartOptions('radar');
        severityPatternChart.update();
    }

    const recoveryTimeChart = state.injury.charts.injuryRecoveryTimeChart;
    if (recoveryTimeChart) {
        const severityDays = { A: [], B: [], C: [], D: [] };
        state.injury.filteredData.forEach(row => {
            const sev = row.severity;
            const days = parseFloat(row.total_dafw_days);
            if (severityDays[sev] && !isNaN(days)) {
                severityDays[sev].push(days);
            }
        });

        const avgDays = Object.keys(severityDays).map(sev => {
            const arr = severityDays[sev];
            return arr.length ? (arr.reduce((a, b) => a + b, 0) / arr.length).toFixed(1) : 0;
        });

        recoveryTimeChart.config.type = 'bar';
        recoveryTimeChart.data = {
            labels: ['Severity A', 'Severity B', 'Severity C', 'Severity D'],
            datasets: [{
                label: 'Avg DAFW Days',
                data: avgDays,
                backgroundColor: [
                    SEVERITY_COLORS.A,
                    SEVERITY_COLORS.B,
                    SEVERITY_COLORS.C,
                    SEVERITY_COLORS.D
                ]
            }]
        };
        recoveryTimeChart.options = getChartOptions('bar');
        recoveryTimeChart.update();
    }

    const costImpactChart = state.injury.charts.injuryCostImpactChart;
    if (costImpactChart) {
        const monthlyCost = {};
        state.injury.filteredData.forEach(row => {
            if (row.parsedDate && !isNaN(row.parsedDate)) {
                const monthKey = `${row.parsedDate.getFullYear()}-${String(row.parsedDate.getMonth() + 1).padStart(2, '0')}`;
                const days = parseFloat(row.total_dafw_days) || 0;
                monthlyCost[monthKey] = (monthlyCost[monthKey] || 0) + days * 300;
            }
        });

        const sortedMonths = Object.keys(monthlyCost).sort();
        const monthNames = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];

        costImpactChart.config.type = 'line';
        costImpactChart.data = {
            labels: sortedMonths.map(m => {
                const [year, month] = m.split('-');
                return `${monthNames[parseInt(month) - 1]} ${year}`;
            }),
            datasets: [{
                label: 'Estimated Cost (‚Ç¨)',
                data: sortedMonths.map(m => monthlyCost[m].toFixed(0)),
                borderColor: AMAZON_COLORS.orange,
                backgroundColor: `${AMAZON_COLORS.orange}33`,
                tension: 0.3
            }]
        };
        costImpactChart.options = getChartOptions('line');
        costImpactChart.update();
    }
}

function updateNearMissAdvancedAnalytics() {
    const ratioChart = state.nearMiss.charts.nearMissToInjuryRatioChart;
    if (ratioChart) {
        const monthlyNearMiss = {};
        const monthlyInjury = {};
        const monthKey = date => `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;

        state.nearMiss.filteredData.forEach(row => {
            if (row.parsedDate && !isNaN(row.parsedDate)) {
                const key = monthKey(row.parsedDate);
                monthlyNearMiss[key] = (monthlyNearMiss[key] || 0) + 1;
            }
        });

        state.injury.filteredData.forEach(row => {
            if (row.parsedDate && !isNaN(row.parsedDate)) {
                const key = monthKey(row.parsedDate);
                monthlyInjury[key] = (monthlyInjury[key] || 0) + 1;
            }
        });

        const allMonths = Array.from(new Set([...Object.keys(monthlyNearMiss), ...Object.keys(monthlyInjury)])).sort();
        const monthNames = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];

        ratioChart.config.type = 'line';
        ratioChart.data = {
            labels: allMonths.map(m => {
                const [y, mo] = m.split('-');
                return `${monthNames[parseInt(mo) - 1]} ${y}`;
            }),
            datasets: [{
                label: 'Near Miss/Injury Ratio',
                data: allMonths.map(m => {
                    const nm = monthlyNearMiss[m] || 0;
                    const inj = monthlyInjury[m] || 0;
                    return inj > 0 ? (nm / inj).toFixed(2) : 0;
                }),
                borderColor: AMAZON_COLORS.darkBlue,
                backgroundColor: `${AMAZON_COLORS.darkBlue}33`,
                tension: 0.3
            }]
        };
        ratioChart.options = getChartOptions('line');
        ratioChart.update();
    }

    const predictiveChart = state.nearMiss.charts.nearMissPredictiveRiskChart;
    if (predictiveChart) {
        const mk = d => `${d.getFullYear()}-${String(d.getMonth() + 1).padStart(2, '0')}`;
        const months = state.nearMiss.filteredData
            .filter(r => r.parsedDate && !isNaN(r.parsedDate))
            .map(r => mk(r.parsedDate))
            .sort();
        const latest = months[months.length - 1];
        const prev = months.length > 1 ? months[months.length - 2] : null;
        const locationCounts = {};

        state.nearMiss.filteredData.forEach(row => {
            if (row.parsedDate && !isNaN(row.parsedDate)) {
                const key = mk(row.parsedDate);
                const loc = row.location || 'Unknown';
                if (!locationCounts[loc]) locationCounts[loc] = { current: 0, previous: 0 };
                if (key === latest) locationCounts[loc].current++;
                else if (key === prev) locationCounts[loc].previous++;
            }
        });

        const growth = Object.entries(locationCounts)
            .map(([loc, val]) => ({ loc, increase: val.current - val.previous }))
            .filter(d => d.increase > 0)
            .sort((a, b) => b.increase - a.increase)
            .slice(0, 5);

        predictiveChart.config.type = 'bar';
        predictiveChart.data = {
            labels: growth.map(g => g.loc),
            datasets: [{
                label: 'Increase in Near Misses',
                data: growth.map(g => g.increase),
                backgroundColor: AMAZON_COLORS.orange
            }]
        };
        predictiveChart.options = getChartOptions('bar');
        predictiveChart.update();
    }

    const hotspotChart = state.nearMiss.charts.nearMissHotspotChart;
    if (hotspotChart) {
        const severityMap = { A: 4, B: 3, C: 2, D: 1 };
        const stats = {};
        state.nearMiss.filteredData.forEach(row => {
            const loc = row.location || 'Unknown';
            if (!stats[loc]) stats[loc] = { count: 0, riskTotal: 0, severityTotal: 0 };
            const risk = parseFloat(row.risk || calculateRiskScore(row)) || 0;
            const sev = severityMap[row.severity] || 0;
            stats[loc].count++;
            stats[loc].riskTotal += risk;
            stats[loc].severityTotal += sev;
        });

        const data = Object.entries(stats)
            .map(([loc, s]) => ({
                x: s.riskTotal / s.count,
                y: s.severityTotal / s.count,
                r: Math.sqrt(s.count) * 5,
                label: loc
            }))
            .sort((a, b) => b.r - a.r)
            .slice(0, 10);

        hotspotChart.config.type = 'bubble';
        hotspotChart.data = {
            datasets: [{
                label: 'Locations',
                data: data.map(d => ({ x: d.x, y: d.y, r: d.r, label: d.label })),
                backgroundColor: AMAZON_COLORS.darkBlue
            }]
        };
        hotspotChart.options = getChartOptions('bubble');
        hotspotChart.options.scales = {
            x: { title: { display: true, text: 'Average Risk Score' } },
            y: { title: { display: true, text: 'Average Severity' }, min: 0, max: 4 }
        };
        hotspotChart.options.plugins.tooltip = {
            callbacks: {
                label: ctx => `${ctx.raw.label}: ${Math.round((ctx.raw.r / 5) ** 2)} incidents`
            }
        };
        hotspotChart.update();
    }
}

// Combined Analytics
function updateCombinedAnalytics() {
    // If no data is loaded yet simply return; nothing to update
    if (state.injury.rawData.length === 0 && state.nearMiss.rawData.length === 0) {
        return;
    }

    // Show and populate the combined filter bar the first time data is loaded.
    const combinedFilters = document.getElementById('combinedFilters');
    if (combinedFilters) {
        populateCombinedFilters();
        combinedFilters.style.display = 'flex';
    }
    
    const totalEvents = state.injury.filteredData.length + state.nearMiss.filteredData.length;
    document.getElementById('combinedTotal').textContent = totalEvents;
    
    const highRiskEvents = [
        ...state.injury.filteredData.filter(r => r.severity === 'A' || r.severity === 'B'),
        ...state.nearMiss.filteredData.filter(r => r.severity === 'A' || r.severity === 'B')
    ].length;
    document.getElementById('combinedHighRisk').textContent = highRiskEvents;
    
    const currentMonth = new Date().getMonth();
    const lastMonth = currentMonth - 1;
    const currentMonthEvents = [...state.injury.filteredData, ...state.nearMiss.filteredData]
        .filter(r => r.parsedDate && r.parsedDate.getMonth() === currentMonth).length;
    const lastMonthEvents = [...state.injury.filteredData, ...state.nearMiss.filteredData]
        .filter(r => r.parsedDate && r.parsedDate.getMonth() === lastMonth).length;
    
    const trend = lastMonthEvents > 0 ? 
        ((currentMonthEvents - lastMonthEvents) / lastMonthEvents * 100).toFixed(0) : '0';
    document.getElementById('combinedTrend').textContent = `${trend > 0 ? '+' : ''}${trend}%`;
    
    const siteCounts = {};
    [...state.injury.filteredData, ...state.nearMiss.filteredData].forEach(row => {
        const site = row.site || 'Unknown';
        siteCounts[site] = (siteCounts[site] || 0) + 1;
    });
    const targetSites = Object.values(siteCounts).filter(count => count > 5).length;
    document.getElementById('combinedTargetSites').textContent = targetSites;
    
    updateCombinedRiskMatrix();
    updateCombinedCharts();
    updateCombinedInsights();
}

function updateCombinedRiskMatrix() {
    const allData = [...state.injury.filteredData, ...state.nearMiss.filteredData];
    updateRiskMatrix(allData, 'combinedRiskMatrix');
}

function updateCombinedCharts() {
    const trendChart = Chart.getChart('combinedTrendChart');
    if (trendChart) {
        const monthlyData = {};
        
        [...state.injury.filteredData, ...state.nearMiss.filteredData].forEach(row => {
            if (row.parsedDate && !isNaN(row.parsedDate)) {
                const monthKey = `${row.parsedDate.getFullYear()}-${String(row.parsedDate.getMonth() + 1).padStart(2, '0')}`;
                if (!monthlyData[monthKey]) {
                    monthlyData[monthKey] = { injury: 0, nearMiss: 0, total: 0 };
                }
                monthlyData[monthKey].total++;
                if (row.case_number) {
                    monthlyData[monthKey].injury++;
                } else {
                    monthlyData[monthKey].nearMiss++;
                }
            }
        });
        
        const sortedMonths = Object.keys(monthlyData).sort();
        const monthNames = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
        
        trendChart.data = {
            labels: sortedMonths.map(m => {
                const [year, month] = m.split('-');
                return `${monthNames[parseInt(month)-1]} ${year}`;
            }),
            datasets: [
                {
                    label: 'Total Events',
                    data: sortedMonths.map(m => monthlyData[m].total),
                    borderColor: AMAZON_COLORS.orange,
                    backgroundColor: `${AMAZON_COLORS.orange}20`,
                    tension: 0.3
                },
                {
                    label: 'Injuries',
                    data: sortedMonths.map(m => monthlyData[m].injury),
                    borderColor: SEVERITY_COLORS.B,
                    backgroundColor: `${SEVERITY_COLORS.B}20`,
                    tension: 0.3
                },
                {
                    label: 'Near Misses',
                    data: sortedMonths.map(m => monthlyData[m].nearMiss),
                    borderColor: AMAZON_COLORS.darkBlue,
                    backgroundColor: `${AMAZON_COLORS.darkBlue}20`,
                    tension: 0.3
                }
            ]
        };
        trendChart.update();
    }
    
    const siteChart = Chart.getChart('combinedSiteChart');
    if (siteChart) {
        const siteData = {};
        
        state.injury.filteredData.forEach(row => {
            const site = row.site || 'Unknown';
            if (!siteData[site]) {
                siteData[site] = { injury: 0, nearMiss: 0, highSeverity: 0 };
            }
            siteData[site].injury++;
            if (row.severity === 'A' || row.severity === 'B') {
                siteData[site].highSeverity++;
            }
        });
        
        state.nearMiss.filteredData.forEach(row => {
            const site = row.site || 'Unknown';
            if (!siteData[site]) {
                siteData[site] = { injury: 0, nearMiss: 0, highSeverity: 0 };
            }
            siteData[site].nearMiss++;
            if (row.severity === 'A' || row.severity === 'B') {
                siteData[site].highSeverity++;
            }
        });
        
        const sites = Object.entries(siteData)
            .sort((a, b) => (b[1].injury + b[1].nearMiss) - (a[1].injury + a[1].nearMiss))
            .slice(0, 10);
        
        siteChart.config.type = 'bar';
        siteChart.data = {
            labels: sites.map(([site]) => site),
            datasets: [
                {
                    label: 'Injuries',
                    data: sites.map(([, data]) => data.injury),
                    backgroundColor: SEVERITY_COLORS.B
                },
                {
                    label: 'Near Misses',
                    data: sites.map(([, data]) => data.nearMiss),
                    backgroundColor: AMAZON_COLORS.orange
                },
                {
                    label: 'High Severity',
                    data: sites.map(([, data]) => data.highSeverity),
                    backgroundColor: SEVERITY_COLORS.A
                }
            ]
        };
        siteChart.options = getChartOptions('bar');
        siteChart.update();
    }
    
    const severityChart = Chart.getChart('combinedSeverityChart');
    if (severityChart) {
        const severityData = {
            injury: { A: 0, B: 0, C: 0, D: 0 },
            nearMiss: { A: 0, B: 0, C: 0, D: 0 }
        };
        
        state.injury.filteredData.forEach(row => {
            if (row.severity && severityData.injury[row.severity] !== undefined) {
                severityData.injury[row.severity]++;
            }
        });
        
        state.nearMiss.filteredData.forEach(row => {
            if (row.severity && severityData.nearMiss[row.severity] !== undefined) {
                severityData.nearMiss[row.severity]++;
            }
        });
        
        severityChart.config.type = 'bar';
        severityChart.data = {
            labels: ['Severity A', 'Severity B', 'Severity C', 'Severity D'],
            datasets: [
                {
                    label: 'Injuries',
                    data: ['A', 'B', 'C', 'D'].map(s => severityData.injury[s]),
                    backgroundColor: SEVERITY_COLORS.B
                },
                {
                    label: 'Near Misses',
                    data: ['A', 'B', 'C', 'D'].map(s => severityData.nearMiss[s]),
                    backgroundColor: AMAZON_COLORS.orange
                }
            ]
        };
        severityChart.options = getChartOptions('bar');
        severityChart.update();
    }
    
    const preventionChart = Chart.getChart('combinedPreventionChart');
    if (preventionChart) {
        const monthlyPrevention = {};
        
        [...state.injury.filteredData, ...state.nearMiss.filteredData].forEach(row => {
            if (row.parsedDate && !isNaN(row.parsedDate)) {
                const monthKey = `${row.parsedDate.getFullYear()}-${String(row.parsedDate.getMonth() + 1).padStart(2, '0')}`;
                if (!monthlyPrevention[monthKey]) {
                    monthlyPrevention[monthKey] = { injury: 0, nearMiss: 0 };
                }
                if (row.case_number) {
                    monthlyPrevention[monthKey].injury++;
                } else {
                    monthlyPrevention[monthKey].nearMiss++;
                }
            }
        });
        
        const sortedMonths = Object.keys(monthlyPrevention).sort();
        const monthNames = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
        
        preventionChart.config.type = 'line';
        preventionChart.data = {
            labels: sortedMonths.map(m => {
                const [year, month] = m.split('-');
                return `${monthNames[parseInt(month)-1]} ${year}`;
            }),
            datasets: [{
                label: 'Prevention Ratio (Near Miss / Injury)',
                data: sortedMonths.map(m => {
                    const data = monthlyPrevention[m];
                    return data.injury > 0 ? (data.nearMiss / data.injury).toFixed(1) : data.nearMiss;
                }),
                borderColor: AMAZON_COLORS.orange,
                backgroundColor: `${AMAZON_COLORS.orange}20`,
                tension: 0.3
            }]
        };
        preventionChart.options = getChartOptions('line');
        preventionChart.update();
    }
}

function updateCombinedInsights() {
    const insightsContainer = document.getElementById('combinedInsights');
    
    const insights = [];
    
    const injuryCount = state.injury.filteredData.length;
    const nearMissCount = state.nearMiss.filteredData.length;
    const ratio = injuryCount > 0 ? (nearMissCount / injuryCount).toFixed(1) : nearMissCount;
    
    insights.push({
        type: ratio > 10 ? 'positive' : ratio > 5 ? 'neutral' : 'negative',
        title: 'Near Miss to Injury Ratio',
        content: `Current ratio is ${ratio}:1. ${ratio > 10 ? 'Excellent' : ratio > 5 ? 'Good' : 'Needs improvement'} - higher ratios indicate better hazard identification before injuries occur.`
    });
    
    const commonBodyParts = {};
    const commonLocations = {};
    
    state.injury.filteredData.forEach(row => {
        if (row.bodyPart) commonBodyParts[row.bodyPart] = (commonBodyParts[row.bodyPart] || 0) + 1;
    });
    
    state.nearMiss.filteredData.forEach(row => {
        if (row.location) commonLocations[row.location] = (commonLocations[row.location] || 0) + 1;
    });
    
    const topBodyPart = Object.entries(commonBodyParts).sort((a, b) => b[1] - a[1])[0];
    const topLocation = Object.entries(commonLocations).sort((a, b) => b[1] - a[1])[0];
    
    if (topBodyPart) {
        insights.push({
            type: 'warning',
            title: 'Most Affected Body Part',
            content: `"${topBodyPart[0]}" accounts for ${topBodyPart[1]} injuries. Consider targeted ergonomic improvements or PPE enhancements.`
        });
    }
    
    if (topLocation) {
        insights.push({
            type: 'warning',
            title: 'High-Risk Location',
            content: `"${topLocation[0]}" has ${topLocation[1]} near miss reports. This location requires immediate safety assessment.`
        });
    }
    
    const highSeverityInjuries = state.injury.filteredData.filter(r => r.severity === 'A' || r.severity === 'B').length;
    const highSeverityNearMisses = state.nearMiss.filteredData.filter(r => r.severity === 'A' || r.severity === 'B').length;
    
    if (highSeverityNearMisses > highSeverityInjuries * 2) {
        insights.push({
            type: 'critical',
            title: 'High Severity Risk',
            content: `${highSeverityNearMisses} high-severity near misses detected. This indicates potential for serious injuries if not addressed immediately.`
        });
    }
    
    insightsContainer.innerHTML = insights.map(insight => `
        <div style="padding: 1rem; margin-bottom: 1rem; background: ${
            insight.type === 'positive' ? 'rgba(76, 175, 80, 0.1)' :
            insight.type === 'warning' ? 'rgba(255, 193, 7, 0.1)' :
            insight.type === 'critical' ? 'rgba(255, 87, 34, 0.1)' :
            'rgba(33, 150, 243, 0.1)'
        }; border-radius: 8px; border-left: 4px solid ${
            insight.type === 'positive' ? '#4CAF50' :
            insight.type === 'warning' ? '#FFC107' :
            insight.type === 'critical' ? '#FF5722' :
            '#2196F3'
        };">
            <h4 style="margin-bottom: 0.5rem;">${insight.title}</h4>
            <p style="margin: 0;">${insight.content}</p>
        </div>
    `).join('');
}

// Action Items
function updateActionItems() {
    const allData = [...state.injury.filteredData, ...state.nearMiss.filteredData];
    
    if (allData.length === 0) return;
    
    const actions = generateActionItems(allData);
    
    const immediateContainer = document.getElementById('immediateActions');
    immediateContainer.innerHTML = actions.immediate.map(action => `
        <li class="action-item">
            <span class="action-icon immediate">!</span>
            <div style="flex: 1;">
                <strong>${action.title}</strong>
                <p style="font-size: 0.9rem; color: var(--text-secondary); margin-top: 0.25rem;">
                    ${action.description}
                </p>
            </div>
            <button class="btn btn-sm btn-outline" onclick="markActionComplete('immediate', '${action.id}')">
                Mark Complete
            </button>
        </li>
    `).join('');
    
    const shortTermContainer = document.getElementById('shortTermActions');
    shortTermContainer.innerHTML = actions.shortTerm.map(action => `
        <li class="action-item">
            <span class="action-icon short-term">üìÖ</span>
            <div style="flex: 1;">
                <strong>${action.title}</strong>
                <p style="font-size: 0.9rem; color: var(--text-secondary); margin-top: 0.25rem;">
                    ${action.description}
                </p>
            </div>
            <button class="btn btn-sm btn-outline" onclick="markActionComplete('shortTerm', '${action.id}')">
                Mark Complete
            </button>
        </li>
    `).join('');
    
    const longTermContainer = document.getElementById('longTermActions');
    longTermContainer.innerHTML = actions.longTerm.map(action => `
        <li class="action-item">
            <span class="action-icon long-term">üîÑ</span>
            <div style="flex: 1;">
                <strong>${action.title}</strong>
                <p style="font-size: 0.9rem; color: var(--text-secondary); margin-top: 0.25rem;">
                    ${action.description}
                </p>
            </div>
            <button class="btn btn-sm btn-outline" onclick="markActionComplete('longTerm', '${action.id}')">
                Mark Complete
            </button>
        </li>
    `).join('');
}

function generateActionItems(data) {
    const actions = {
        immediate: [],
        shortTerm: [],
        longTerm: []
    };
    
    const highSeverityCount = data.filter(r => r.severity === 'A' || r.severity === 'B').length;
    const recordableCount = state.injury.filteredData.filter(r => r.recordable === 1).length;
    const otrCount = state.injury.filteredData.filter(r => r.otr === 'yes').length;
    
    if (highSeverityCount > 5) {
        actions.immediate.push({
            id: 'imm-1',
            title: `Address ${highSeverityCount} high-severity incidents`,
            description: 'Conduct immediate safety stand-down and review all A & B severity cases'
        });
    }
    
    if (recordableCount > 3) {
        actions.immediate.push({
            id: 'imm-2',
            title: `Review ${recordableCount} recordable cases`,
            description: 'Ensure all OSHA reporting requirements are met and root causes are identified'
        });
    }
    
    if (otrCount > 2) {
        actions.immediate.push({
            id: 'imm-3',
            title: `Investigate ${otrCount} OTR incidents`,
            description: 'Review driver safety protocols and implement immediate corrective actions'
        });
    }
    
    const locationCounts = {};
    data.forEach(row => {
        const location = row.location || row.initial_info_location_event || 'Unknown';
        locationCounts[location] = (locationCounts[location] || 0) + 1;
    });
    
    Object.entries(locationCounts)
        .sort((a, b) => b[1] - a[1])
        .slice(0, 3)
        .forEach(([location, count], index) => {
            if (count > 5) {
                actions.shortTerm.push({
                    id: `st-${index + 1}`,
                    title: `Safety audit at ${location}`,
                    description: `${count} incidents reported. Conduct comprehensive safety assessment within 30 days`
                });
            }
        });
    
    const processCounts = {};
    data.forEach(row => {
        const process = row.processPath || row.initial_info_process_path || 'Unknown';
        processCounts[process] = (processCounts[process] || 0) + 1;
    });
    
    Object.entries(processCounts)
        .sort((a, b) => b[1] - a[1])
        .slice(0, 2)
        .forEach(([process, count], index) => {
            if (count > 3) {
                actions.shortTerm.push({
                    id: `st-p-${index + 1}`,
                    title: `Review ${process} process`,
                    description: `${count} incidents in this process. Update SOPs and conduct training`
                });
            }
        });
    
    actions.longTerm.push({
        id: 'lt-1',
        title: 'Implement predictive analytics',
        description: 'Develop machine learning models to predict high-risk situations based on historical data'
    });
    
    actions.longTerm.push({
        id: 'lt-2',
        title: 'Enhanced safety culture program',
        description: 'Launch comprehensive behavioral safety program focusing on near miss reporting'
    });
    
    if (data.length > 50) {
        actions.longTerm.push({
            id: 'lt-3',
            title: 'Quarterly trend analysis',
            description: 'Establish regular review cycles for safety metrics and leading indicators'
        });
    }
    
    return actions;
}

function markActionComplete(type, actionId) {
    showStatus(`Action ${actionId} marked as complete`, 'success');
    event.target.closest('.action-item').style.opacity = '0.5';
    event.target.disabled = true;
    event.target.textContent = 'Completed';
}

function addNewAction() {
    showStatus('Action creation form would open here', 'info');
}

// View Details
function viewDetails(type, id) {
    let data;
    if (type === 'injury') {
        data = state.injury.filteredData.find(r => r.case_number === id);
    } else if (type === 'nearmiss') {
        data = state.nearMiss.filteredData.find(r => r.incident_id === id);
    } else {
        data = state.inspections.filteredData.find(r => r.id === id);
    }

    if (!data) return;

    const modal = document.getElementById('detailModal');
    const title = document.getElementById('modalTitle');
    const body = document.getElementById('modalBody');

    if (type === 'injury') {
        title.textContent = 'Injury & Illness Details';
    } else if (type === 'nearmiss') {
        title.textContent = 'Near Miss Details';
    } else {
        title.textContent = 'Inspection Details';
    }

    if (type === 'injury') {
        const austinUrl = data.austin_url && data.austin_url !== '#' ? data.austin_url : null;
        
        body.innerHTML = `
            <div style="display: grid; gap: 1rem;">
                <div><strong>Case Number:</strong> ${data.case_number}</div>
                <div><strong>Date:</strong> ${data.incident_date || 'N/A'}</div>
                <div><strong>Time:</strong> ${data.incident_time || 'N/A'}</div>
                <div><strong>Site:</strong> ${data.site || 'N/A'}</div>
                <div><strong>Body Part:</strong> ${data.bodyPart || 'N/A'}</div>
                <div><strong>Type:</strong> ${data.type || 'N/A'}</div>
                <div><strong>Severity:</strong> <span class="badge badge-${getSeverityClass(data.severity)}">${data.severity}</span></div>
                <div><strong>Recordable:</strong> <span class="badge badge-${data.recordable === 1 ? 'danger' : 'success'}">${data.recordable === 1 ? 'Yes' : 'No'}</span></div>
                <div><strong>OTR:</strong> <span class="badge badge-${data.otr === 'yes' ? 'warning' : 'info'}">${data.otr === 'yes' ? 'Yes' : 'No'}</span></div>
                <div><strong>DAFW Days:</strong> ${data.total_dafw_days || 0}</div>
                <div><strong>RWA Days:</strong> ${data.total_rwa_days || 0}</div>
                <div><strong>Root Cause:</strong> ${data.rootCause || 'Under Investigation'}</div>
                <div><strong>Contributing Factors:</strong> ${data.contributingFactor || 'N/A'}</div>
                <div><strong>Process Path:</strong> ${data.processPath || 'N/A'}</div>
                <div><strong>Description:</strong> ${data.initial_info_incident_description || 'No description available'}</div>
                <div><strong>Status:</strong> ${data.status || 'N/A'}</div>
                ${austinUrl ? `
                <div style="margin-top: 1rem;">
                    <a href="${austinUrl}" target="_blank" class="btn btn-primary">
                        <span>üìö</span> Austin Link
                    </a>
                </div>` : ''}
            </div>
        `;
    } else if (type === 'nearmiss') {
        const austinUrl = data.austin_url && data.austin_url !== '#' ? data.austin_url : null;

        body.innerHTML = `
            <div style="display: grid; gap: 1rem;">
                <div><strong>ID:</strong> ${data.incident_id}</div>
                <div><strong>Date:</strong> ${data.nearmiss_date || 'N/A'}</div>
                <div><strong>Site:</strong> ${data.site || 'N/A'}</div>
                <div><strong>Location:</strong> ${data.location || 'N/A'}</div>
                <div><strong>Process Path:</strong> ${data.processPath || 'N/A'}</div>
                <div><strong>Primary Impact:</strong> ${data.primaryImpact || 'N/A'}</div>
                <div><strong>Potential Severity:</strong> <span class="badge badge-${getSeverityClass(data.severity)}">${data.severity}</span></div>
                <div><strong>Likelihood:</strong> <span class="badge badge-info">${data.standardized_likelihood || 'N/A'}</span></div>
                <div><strong>Risk Score:</strong> <span class="badge badge-${getRiskClass(data.risk)}">${data.risk || 'N/A'}</span></div>
                <div><strong>Contributing Factors:</strong> ${data.contributingFactor || 'N/A'}</div>
                <div><strong>Description:</strong> ${data.initial_info_incident_description || 'No description available'}</div>
                <div><strong>Root Cause:</strong> ${data.rca_primary_cause || 'Under investigation'}</div>
                <div><strong>Status:</strong> ${data.status || 'N/A'}</div>
                ${austinUrl ? `
                <div style="margin-top: 1rem;">
                    <a href="${austinUrl}" target="_blank" class="btn btn-primary">
                        <span>üìö</span> Austin Link
                    </a>
                </div>` : ''}
            </div>
        `;
    } else {
        const dueDateText = (data.dueDate instanceof Date && !isNaN(data.dueDate)) ? data.dueDate.toLocaleDateString() : (data.dueDateRaw || 'N/A');
        const original = data.sourceRow || {};
        body.innerHTML = `
            <div style="display: grid; gap: 1rem;">
                <div><strong>Inspection ID:</strong> ${data.id}</div>
                <div><strong>Site:</strong> ${data.site || 'Unknown'}</div>
                <div><strong>Inspection:</strong> ${data.inspection || 'N/A'}</div>
                <div><strong>Type:</strong> ${data.type || 'N/A'}</div>
                <div><strong>Due Date:</strong> ${dueDateText}</div>
                <div><strong>Status:</strong> ${data.status}</div>
                <div><strong>Days Until Due:</strong> ${formatDaysUntilDue(data.daysUntilDue)}</div>
                <div><strong>Owner:</strong> ${data.owner || 'TBD'}</div>
                <div><strong>Completion Flag:</strong> ${data.complete === 1 ? 'Completed' : 'Open'}</div>
                <div><strong>Original Record:</strong><pre style="background:#f4f4f4; padding:10px; border-radius:4px; white-space:pre-wrap;">${JSON.stringify(original, null, 2)}</pre></div>
            </div>
        `;
    }

    modal.style.display = 'block';
}

function closeModal() {
    document.getElementById('detailModal').style.display = 'none';
}

function openHelpModal() {
    document.getElementById('helpModal').style.display = 'block';
    switchHelpSection('welcome');
}

function closeHelpModal() {
    document.getElementById('helpModal').style.display = 'none';
}

function switchHelpSection(section) {
    document.querySelectorAll('.help-tab').forEach(tab => {
        tab.classList.toggle('active', tab.dataset.section === section);
    });
    document.querySelectorAll('.help-section').forEach(sec => {
        sec.classList.toggle('active', sec.id === section);
    });
}

function tryNow(module, targetId) {
    closeHelpModal();
    switchModule(module);
    if (targetId) {
        const el = document.getElementById(targetId);
        if (el) {
            el.scrollIntoView({ behavior: 'smooth' });
        }
    }
}

// Export Functions
function exportInjuryData() {
    exportToExcel('injury');
}

function exportNearMissData() {
    exportToExcel('nearmiss');
}

function exportToExcel(type = 'all') {
    try {
        const wb = XLSX.utils.book_new();

        if (type === 'injury' || type === 'all') {
            if (state.injury.filteredData.length > 0) {
                const ws1 = XLSX.utils.json_to_sheet(state.injury.filteredData);
                XLSX.utils.book_append_sheet(wb, ws1, "Injury Data");

                const injurySummary = createInjurySummarySheet();
                const ws1Summary = XLSX.utils.aoa_to_sheet(injurySummary);
                XLSX.utils.book_append_sheet(wb, ws1Summary, "Injury Summary");
            }
        }

        if (type === 'nearmiss' || type === 'all') {
            if (state.nearMiss.filteredData.length > 0) {
                const ws2 = XLSX.utils.json_to_sheet(state.nearMiss.filteredData);
                XLSX.utils.book_append_sheet(wb, ws2, "Near Miss Data");

                const nearMissSummary = createNearMissSummarySheet();
                const ws2Summary = XLSX.utils.aoa_to_sheet(nearMissSummary);
                XLSX.utils.book_append_sheet(wb, ws2Summary, "Near Miss Summary");
            }
        }

        if (type === 'inspections' || type === 'all') {
            if (state.inspections.filteredData.length > 0) {
                const formatted = state.inspections.filteredData.map(item => ({
                    ID: item.id,
                    Site: item.site,
                    Inspection: item.inspection,
                    Type: item.type,
                    DueDate: (item.dueDate instanceof Date && !isNaN(item.dueDate)) ? item.dueDate.toISOString().split('T')[0] : (item.dueDateRaw || ''),
                    Status: item.status,
                    Owner: item.owner,
                    Complete: item.complete
                }));
                const ws3 = XLSX.utils.json_to_sheet(formatted);
                XLSX.utils.book_append_sheet(wb, ws3, "Inspections");
            }

            const wbrSummary = generateWBRSummaryData();
            if (wbrSummary.length) {
                const wsSummary = XLSX.utils.json_to_sheet(wbrSummary);
                const sheetName = type === 'inspections' ? 'WBR Summary' : 'WBR Summary';
                XLSX.utils.book_append_sheet(wb, wsSummary, sheetName);
            }
        }

        const noInjuryData = state.injury.filteredData.length === 0;
        const noNearMissData = state.nearMiss.filteredData.length === 0;
        const noInspectionData = state.inspections.filteredData.length === 0;

        if ((type === 'injury' && noInjuryData) ||
            (type === 'nearmiss' && noNearMissData) ||
            (type === 'inspections' && noInspectionData) ||
            (type === 'all' && noInjuryData && noNearMissData && noInspectionData)) {
            showStatus('No data to export', 'error');
            return;
        }

        const filename = type === 'all' ?
            `safety_analysis_complete_${new Date().toISOString().split('T')[0]}.xlsx` :
            `${type}_analysis_${new Date().toISOString().split('T')[0]}.xlsx`;

        XLSX.writeFile(wb, filename);
        showStatus('Data exported successfully!', 'success');
    } catch (error) {
        console.error('Export error:', error);
        showStatus('Error exporting data: ' + error.message, 'error');
    }
}

function createInjurySummarySheet() {
    const data = state.injury.filteredData;
    const recordableCount = data.filter(r => r.recordable === 1).length;
    const lostTimeCount = data.filter(r => r.total_dafw_days > 0).length;
    const totalDaysLost = data.reduce((sum, r) => sum + (r.total_dafw_days || 0), 0);
    const otrCount = data.filter(r => r.otr === 'yes').length;
    
    return [
        ['Injury & Illness Analysis Summary'],
        ['Generated on:', new Date().toLocaleString()],
        ['Report by:', 'Erwin Esener @eeesener - Amazon WHS Austria'],
        [''],
        ['Key Metrics:'],
        ['Total Incidents:', data.length],
        ['Recordable Cases:', recordableCount],
        ['Lost Time Cases:', lostTimeCount],
        ['Total Days Lost (DAFW):', totalDaysLost],
        ['OTR Incidents:', otrCount],
        [''],
        ['Severity Distribution:'],
        ['A - Critical:', data.filter(r => r.severity === 'A').length],
        ['B - High:', data.filter(r => r.severity === 'B').length],
        ['C - Medium:', data.filter(r => r.severity === 'C').length],
        ['D - Low:', data.filter(r => r.severity === 'D').length],
        [''],
        ['Top Body Parts Affected:'],
        ...getTopItems(data, 'bodyPart', 5).map(([part, count]) => [part, count]),
        [''],
        ['Top Root Causes:'],
        ...getTopItems(data, 'rootCause', 5).map(([cause, count]) => [cause, count]),
        [''],
        ['Data Quality Score:', state.injury.qualityMetrics?.qualityScore || 'N/A']
    ];
}

function createNearMissSummarySheet() {
    const data = state.nearMiss.filteredData;
    const highSeverityCount = data.filter(r => r.severity === 'A' || r.severity === 'B').length;
    const avgRisk = data.length > 0 ? 
        (data.reduce((sum, r) => sum + parseFloat(r.risk || 0), 0) / data.length).toFixed(1) : 0;
    
    return [
        ['Near Miss Analysis Summary'],
        ['Generated on:', new Date().toLocaleString()],
        ['Report by:', 'Erwin Esener @eeesener - Amazon WHS Austria'],
        [''],
        ['Key Metrics:'],
        ['Total Near Misses:', data.length],
        ['High Severity Cases (A & B):', highSeverityCount],
        ['Average Risk Score:', avgRisk],
        [''],
        ['Severity Distribution:'],
        ['A - Critical:', data.filter(r => r.severity === 'A').length],
        ['B - High:', data.filter(r => r.severity === 'B').length],
        ['C - Medium:', data.filter(r => r.severity === 'C').length],
        ['D - Low:', data.filter(r => r.severity === 'D').length],
        [''],
        ['Top Locations:'],
        ...getTopItems(data, 'location', 5).map(([location, count]) => [location, count]),
        [''],
        ['Top Process Paths:'],
        ...getTopItems(data, 'processPath', 5).map(([process, count]) => [process, count]),
        [''],
        ['Data Quality Score:', state.nearMiss.qualityMetrics?.qualityScore || 'N/A']
    ];
}

function getTopItems(data, field, limit = 5) {
    const counts = {};
    data.forEach(row => {
        const value = row[field] || 'Unknown';
        counts[value] = (counts[value] || 0) + 1;
    });
    
    return Object.entries(counts)
        .sort((a, b) => b[1] - a[1])
        .slice(0, limit);
}

// Export Table
function exportTable(type) {
    const tableId = type === 'injury' ? 'injuryTable' : 'nearMissTable';
    const table = document.getElementById(tableId);
    
    if (!table) {
        showStatus('Table not found', 'error');
        return;
    }
    
    try {
        const wb = XLSX.utils.table_to_book(table);
        XLSX.writeFile(wb, `${type}_table_export_${new Date().toISOString().split('T')[0]}.xlsx`);
        showStatus('Table exported successfully!', 'success');
    } catch (error) {
        console.error('Table export error:', error);
        showStatus('Error exporting table: ' + error.message, 'error');
    }
}

// Export Near Miss Duplicate Details as PDF
function exportNearMissDuplicatesPDF() {
    const metrics = state.nearMiss.qualityMetrics;
    if (!metrics || !metrics.duplicateDetails.length) {
        showStatus('No duplicate records to export', 'warning');
        return;
    }

    const { jsPDF } = window.jspdf;
    const doc = new jsPDF({ unit: 'pt', compress: true });
    doc.setFont('helvetica', 'normal');

    const margin = 40;
    let yPos = margin;
    const tableWidth = doc.internal.pageSize.getWidth() - margin * 2;

    doc.setFontSize(16);
    doc.setTextColor(...hexToRgb(AMAZON_COLORS.darkBlue));
    doc.text('Near Miss Duplicate Report', margin, yPos);
    yPos += 20;

    metrics.duplicateDetails.forEach((group, index) => {
        if (yPos > doc.internal.pageSize.getHeight() - 80) {
            doc.addPage();
            yPos = margin;
        }

        doc.setFontSize(12);
        doc.setFont('helvetica', 'bold');
        doc.text(`Group ${index + 1} - ${group.data.site} (${group.data.date || 'N/A'})`, margin, yPos);
        yPos += 10;

        const records = group.indices.map(i => state.nearMiss.filteredData[i]);
        const baseDesc = records[0].initial_info_incident_description || '';

        doc.autoTable({
            startY: yPos,
            head: [['Description', 'Creator', 'Austin Link', 'Similarity %']],
            body: records.map((rec, i) => {
                const desc = (rec.initial_info_incident_description || '').substring(0, 100);
                const creator = rec.created_by || rec.creator || rec.reportedBy || rec.initial_info_reporter || 'Unknown';
                const austin = rec.austin_url && rec.austin_url !== '#' ? rec.austin_url : 'N/A';
                const similarity = i === 0 ? 'Base' :
                    (calculateTextSimilarity(baseDesc, rec.initial_info_incident_description || '') * 100).toFixed(1) + '%';
                return [desc, creator, austin, similarity];
            }),
            theme: 'grid',
            headStyles: { fillColor: hexToRgb(AMAZON_COLORS.darkBlue) },
            styles: { fontSize: 8, overflow: 'linebreak' },
            columnStyles: {
                0: { cellWidth: tableWidth * 0.5 },
                1: { cellWidth: tableWidth * 0.15 },
                2: { cellWidth: tableWidth * 0.25 },
                3: { cellWidth: tableWidth * 0.1, halign: 'right' }
            },
            margin: { left: margin, right: margin }
        });

        yPos = doc.lastAutoTable.finalY + 20;
    });

    doc.save('near_miss_duplicates.pdf');
    showStatus('Duplicate report exported!', 'success');
}

// Capture individual charts
function captureChart(chartId) {
    const canvas = document.getElementById(chartId);
    if (!canvas) {
        console.error('Chart not found:', chartId);
        return;
    }

    const tempCanvas = document.createElement('canvas');
    const tempCtx = tempCanvas.getContext('2d');
    tempCanvas.width = canvas.width;
    tempCanvas.height = canvas.height;

    tempCtx.fillStyle = 'white';
    tempCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);
    tempCtx.drawImage(canvas, 0, 0);

    tempCanvas.toBlob((blob) => {
        if (!blob) {
            showStatus('Unable to capture chart image.', 'error');
            return;
        }

        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `chart_${chartId}_${new Date().toISOString().slice(0, 10)}.png`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);

        showStatus('Chart saved successfully!', 'success');
    }, 'image/png');
}

function captureChartWithTitle(chartId, title) {
    const canvas = document.getElementById(chartId);
    if (!canvas) {
        console.error('Chart not found:', chartId);
        return;
    }

    const padding = 40;
    const tempCanvas = document.createElement('canvas');
    const tempCtx = tempCanvas.getContext('2d');
    tempCanvas.width = canvas.width;
    tempCanvas.height = canvas.height + padding;

    tempCtx.fillStyle = 'white';
    tempCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);

    tempCtx.fillStyle = '#232F3E';
    tempCtx.font = 'bold 16px Inter, sans-serif';
    tempCtx.textAlign = 'center';
    tempCtx.fillText(title || 'Safety Analytics Chart', tempCanvas.width / 2, 25);

    tempCtx.drawImage(canvas, 0, padding);

    tempCanvas.toBlob((blob) => {
        if (!blob) {
            showStatus('Unable to capture chart image.', 'error');
            return;
        }

        const slug = slugifyLabel(title || 'chart') || 'chart';
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `${slug}_${new Date().toISOString().slice(0, 10)}.png`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);

        showStatus(`${title || 'Chart'} saved successfully!`, 'success');
    }, 'image/png');
}

function deriveChartTitle(container, canvas, fallbackTitle) {
    let title = fallbackTitle || '';

    if (!title) {
        const chartCard = container?.closest('.chart-card');
        const cardTitle = chartCard?.querySelector('.chart-title');
        if (cardTitle?.textContent) {
            title = cardTitle.textContent.trim();
        }
    }

    const chartCard = container?.closest('.chart-card');
    const select = chartCard?.querySelector('select');
    if (select) {
        const selectedOption = select.options[select.selectedIndex];
        if (selectedOption?.textContent) {
            const optionText = selectedOption.textContent.trim();
            if (title && !title.includes(optionText)) {
                title = `${title} - ${optionText}`;
            } else if (!title) {
                title = optionText;
            }
        }
    }

    if (!title && canvas?.id) {
        title = canvas.id;
    }

    return title || 'Safety Analytics Chart';
}

function addCaptureButton(chartContainer) {
    if (!chartContainer) {
        return;
    }

    const canvas = chartContainer.querySelector('canvas');
    if (!canvas || chartContainer.querySelector('.capture-btn')) {
        return;
    }

    if (!chartContainer.style.position || chartContainer.style.position === 'static') {
        chartContainer.style.position = 'relative';
    }

    const baseTitle = chartContainer.dataset.captureTitle
        || canvas.dataset.captureTitle
        || chartContainer.closest('.chart-card')?.querySelector('.chart-title')?.textContent?.trim()
        || canvas.id;

    const button = document.createElement('button');
    button.type = 'button';
    button.className = 'capture-btn';
    button.innerHTML = 'üì∑';
    button.title = 'Save as PNG';
    button.setAttribute('aria-label', 'Save chart as PNG');
    button.dataset.captureBaseTitle = baseTitle || '';

    button.addEventListener('click', () => {
        const title = deriveChartTitle(chartContainer, canvas, button.dataset.captureBaseTitle);
        captureChartWithTitle(canvas.id, title);
    });

    chartContainer.appendChild(button);
}

function initializeChartCaptureButtons() {
    const containers = document.querySelectorAll('.chart-container');
    containers.forEach(container => addCaptureButton(container));
}

function deriveViewLabel(id) {
    if (!id) return 'analysis-view';
    return id
        .replace(/([a-z])([A-Z])/g, '$1 $2')
        .replace(/_/g, ' ')
        .replace(/\s+/g, ' ')
        .trim();
}

function slugifyLabel(label) {
    if (!label) return 'analysis-view';
    return label
        .toLowerCase()
        .replace(/[^a-z0-9]+/g, '-')
        .replace(/^-+|-+$/g, '')
        .trim() || 'analysis-view';
}

function formatCaptureFileName(slug) {
    const datePart = new Date().toISOString().split('T')[0];
    return `${slug}_${datePart}.png`;
}

async function captureHTMLElement(element, filename) {
    if (!element) {
        throw new Error('Element not found');
    }

    document.body.classList.add('capturing');

    try {
        await new Promise(resolve => requestAnimationFrame(() => requestAnimationFrame(resolve)));
        const canvas = await html2canvas(element, {
            scale: 2,
            useCORS: true,
            logging: false,
            backgroundColor: state.theme === 'dark' ? '#1a1a1a' : '#ffffff'
        });

        const link = document.createElement('a');
        link.download = filename;
        link.href = canvas.toDataURL('image/png');
        link.click();
        return canvas;
    } finally {
        document.body.classList.remove('capturing');
    }
}

async function captureAnalysisView(viewId, customLabel, triggerButton) {
    const element = document.getElementById(viewId);
    if (!element) {
        showStatus('Analysis view not found', 'error');
        return;
    }

    const viewLabel = customLabel || deriveViewLabel(viewId);
    const fileSlug = slugifyLabel(viewLabel || viewId);
    const filename = formatCaptureFileName(fileSlug);

    showStatus(`Capturing ${viewLabel}...`, 'info');

    if (triggerButton) {
        triggerButton.classList.add('capturing');
    }

    try {
        await captureHTMLElement(element, filename);
        showStatus(`${viewLabel} captured successfully!`, 'success');
    } catch (error) {
        console.error('View capture error:', error);
        showStatus(`Error capturing ${viewLabel}: ${error.message}`, 'error');
    } finally {
        if (triggerButton) {
            triggerButton.classList.remove('capturing');
        }
    }
}

// Export Dashboard
async function exportDashboard() {
    showStatus('Capturing analysis views...', 'info');

    const modulesToCapture = [
        { moduleId: 'injury', selector: '.injury-view:not(.hidden)', fallbackId: 'injuryDashboard' },
        { moduleId: 'nearmiss', selector: '.nearmiss-view:not(.hidden)', fallbackId: 'nearMissDashboard' }
    ];

    let capturedAny = false;

    for (const config of modulesToCapture) {
        const moduleEl = document.getElementById(config.moduleId);
        if (!moduleEl) {
            continue;
        }

        const wasActive = moduleEl.classList.contains('active');
        if (!wasActive) {
            moduleEl.classList.add('active');
        }

        await new Promise(resolve => requestAnimationFrame(() => requestAnimationFrame(resolve)));

        let viewElement = moduleEl.querySelector(config.selector);
        if (!viewElement && config.fallbackId) {
            viewElement = document.getElementById(config.fallbackId);
        }

        if (viewElement) {
            const label = deriveViewLabel(viewElement.id);
            const fileSlug = slugifyLabel(label);
            const filename = formatCaptureFileName(fileSlug);
            try {
                await captureHTMLElement(viewElement, filename);
                capturedAny = true;
            } catch (error) {
                console.error('Dashboard export error:', error);
                showStatus(`Error capturing ${label}: ${error.message}`, 'error');
            }
        }

        if (!wasActive) {
            moduleEl.classList.remove('active');
        }
    }

    if (capturedAny) {
        showStatus('Analysis views exported as images!', 'success');
    } else {
        showStatus('No analysis views available to capture.', 'warning');
    }
}

function initializeAnalysisCaptureButtons() {
    const views = document.querySelectorAll('.injury-view, .nearmiss-view');

    views.forEach(view => {
        if (!view.id) {
            return;
        }

        if (view.querySelector('.capture-view-btn')) {
            return;
        }

        const friendlyLabel = deriveViewLabel(view.id);
        const button = document.createElement('button');
        button.type = 'button';
        button.className = 'capture-view-btn';
        button.innerHTML = '<span>üì∏</span><span>Capture</span>';
        button.title = `Capture ${friendlyLabel}`;
        button.setAttribute('aria-label', `Capture ${friendlyLabel}`);
        button.addEventListener('click', event => {
            event.stopPropagation();
            captureAnalysisView(view.id, friendlyLabel, event.currentTarget);
        });

        view.appendChild(button);
    });
}

// Generate PDF Report
function legacyGeneratePDFReport(type) {
    showStatus('Generating enhanced professional PDF report...', 'info');

    try {
        const { jsPDF } = window.jspdf || {};
        if (!jsPDF) {
            throw new Error('jsPDF library not available');
        }

        const doc = new jsPDF({
            orientation: 'portrait',
            unit: 'mm',
            format: 'a4'
        });

        doc.setFont('helvetica', 'normal');

        const pageWidth = doc.internal.pageSize.getWidth();
        const pageHeight = doc.internal.pageSize.getHeight();
        const margin = 15;
        const contentWidth = pageWidth - margin * 2;
        let currentPage = 1;

        const REPORT_COLORS = {
            primary: '#FF9900',
            secondary: '#232F3E',
            tertiary: '#37475A',
            success: '#4CAF50',
            warning: '#FFC107',
            danger: '#B71C1C',
            info: '#2196F3',
            neutral: '#9E9E9E',
            background: '#F5F5F5'
        };

        const reportTitles = {
            injury: 'Injury & Illness Analysis',
            nearmiss: 'Near Miss Intelligence',
            combined: 'Integrated Safety Report',
            executive: 'Executive Safety Dashboard',
            wbr: 'Weekly Business Review'
        };

        const addHeader = (pageNum, reportType) => {
            doc.setFillColor(...hexToRgb(REPORT_COLORS.primary));
            doc.rect(0, 0, pageWidth, 35, 'F');

            doc.setFillColor(...hexToRgb(REPORT_COLORS.secondary));
            doc.rect(0, 0, 65, 35, 'F');

            doc.setTextColor(255, 255, 255);
            doc.setFontSize(20);
            doc.setFont('helvetica', 'bold');
            const title = reportTitles[reportType] || 'Safety Report';
            doc.text(title, pageWidth / 2, 18, { align: 'center' });

            doc.setFontSize(11);
            doc.setFont('helvetica', 'normal');
            doc.text(`Reporting Period: ${getReportPeriod()}`, pageWidth / 2, 26, { align: 'center' });

            doc.setFontSize(9);
            doc.text(`Page ${pageNum}`, pageWidth - margin, 30, { align: 'right' });

            doc.setFontSize(10);
            doc.setFont('helvetica', 'bold');
            doc.text('AMAZON', 10, 15);
            doc.setFont('helvetica', 'normal');
            doc.text('WHS Austria', 10, 21);
        };

        const addFooter = (pageNum) => {
            const footerY = pageHeight - 12;
            doc.setFillColor(...hexToRgb(REPORT_COLORS.secondary));
            doc.rect(0, footerY - 3, pageWidth, 15, 'F');

            doc.setTextColor(255, 255, 255);
            doc.setFontSize(8);
            doc.setFont('helvetica', 'normal');
            doc.text('Confidential - Internal Use Only', margin, footerY);
            doc.text(`Generated: ${new Date().toLocaleString('en-GB')}`, pageWidth / 2, footerY, { align: 'center' });
            doc.text('¬© 2024 Amazon.com, Inc.', pageWidth - margin, footerY, { align: 'right' });
        };

        const addSectionHeader = (title, yPos, icon = '') => {
            doc.setFillColor(...hexToRgb(REPORT_COLORS.primary));
            doc.roundedRect(margin - 5, yPos - 8, contentWidth + 10, 14, 3, 3, 'F');
            doc.setTextColor(255, 255, 255);
            doc.setFontSize(14);
            doc.setFont('helvetica', 'bold');
            doc.text(icon ? `${icon} ${title}` : title, margin, yPos);
            return yPos + 15;
        };

        const addMetricCard = (x, y, width, height, label, value, trend = '', color = REPORT_COLORS.primary, icon = '') => {
            doc.setFillColor(255, 255, 255);
            doc.setDrawColor(230, 230, 230);
            doc.roundedRect(x, y, width, height, 3, 3, 'FD');

            doc.setFillColor(...hexToRgb(color));
            doc.rect(x, y, width, 3, 'F');

            if (icon) {
                doc.setTextColor(...hexToRgb(REPORT_COLORS.secondary));
                doc.setFontSize(12);
                doc.text(icon, x + 5, y + 11);
            }

            doc.setTextColor(...hexToRgb(REPORT_COLORS.secondary));
            doc.setFontSize(20);
            doc.setFont('helvetica', 'bold');
            doc.text(String(value ?? 'N/A'), x + width / 2, y + height / 2 - 2, { align: 'center' });

            doc.setFontSize(9);
            doc.setFont('helvetica', 'normal');
            doc.setTextColor(120, 120, 120);
            doc.text(label, x + width / 2, y + height / 2 + 5, { align: 'center' });

            if (trend) {
                const trendColor = trend.includes('+') || trend.startsWith('‚Üë') ? REPORT_COLORS.danger : trend.includes('-') || trend.startsWith('‚Üì') ? REPORT_COLORS.success : REPORT_COLORS.info;
                doc.setFontSize(8);
                doc.setTextColor(...hexToRgb(trendColor));
                doc.text(trend, x + width / 2, y + height - 4, { align: 'center' });
            }
        };

        const addChart = (chartId, x, y, width, height) => {
            try {
                const chart = Chart.getChart(chartId);
                if (chart) {
                    const chartImage = chart.toBase64Image();
                    doc.addImage(chartImage, 'PNG', x, y, width, height);
                    return true;
                }
            } catch (error) {
                console.warn(`Could not add chart ${chartId}:`, error);
            }
            return false;
        };

        const addInsightBox = (x, y, width, title, insights, icon = 'üí°') => {
            const lineHeight = 5;
            const wrappedInsights = (insights && insights.length ? insights : ['No notable insights available for the selected filters.']).map(insight => doc.splitTextToSize(insight, width - 12));
            const textHeight = wrappedInsights.reduce((total, lines) => total + lines.length * lineHeight + 1, 0);
            const height = 12 + textHeight + 4;

            doc.setFillColor(250, 250, 250);
            doc.setDrawColor(200, 200, 200);
            doc.roundedRect(x, y, width, height, 3, 3, 'FD');

            doc.setFillColor(...hexToRgb(REPORT_COLORS.tertiary));
            doc.roundedRect(x, y, width, 8, 3, 3, 'F');

            doc.setTextColor(255, 255, 255);
            doc.setFontSize(10);
            doc.setFont('helvetica', 'bold');
            doc.text(icon ? `${icon} ${title}` : title, x + 3, y + 5.5);

            doc.setTextColor(...hexToRgb(REPORT_COLORS.secondary));
            doc.setFontSize(9);
            doc.setFont('helvetica', 'normal');

            let cursorY = y + 13;
            wrappedInsights.forEach((lines, idx) => {
                lines.forEach((line, lineIdx) => {
                    const prefix = lineIdx === 0 ? '‚Ä¢ ' : '  ';
                    doc.text(`${prefix}${line}`, x + 3, cursorY);
                    cursorY += lineHeight;
                });
                if (idx < wrappedInsights.length - 1) {
                    cursorY += 1;
                }
            });

            return y + height + 10;
        };

        const ensureHeadersForNewPages = () => {
            const totalPages = doc.internal.getNumberOfPages();
            if (totalPages > currentPage) {
                for (let page = currentPage + 1; page <= totalPages; page++) {
                    doc.setPage(page);
                    addHeader(page, type);
                    addFooter(page);
                }
                currentPage = totalPages;
                doc.setPage(currentPage);
            }
        };

        const goToNextPage = () => {
            doc.setPage(currentPage);
            addFooter(currentPage);
            doc.addPage();
            currentPage = doc.internal.getNumberOfPages();
            addHeader(currentPage, type);
            return 45;
        };

        const metrics = calculateComprehensiveMetrics(type);
        let yPos = 45;

        addHeader(currentPage, type);

        yPos = addSectionHeader('Executive Summary', yPos, 'üìä');

        const cardWidth = (contentWidth - 30) / 4;
        const cardHeight = 25;

        addMetricCard(margin, yPos, cardWidth, cardHeight,
            'Total Incidents', metrics.totalIncidents, metrics.incidentTrend,
            REPORT_COLORS.primary, 'üìà');

        addMetricCard(margin + cardWidth + 10, yPos, cardWidth, cardHeight,
            'Recordable Rate', `${metrics.recordableRate}%`, metrics.recordableTrend,
            metrics.recordableRate > 5 ? REPORT_COLORS.danger : REPORT_COLORS.success, '‚ö†Ô∏è');

        addMetricCard(margin + (cardWidth + 10) * 2, yPos, cardWidth, cardHeight,
            'Severity A/B', metrics.highSeverityCount, metrics.severityTrend,
            metrics.highSeverityCount > 0 ? REPORT_COLORS.danger : REPORT_COLORS.success, 'üö®');

        addMetricCard(margin + (cardWidth + 10) * 3, yPos, cardWidth, cardHeight,
            'Days Lost', metrics.totalDaysLost, metrics.daysLostTrend,
            REPORT_COLORS.warning, 'üìÖ');

        yPos += cardHeight + 10;

        addMetricCard(margin, yPos, cardWidth, cardHeight,
            'Near Miss Ratio', metrics.nearMissRatio, '',
            REPORT_COLORS.info, 'üéØ');

        addMetricCard(margin + cardWidth + 10, yPos, cardWidth, cardHeight,
            'Risk Score Avg', metrics.avgRiskScore.toFixed(1), metrics.riskTrend,
            metrics.avgRiskScore > 7 ? REPORT_COLORS.danger : REPORT_COLORS.warning, 'üé≤');

        addMetricCard(margin + (cardWidth + 10) * 2, yPos, cardWidth, cardHeight,
            'Closure Rate', `${metrics.closureRate}%`, '',
            metrics.closureRate < 80 ? REPORT_COLORS.warning : REPORT_COLORS.success, '‚úÖ');

        addMetricCard(margin + (cardWidth + 10) * 3, yPos, cardWidth, cardHeight,
            'TRIR', metrics.trir.toFixed(2), metrics.trirTrend,
            metrics.trir > 2 ? REPORT_COLORS.danger : REPORT_COLORS.success, 'üìä');

        yPos += cardHeight + 15;

        const keyInsights = generateKeyInsights(type, metrics);
        yPos = addInsightBox(margin, yPos, contentWidth, 'Key Insights & Findings', keyInsights, 'üí°');

        yPos = goToNextPage();

        yPos = addSectionHeader('Primary Impact Analysis', yPos, 'üí•');

        const impactData = getImpactAnalysis(type);
        if (impactData.length) {
            doc.autoTable({
                startY: yPos,
                head: [['Impact Type', 'Count', 'Percentage', 'Avg Severity', 'Risk Level']],
                body: impactData.map(row => [
                    row.type,
                    row.count,
                    `${row.percentage}%`,
                    row.avgSeverity,
                    row.riskLevel
                ]),
                theme: 'grid',
                headStyles: {
                    fillColor: hexToRgb(REPORT_COLORS.secondary),
                    textColor: [255, 255, 255]
                },
                bodyStyles: { fontSize: 9 },
                columnStyles: {
                    0: { cellWidth: 60 },
                    1: { cellWidth: 25, halign: 'center' },
                    2: { cellWidth: 30, halign: 'center' },
                    3: { cellWidth: 35, halign: 'center' },
                    4: { cellWidth: 35, halign: 'center' }
                },
                willDrawCell: (data) => {
                    if (data.section === 'body' && data.column.index === 4) {
                        const risk = data.cell.raw;
                        let color = REPORT_COLORS.success;
                        if (risk === 'Critical') {
                            color = REPORT_COLORS.danger;
                        } else if (risk === 'High') {
                            color = REPORT_COLORS.warning;
                        } else if (risk === 'Medium') {
                            color = REPORT_COLORS.info;
                        }
                        data.cell.styles.fillColor = hexToRgb(color);
                        data.cell.styles.textColor = [255, 255, 255];
                    }
                },
                margin: { left: margin, right: margin }
            });
            ensureHeadersForNewPages();
            doc.setPage(currentPage);
            yPos = doc.lastAutoTable.finalY + 15;
        } else {
            doc.setFontSize(10);
            doc.setTextColor(...hexToRgb(REPORT_COLORS.secondary));
            doc.text('No impact analysis data available for the selected filters.', margin, yPos + 5);
            yPos += 15;
        }

        yPos = addSectionHeader('Process Path Breakdown', yPos, 'üîÑ');
        const processData = getProcessPathAnalysis(type);
        if (processData.length) {
            const processes = processData.map(p => p.process);
            const heatMapWidth = contentWidth / Math.max(processes.length, 1);
            const heatMapHeight = 20;

            processData.forEach((processInfo, idx) => {
                const riskIntensity = Math.min(1, processInfo.risk / 10);
                const color = [
                    255,
                    Math.max(0, Math.round(255 - 140 * riskIntensity)),
                    Math.max(0, Math.round(255 - 140 * riskIntensity))
                ];
                doc.setFillColor(...color);
                doc.rect(margin + idx * heatMapWidth, yPos, heatMapWidth, heatMapHeight, 'F');

                doc.setTextColor(riskIntensity > 0.6 ? 255 : 30);
                doc.setFontSize(10);
                doc.setFont('helvetica', 'bold');
                doc.text(processInfo.process, margin + idx * heatMapWidth + heatMapWidth / 2, yPos + 8, { align: 'center' });

                doc.setFontSize(8);
                doc.setFont('helvetica', 'normal');
                doc.text(`${processInfo.incidents} incidents`, margin + idx * heatMapWidth + heatMapWidth / 2, yPos + 14, { align: 'center' });
            });

            yPos += heatMapHeight + 15;
        } else {
            doc.setFontSize(10);
            doc.setTextColor(...hexToRgb(REPORT_COLORS.secondary));
            doc.text('No process path information available.', margin, yPos + 5);
            yPos += 15;
        }

        const processInsights = generateProcessInsights(processData);
        yPos = addInsightBox(margin, yPos, contentWidth, 'Process-Specific Recommendations', processInsights, 'üéØ');

        yPos = goToNextPage();

        yPos = addSectionHeader('Trend Analysis & Patterns', yPos, 'üìà');

        const chartMap = {
            injury: ['injuryChart1', 'injuryChart2'],
            nearmiss: ['nearMissChart1', 'nearMissChart2'],
            combined: ['combinedTrendChart', 'combinedSiteChart'],
            wbr: ['combinedTrendChart', 'combinedSeverityChart'],
            executive: ['combinedTrendChart', 'combinedSiteChart']
        };
        const chartIds = chartMap[type] || chartMap.combined;
        const chartsToRender = chartIds
            .map(id => ({ id, chart: Chart.getChart(id) }))
            .filter(item => item.chart);

        if (chartsToRender.length) {
            const chartWidth = (contentWidth - (chartsToRender.length - 1) * 10) / chartsToRender.length;
            chartsToRender.forEach((item, index) => {
                addChart(item.id, margin + index * (chartWidth + 10), yPos, chartWidth, 60);
            });
            yPos += 65;
        } else {
            doc.setFontSize(10);
            doc.setTextColor(...hexToRgb(REPORT_COLORS.secondary));
            doc.text('Charts are not available. Ensure dashboards are loaded before exporting.', margin, yPos + 5);
            yPos += 15;
        }

        const monthlyData = getMonthlyTrendData(type);
        if (monthlyData.length) {
            doc.autoTable({
                startY: yPos,
                head: [['Month', 'Incidents', 'Recordable', 'Near Miss', 'Risk Score', 'Actions']],
                body: monthlyData.map(month => [
                    month.name,
                    month.incidents,
                    month.recordable,
                    month.nearMiss,
                    month.riskScore.toFixed(1),
                    month.actions
                ]),
                theme: 'striped',
                headStyles: { fillColor: hexToRgb(REPORT_COLORS.secondary), textColor: [255, 255, 255] },
                styles: { fontSize: 9, cellPadding: 3 },
                margin: { left: margin, right: margin }
            });
            ensureHeadersForNewPages();
            doc.setPage(currentPage);
            yPos = doc.lastAutoTable.finalY + 15;
        }

        yPos = goToNextPage();

        yPos = addSectionHeader('Risk Matrix & Mitigation Priority', yPos, '‚ö°');

        const matrixSize = 100;
        const cellSize = matrixSize / 5;
        const matrixX = margin + 40;
        const matrixY = yPos + 10;

        const riskColors = {
            minimal: REPORT_COLORS.success,
            low: '#8BC34A',
            medium: REPORT_COLORS.warning,
            high: '#FF9800',
            critical: '#FF5722'
        };

        for (let row = 0; row < 5; row++) {
            for (let col = 0; col < 5; col++) {
                const severity = 5 - row;
                const likelihood = col + 1;
                const riskScore = severity * likelihood;
                let colorKey = 'minimal';
                if (riskScore >= 20) {
                    colorKey = 'critical';
                } else if (riskScore >= 15) {
                    colorKey = 'high';
                } else if (riskScore >= 10) {
                    colorKey = 'medium';
                } else if (riskScore >= 5) {
                    colorKey = 'low';
                }

                doc.setFillColor(...hexToRgb(riskColors[colorKey]));
                doc.rect(matrixX + col * cellSize, matrixY + row * cellSize, cellSize, cellSize, 'F');

                doc.setTextColor(255, 255, 255);
                doc.setFontSize(8);
                doc.setFont('helvetica', 'bold');
                doc.text(String(riskScore), matrixX + col * cellSize + cellSize / 2, matrixY + row * cellSize + cellSize / 2 + 1, { align: 'center' });
            }
        }

        doc.setTextColor(...hexToRgb(REPORT_COLORS.secondary));
        doc.setFontSize(10);
        doc.setFont('helvetica', 'bold');

        const severityLabels = ['Critical', 'A', 'B', 'C', 'D'];
        severityLabels.forEach((label, idx) => {
            doc.text(label, matrixX - 5, matrixY + idx * cellSize + cellSize / 2 + 2, { align: 'right' });
        });

        const likelihoodLabels = ['Rare', 'Unlikely', 'Possible', 'Likely', 'Certain'];
        likelihoodLabels.forEach((label, idx) => {
            doc.text(label, matrixX + idx * cellSize + cellSize / 2, matrixY + matrixSize + 10, { align: 'center' });
        });

        doc.text('Severity', matrixX - 25, matrixY + matrixSize / 2, { align: 'center' });
        doc.text('Likelihood', matrixX + matrixSize / 2, matrixY + matrixSize + 20, { align: 'center' });

        yPos = matrixY + matrixSize + 30;

        const riskDistribution = calculateRiskDistribution(type);
        doc.autoTable({
            startY: yPos,
            head: [['Risk Level', 'Count', '%', 'Top Location', 'Primary Action']],
            body: [
                ['Critical (20-25)', riskDistribution.critical.count, `${riskDistribution.critical.percentage}%`,
                    riskDistribution.critical.topLocation, 'Immediate intervention required'],
                ['High (15-19)', riskDistribution.high.count, `${riskDistribution.high.percentage}%`,
                    riskDistribution.high.topLocation, 'Action within 24 hours'],
                ['Medium (10-14)', riskDistribution.medium.count, `${riskDistribution.medium.percentage}%`,
                    riskDistribution.medium.topLocation, 'Action within 7 days'],
                ['Low (5-9)', riskDistribution.low.count, `${riskDistribution.low.percentage}%`,
                    riskDistribution.low.topLocation, 'Monitor and review'],
                ['Minimal (1-4)', riskDistribution.minimal.count, `${riskDistribution.minimal.percentage}%`,
                    riskDistribution.minimal.topLocation, 'Routine controls']
            ],
            theme: 'grid',
            headStyles: { fillColor: hexToRgb(REPORT_COLORS.secondary), textColor: [255, 255, 255] },
            styles: { fontSize: 9 },
            columnStyles: {
                0: { cellWidth: 40 },
                1: { cellWidth: 20, halign: 'center' },
                2: { cellWidth: 18, halign: 'center' },
                3: { cellWidth: 50 },
                4: { cellWidth: 60 }
            },
            margin: { left: margin, right: margin }
        });
        ensureHeadersForNewPages();
        doc.setPage(currentPage);
        yPos = doc.lastAutoTable.finalY + 15;

        yPos = goToNextPage();

        yPos = addSectionHeader('Root Cause Analysis & Corrective Actions', yPos, 'üîç');

        const rootCauses = getRootCauseAnalysis(type);
        if (rootCauses.length) {
            doc.autoTable({
                startY: yPos,
                head: [['Root Cause', 'Frequency', 'Cumulative %', 'Associated Severity']],
                body: rootCauses.slice(0, 10).map(cause => [
                    cause.name,
                    cause.count,
                    `${cause.cumulative}%`,
                    cause.avgSeverity
                ]),
                theme: 'striped',
                headStyles: { fillColor: hexToRgb(REPORT_COLORS.secondary), textColor: [255, 255, 255] },
                styles: { fontSize: 9 },
                margin: { left: margin, right: margin }
            });
            ensureHeadersForNewPages();
            doc.setPage(currentPage);
            yPos = doc.lastAutoTable.finalY + 15;
        } else {
            doc.setFontSize(10);
            doc.setTextColor(...hexToRgb(REPORT_COLORS.secondary));
            doc.text('Root cause information is unavailable.', margin, yPos + 5);
            yPos += 15;
        }

        yPos = addSectionHeader('Recommended Actions', yPos, '‚úÖ');

        const actions = generateRecommendedActions(type, metrics, rootCauses);

        const renderPriorityActions = (title, icon, color, background, actionList, startY) => {
            const lines = actionList.length ? actionList.map((action, idx) => doc.splitTextToSize(`${idx + 1}. ${action}`, contentWidth - 12)) : [doc.splitTextToSize('No actions identified for this priority. Maintain current controls and monitor performance.', contentWidth - 12)];
            const totalLines = lines.reduce((sum, group) => sum + group.length, 0);
            const boxHeight = 14 + totalLines * 5;

            doc.setFillColor(...background);
            doc.roundedRect(margin, startY, contentWidth, boxHeight, 3, 3, 'F');

            doc.setTextColor(...hexToRgb(color));
            doc.setFontSize(11);
            doc.setFont('helvetica', 'bold');
            doc.text(`${icon} ${title}`, margin + 3, startY + 7);

            doc.setTextColor(...hexToRgb(REPORT_COLORS.secondary));
            doc.setFontSize(9);
            doc.setFont('helvetica', 'normal');

            let cursor = startY + 14;
            lines.forEach(group => {
                group.forEach(line => {
                    doc.text(line, margin + 5, cursor);
                    cursor += 5;
                });
                cursor += 1;
            });

            return startY + boxHeight + 10;
        };

        yPos = renderPriorityActions('Priority 1 - Immediate Actions (Within 24 hours)', 'üö®', REPORT_COLORS.danger, hexToRgb('#FFE7E7'), actions.priority1, yPos);
        yPos = renderPriorityActions('Priority 2 - Short-term Actions (Within 7 days)', '‚ö†Ô∏è', REPORT_COLORS.warning, hexToRgb('#FFF4E0'), actions.priority2, yPos);
        yPos = renderPriorityActions('Priority 3 - Long-term Improvements', 'üìã', REPORT_COLORS.success, hexToRgb('#E7F7E7'), actions.priority3, yPos);

        if (type === 'executive' || type === 'wbr') {
            yPos = goToNextPage();

            yPos = addSectionHeader('Predictive Analytics & Forecasting', yPos, 'üîÆ');

            const predictions = generatePredictiveInsights(type, metrics);
            const forecastWidth = (contentWidth - 20) / 3;

            addMetricCard(margin, yPos, forecastWidth, 30,
                'Projected Incidents (Next 30 days)', predictions.projected30Day,
                predictions.trend30Day, REPORT_COLORS.info, 'üìä');

            addMetricCard(margin + forecastWidth + 10, yPos, forecastWidth, 30,
                'Risk Score Projection', predictions.riskProjection,
                predictions.riskTrend, REPORT_COLORS.warning, '‚ö°');

            addMetricCard(margin + (forecastWidth + 10) * 2, yPos, forecastWidth, 30,
                'TRIR Forecast (EOY)', predictions.trirEOY,
                predictions.trirChange, REPORT_COLORS.primary, 'üìà');

            yPos += 40;

            yPos = addSectionHeader('Leading Indicators & Early Warning Signs', yPos, 'üö¶');

            const indicators = getLeadingIndicators(type, metrics);
            doc.autoTable({
                startY: yPos,
                head: [['Indicator', 'Current', 'Baseline', 'Status', 'Action Required']],
                body: indicators.map(ind => [
                    ind.name,
                    ind.current,
                    ind.baseline,
                    ind.status,
                    ind.action
                ]),
                theme: 'grid',
                headStyles: { fillColor: hexToRgb(REPORT_COLORS.secondary), textColor: [255, 255, 255] },
                styles: { fontSize: 9 },
                columnStyles: { 3: { halign: 'center', cellWidth: 20 } },
                didParseCell: (data) => {
                    if (data.section === 'body' && data.column.index === 3) {
                        data.cell.text = [''];
                    }
                },
                didDrawCell: (data) => {
                    if (data.section === 'body' && data.column.index === 3) {
                        const status = indicators[data.row.index].status;
                        const color = status === 'üî¥' ? REPORT_COLORS.danger : status === 'üü°' ? REPORT_COLORS.warning : REPORT_COLORS.success;
                        const centerX = data.cell.x + data.cell.width / 2;
                        const centerY = data.cell.y + data.cell.height / 2;
                        doc.setFillColor(...hexToRgb(color));
                        doc.circle(centerX, centerY, 3, 'F');
                    }
                },
                margin: { left: margin, right: margin }
            });
            ensureHeadersForNewPages();
            doc.setPage(currentPage);
            yPos = doc.lastAutoTable.finalY + 15;

            yPos = addSectionHeader('Performance Benchmarking', yPos, 'üèÜ');

            const benchmarks = getBenchmarkData(type, metrics);
            const benchmarkInsights = [
                `Site performance: Rank #${benchmarks.siteRank} of ${benchmarks.totalSites} in network`,
                `${benchmarks.aboveAverage}% of key metrics outperform network average`,
                `Best performing area: ${benchmarks.bestArea} (${benchmarks.bestMetric})`,
                `Focus area: ${benchmarks.worstArea} (${benchmarks.worstMetric})`,
                `Quarter-over-quarter improvement: ${benchmarks.qoqImprovement}%`
            ];

            addInsightBox(margin, yPos, contentWidth, 'Comparative Performance', benchmarkInsights, 'üìä');
        }

        doc.setPage(currentPage);
        addFooter(currentPage);

        const fileName = `${type}_safety_report_${new Date().toISOString().split('T')[0]}_enhanced.pdf`;
        doc.save(fileName);

        showStatus('Enhanced professional PDF report generated successfully!', 'success');
        addToReportHistory(type, fileName);
    } catch (error) {
        console.error('PDF generation error:', error);
        showStatus('Error generating PDF: ' + error.message, 'error');
    }
}

function calculateComprehensiveMetrics(type) {
    const injuryData = state?.injury?.filteredData || [];
    const nearMissData = state?.nearMiss?.filteredData || [];
    const relevantData = type === 'injury' ? injuryData :
        type === 'nearmiss' ? nearMissData : [...injuryData, ...nearMissData];

    const totalIncidents = relevantData.length;

    const recordableCount = injuryData.filter(r => r.recordable === 1).length;
    const recordableRate = injuryData.length ? (recordableCount / injuryData.length) * 100 : 0;

    const highSeverityCount = relevantData.filter(r => r.severity === 'A' || r.severity === 'B').length;
    const totalDaysLost = injuryData.reduce((sum, r) => sum + (Number(r.total_dafw_days) || 0), 0);

    const riskScores = relevantData
        .map(r => parseFloat(r.risk ?? calculateRiskScore(r)))
        .filter(score => !Number.isNaN(score));
    const avgRiskScore = riskScores.length ? riskScores.reduce((a, b) => a + b, 0) / riskScores.length : 0;

    const hoursWorked = state?.hoursWorked || 200000;
    const trir = recordableCount ? (recordableCount / hoursWorked) * 200000 : 0;
    const lostTimeCases = injuryData.filter(r => (Number(r.total_dafw_days) || 0) > 0).length;
    const ltir = lostTimeCases ? (lostTimeCases / hoursWorked) * 200000 : 0;

    const now = new Date();
    const currentMonth = now.getMonth();
    const currentYear = now.getFullYear();
    const previousMonthDate = new Date(currentYear, currentMonth - 1, 1);
    const previousMonth = previousMonthDate.getMonth();
    const previousYear = previousMonthDate.getFullYear();

    const getRecordDate = (row) => {
        if (row.parsedDate instanceof Date && !Number.isNaN(row.parsedDate)) {
            return row.parsedDate;
        }
        const dateValue = row.incident_date || row.nearmiss_date || row.date;
        if (!dateValue) {
            return null;
        }
        const parsed = new Date(dateValue);
        return Number.isNaN(parsed) ? null : parsed;
    };

    const currentData = relevantData.filter(r => {
        const date = getRecordDate(r);
        return date && date.getMonth() === currentMonth && date.getFullYear() === currentYear;
    });
    const previousData = relevantData.filter(r => {
        const date = getRecordDate(r);
        return date && date.getMonth() === previousMonth && date.getFullYear() === previousYear;
    });

    let incidentTrend = 'N/A';
    if (previousData.length > 0) {
        const change = ((currentData.length - previousData.length) / previousData.length) * 100;
        incidentTrend = `${change >= 0 ? '+' : ''}${change.toFixed(1)}%`;
    }

    let recordableTrend = 'N/A';
    const currentRecordables = currentData.filter(r => r.recordable === 1).length;
    const previousRecordables = previousData.filter(r => r.recordable === 1).length;
    if (previousRecordables > 0) {
        const change = ((currentRecordables - previousRecordables) / previousRecordables) * 100;
        recordableTrend = `${change >= 0 ? '+' : ''}${change.toFixed(1)}%`;
    }

    const currentHighSeverity = currentData.filter(r => r.severity === 'A' || r.severity === 'B').length;
    const previousHighSeverity = previousData.filter(r => r.severity === 'A' || r.severity === 'B').length;
    const severityTrend = previousHighSeverity ? `${currentHighSeverity - previousHighSeverity >= 0 ? '+' : ''}${currentHighSeverity - previousHighSeverity}` : `${currentHighSeverity}`;

    const currentDaysLost = injuryData.filter(r => {
        const date = getRecordDate(r);
        return date && date.getMonth() === currentMonth && date.getFullYear() === currentYear;
    }).reduce((sum, r) => sum + (Number(r.total_dafw_days) || 0), 0);
    const previousDaysLost = injuryData.filter(r => {
        const date = getRecordDate(r);
        return date && date.getMonth() === previousMonth && date.getFullYear() === previousYear;
    }).reduce((sum, r) => sum + (Number(r.total_dafw_days) || 0), 0);
    let daysLostTrend = 'N/A';
    if (previousDaysLost > 0) {
        const change = ((currentDaysLost - previousDaysLost) / previousDaysLost) * 100;
        daysLostTrend = `${change >= 0 ? '+' : ''}${change.toFixed(1)}%`;
    } else if (currentDaysLost > 0) {
        daysLostTrend = '+100%';
    }

    const previousRiskScores = previousData
        .map(r => parseFloat(r.risk ?? calculateRiskScore(r)))
        .filter(score => !Number.isNaN(score));
    const previousRiskAvg = previousRiskScores.length ? previousRiskScores.reduce((a, b) => a + b, 0) / previousRiskScores.length : avgRiskScore;
    const riskTrend = avgRiskScore >= previousRiskAvg ? '‚Üë' : '‚Üì';

    const previousRecordableRate = previousData.length ? (previousRecordables / previousData.length) * 100 : recordableRate;
    const trirTrend = recordableRate > previousRecordableRate ? '‚Üë' : recordableRate < previousRecordableRate ? '‚Üì' : '‚Üí';

    const nearMissRatio = injuryData.length ? `${(nearMissData.length / injuryData.length).toFixed(1)}:1` : 'N/A';
    const closedIncidents = relevantData.filter(r => ['Closed', 'Complete', 'Resolved'].includes(String(r.status).trim())).length;
    const closureRate = totalIncidents ? Math.round((closedIncidents / totalIncidents) * 100) : 0;

    return {
        totalIncidents,
        recordableRate: Number(recordableRate.toFixed(1)),
        recordableTrend,
        highSeverityCount,
        severityTrend,
        totalDaysLost,
        daysLostTrend,
        nearMissRatio,
        avgRiskScore,
        riskTrend,
        closureRate,
        trir,
        trirTrend,
        ltir,
        incidentTrend
    };
}

function generateKeyInsights(type, metrics) {
    const insights = [];

    if (metrics.recordableRate > 10) {
        insights.push(`Recordable rate remains elevated at ${metrics.recordableRate}% indicating systemic safety concerns.`);
    } else {
        insights.push(`Recordable rate of ${metrics.recordableRate}% is within the expected control range.`);
    }

    if (metrics.highSeverityCount > 0) {
        insights.push(`${metrics.highSeverityCount} high-severity incidents occurred this period and require immediate intervention.`);
    } else {
        insights.push('No severity A/B events recorded during the reporting period.');
    }

    if (metrics.nearMissRatio !== 'N/A') {
        const ratioValue = parseFloat(metrics.nearMissRatio);
        if (!Number.isNaN(ratioValue) && ratioValue < 3) {
            insights.push(`Near miss reporting ratio of ${metrics.nearMissRatio} signals potential under-reporting. Reinforce reporting culture.`);
        } else {
            insights.push(`Healthy near miss to injury ratio (${metrics.nearMissRatio}) demonstrates proactive hazard identification.`);
        }
    }

    if (metrics.avgRiskScore > 7) {
        insights.push(`Average risk score is ${metrics.avgRiskScore.toFixed(1)}, exceeding the threshold for enhanced controls.`);
    }

    if (metrics.closureRate < 80) {
        insights.push(`Closure rate is ${metrics.closureRate}% - accelerate action item completion to reach the 90% target.`);
    } else {
        insights.push(`Closure rate of ${metrics.closureRate}% reflects strong follow-through on corrective actions.`);
    }

    if (!insights.length) {
        insights.push('No significant deviations detected across monitored indicators. Maintain current controls.');
    }

    return insights;
}

function getImpactAnalysis(type) {
    const injuryData = state?.injury?.filteredData || [];
    const nearMissData = state?.nearMiss?.filteredData || [];
    const relevantData = type === 'injury' ? injuryData :
        type === 'nearmiss' ? nearMissData : [...injuryData, ...nearMissData];

    const total = relevantData.length;
    const impactMap = new Map();

    relevantData.forEach(row => {
        const impact = row.primaryImpact || row.initial_info_primary_impact || row.initial_info_impact_type_primary || 'Unknown';
        const entry = impactMap.get(impact) || { count: 0, severities: [], risks: [] };
        entry.count += 1;
        if (row.severity) {
            entry.severities.push(row.severity);
        }
        const riskScore = parseFloat(row.risk ?? calculateRiskScore(row));
        if (!Number.isNaN(riskScore)) {
            entry.risks.push(riskScore);
        }
        impactMap.set(impact, entry);
    });

    const severityMap = { A: 4, B: 3, C: 2, D: 1 };
    const severityLabels = ['D', 'C', 'B', 'A'];

    return Array.from(impactMap.entries()).map(([impact, data]) => {
        const avgSeverityScore = data.severities.length ?
            data.severities.map(s => severityMap[s] || 1).reduce((a, b) => a + b, 0) / data.severities.length : 1;
        const avgSeverity = severityLabels[Math.max(0, Math.round(avgSeverityScore) - 1)];
        const avgRisk = data.risks.length ? data.risks.reduce((a, b) => a + b, 0) / data.risks.length : 0;
        let riskLevel = 'Low';
        if (avgRisk >= 20) {
            riskLevel = 'Critical';
        } else if (avgRisk >= 15) {
            riskLevel = 'High';
        } else if (avgRisk >= 10) {
            riskLevel = 'Medium';
        }
        return {
            type: impact.substring(0, 50),
            count: data.count,
            percentage: total ? Number(((data.count / total) * 100).toFixed(1)) : 0,
            avgSeverity,
            riskLevel
        };
    }).sort((a, b) => b.count - a.count);
}

function getProcessPathAnalysis(type) {
    const injuryData = state?.injury?.filteredData || [];
    const nearMissData = state?.nearMiss?.filteredData || [];
    const relevantData = type === 'injury' ? injuryData :
        type === 'nearmiss' ? nearMissData : [...injuryData, ...nearMissData];

    const processMap = new Map();

    relevantData.forEach(row => {
        const processRaw = row.processPath || row.initial_info_process_path || 'Unknown';
        const process = processRaw || 'Unknown';
        if (!processMap.has(process)) {
            processMap.set(process, {
                process,
                incidents: 0,
                recordable: 0,
                severityA: 0,
                risk: 0
            });
        }
        const entry = processMap.get(process);
        entry.incidents += 1;
        if (row.recordable === 1) {
            entry.recordable += 1;
        }
        if (row.severity === 'A') {
            entry.severityA += 1;
        }
        const riskScore = parseFloat(row.risk ?? calculateRiskScore(row));
        if (!Number.isNaN(riskScore)) {
            entry.risk += riskScore;
        }
    });

    return Array.from(processMap.values()).map(entry => ({
        ...entry,
        risk: entry.incidents ? entry.risk / entry.incidents : 0
    })).sort((a, b) => b.incidents - a.incidents);
}

function generateProcessInsights(processData) {
    if (!processData || !processData.length) {
        return ['No process-specific data available. Load data to unlock tailored recommendations.'];
    }

    const insights = [];

    const byRisk = [...processData].sort((a, b) => b.risk - a.risk);
    if (byRisk[0] && byRisk[0].risk > 7) {
        insights.push(`${byRisk[0].process} shows the highest risk score (${byRisk[0].risk.toFixed(1)}). Prioritise a focused safety review.`);
    }

    const byIncidents = [...processData].sort((a, b) => b.incidents - a.incidents);
    if (byIncidents[0]) {
        insights.push(`${byIncidents[0].process} accounts for ${byIncidents[0].incidents} incidents. Implement targeted controls and coaching.`);
    }

    const severityAProcesses = processData.filter(p => p.severityA > 0);
    if (severityAProcesses.length) {
        insights.push(`Severity A incidents present in: ${severityAProcesses.map(p => p.process).join(', ')}.`);
    }

    const byBest = [...processData].filter(p => p.incidents > 0).sort((a, b) => a.incidents - b.incidents);
    if (byBest[0]) {
        insights.push(`${byBest[0].process} demonstrates best safety performance (${byBest[0].incidents} incidents). Share learnings across teams.`);
    }

    const highRecordable = processData.filter(p => p.incidents > 0 && p.recordable / p.incidents > 0.5);
    if (highRecordable.length) {
        insights.push(`High recordable rates detected in: ${highRecordable.map(p => p.process).join(', ')}. Revisit SOP compliance and supervision.`);
    }

    return insights;
}

function getMonthlyTrendData(type) {
    const injuryData = state?.injury?.filteredData || [];
    const nearMissData = state?.nearMiss?.filteredData || [];
    const relevantData = type === 'injury' ? injuryData :
        type === 'nearmiss' ? nearMissData : [...injuryData, ...nearMissData];
    const monthsToShow = 6;

    const now = new Date();
    const months = [];
    for (let i = monthsToShow - 1; i >= 0; i--) {
        const date = new Date(now.getFullYear(), now.getMonth() - i, 1);
        months.push({ month: date.getMonth(), year: date.getFullYear(), name: date.toLocaleString('en-GB', { month: 'short', year: 'numeric' }) });
    }

    const getDate = (row) => {
        if (row.parsedDate instanceof Date && !Number.isNaN(row.parsedDate)) {
            return row.parsedDate;
        }
        const raw = row.incident_date || row.nearmiss_date || row.date;
        if (!raw) {
            return null;
        }
        const parsed = new Date(raw);
        return Number.isNaN(parsed) ? null : parsed;
    };

    return months.map(({ month, year, name }) => {
        const monthRecords = relevantData.filter(row => {
            const date = getDate(row);
            return date && date.getMonth() === month && date.getFullYear() === year;
        });

        const injuryMonthRecords = injuryData.filter(row => {
            const date = getDate(row);
            return date && date.getMonth() === month && date.getFullYear() === year;
        });

        const nearMissMonthRecords = nearMissData.filter(row => {
            const date = getDate(row);
            return date && date.getMonth() === month && date.getFullYear() === year;
        });

        const riskScores = monthRecords
            .map(r => parseFloat(r.risk ?? calculateRiskScore(r)))
            .filter(score => !Number.isNaN(score));
        const avgRisk = riskScores.length ? riskScores.reduce((a, b) => a + b, 0) / riskScores.length : 0;

        const actions = generateActionItems(monthRecords);
        const totalActions = actions.immediate.length + actions.shortTerm.length + actions.longTerm.length;

        return {
            name,
            incidents: monthRecords.length,
            recordable: injuryMonthRecords.filter(r => r.recordable === 1).length,
            nearMiss: nearMissMonthRecords.length,
            riskScore: avgRisk,
            actions: totalActions
        };
    });
}

function calculateRiskDistribution(type) {
    const injuryData = state?.injury?.filteredData || [];
    const nearMissData = state?.nearMiss?.filteredData || [];
    const relevantData = type === 'injury' ? injuryData :
        type === 'nearmiss' ? nearMissData : [...injuryData, ...nearMissData];

    const distribution = {
        critical: { count: 0, locations: {} },
        high: { count: 0, locations: {} },
        medium: { count: 0, locations: {} },
        low: { count: 0, locations: {} },
        minimal: { count: 0, locations: {} }
    };

    const getLocation = (row) => row.location || row.initial_info_location_event || row.department || 'Unknown';

    relevantData.forEach(row => {
        const riskScore = parseFloat(row.risk ?? calculateRiskScore(row));
        if (Number.isNaN(riskScore)) {
            return;
        }
        let key = 'minimal';
        if (riskScore >= 20) {
            key = 'critical';
        } else if (riskScore >= 15) {
            key = 'high';
        } else if (riskScore >= 10) {
            key = 'medium';
        } else if (riskScore >= 5) {
            key = 'low';
        }
        distribution[key].count += 1;
        const location = getLocation(row);
        distribution[key].locations[location] = (distribution[key].locations[location] || 0) + 1;
    });

    const total = Object.values(distribution).reduce((sum, item) => sum + item.count, 0) || 1;

    const mapToResult = (entry) => {
        const locations = entry.locations;
        const topLocation = Object.entries(locations).sort((a, b) => b[1] - a[1])[0];
        return {
            count: entry.count,
            percentage: Number(((entry.count / total) * 100).toFixed(1)),
            topLocation: topLocation ? topLocation[0] : 'N/A'
        };
    };

    return {
        critical: mapToResult(distribution.critical),
        high: mapToResult(distribution.high),
        medium: mapToResult(distribution.medium),
        low: mapToResult(distribution.low),
        minimal: mapToResult(distribution.minimal)
    };
}

function getRootCauseAnalysis(type) {
    const injuryData = state?.injury?.filteredData || [];
    const nearMissData = state?.nearMiss?.filteredData || [];
    const relevantData = type === 'injury' ? injuryData :
        type === 'nearmiss' ? nearMissData : [...injuryData, ...nearMissData];

    const counts = new Map();
    const severityMap = { A: 4, B: 3, C: 2, D: 1 };

    relevantData.forEach(row => {
        const cause = row.rootCause || row.rca_primary_cause || 'Under Investigation';
        const entry = counts.get(cause) || { count: 0, severities: [] };
        entry.count += 1;
        if (row.severity) {
            entry.severities.push(row.severity);
        }
        counts.set(cause, entry);
    });

    const total = Array.from(counts.values()).reduce((sum, value) => sum + value.count, 0) || 1;

    let cumulative = 0;
    return Array.from(counts.entries())
        .sort((a, b) => b[1].count - a[1].count)
        .map(([name, data]) => {
            cumulative += (data.count / total) * 100;
            const avgSeverityScore = data.severities.length ?
                data.severities.map(s => severityMap[s] || 1).reduce((a, b) => a + b, 0) / data.severities.length : 1;
            const severityLabels = ['D', 'C', 'B', 'A'];
            const avgSeverity = severityLabels[Math.max(0, Math.round(avgSeverityScore) - 1)];
            return {
                name: name.substring(0, 60),
                count: data.count,
                cumulative: Number(cumulative.toFixed(1)),
                avgSeverity
            };
        });
}

function generateRecommendedActions(type, metrics, rootCauses) {
    const actions = {
        priority1: [],
        priority2: [],
        priority3: []
    };

    if (metrics.highSeverityCount > 0) {
        actions.priority1.push('Conduct immediate deep-dive investigations for all Severity A/B events with leadership review within 24 hours.');
    }

    if (metrics.recordableRate > 8) {
        actions.priority1.push('Launch rapid response team to address drivers of elevated recordable rate and reinforce life-saving rules.');
    }

    if (metrics.avgRiskScore > 7.5) {
        actions.priority1.push('Deploy enhanced controls at high-risk workstations identified through risk scoring analytics.');
    }

    const topCause = rootCauses && rootCauses.length ? rootCauses[0].name : null;
    if (topCause) {
        actions.priority2.push(`Implement corrective action plan targeting root cause: ${topCause}. Track completion through CAPA board.`);
    }

    if (metrics.nearMissRatio !== 'N/A') {
        const ratioValue = parseFloat(metrics.nearMissRatio);
        if (!Number.isNaN(ratioValue) && ratioValue < 3) {
            actions.priority2.push('Reinforce near miss reporting expectations with team huddles and simplified reporting channels.');
        }
    }

    if (metrics.closureRate < 85) {
        actions.priority2.push('Establish weekly action review cadence with area managers to accelerate closure rate to >90%.');
    }

    actions.priority3.push('Introduce quarterly safety culture pulse checks and embed findings into leadership standard work.');
    actions.priority3.push('Expand predictive analytics capability by integrating leading indicators and ergonomic risk assessments.');
    actions.priority3.push('Share best practices from top-performing areas and replicate successful interventions across the network.');

    if (!actions.priority1.length) {
        actions.priority1.push('No critical gaps detected. Maintain enhanced monitoring of severe risk activities.');
    }

    if (!actions.priority2.length) {
        actions.priority2.push('Sustain near-miss engagement programmes and continue quarterly process audits.');
    }

    return actions;
}

function generatePredictiveInsights(type, metrics) {
    const trendType = type === 'executive' || type === 'wbr' ? 'combined' : type;
    const monthlyData = getMonthlyTrendData(trendType);
    const recent = monthlyData.slice(-3);
    const previous = monthlyData.slice(-6, -3);

    const recentAvg = recent.length ? recent.reduce((sum, month) => sum + month.incidents, 0) / recent.length : metrics.totalIncidents;
    const previousAvg = previous.length ? previous.reduce((sum, month) => sum + month.incidents, 0) / previous.length : recentAvg;
    const growth = previousAvg ? ((recentAvg - previousAvg) / previousAvg) * 100 : 0;

    const lastMonth = monthlyData[monthlyData.length - 1] || { incidents: metrics.totalIncidents, riskScore: metrics.avgRiskScore };
    const projected = Math.max(0, Math.round(lastMonth.incidents * (1 + Math.min(growth, 30) / 100)));

    const riskProjection = (lastMonth.riskScore || metrics.avgRiskScore) * (growth > 0 ? 1.05 : 0.95);
    const trirProjection = metrics.trir * (growth > 0 ? 1.03 : 0.97);

    const formatTrend = (value) => {
        if (!Number.isFinite(value) || value === 0) {
            return '‚Üí 0%';
        }
        const prefix = value > 0 ? '‚Üë' : '‚Üì';
        return `${prefix} ${Math.abs(value).toFixed(1)}%`;
    };

    return {
        projected30Day: projected,
        trend30Day: formatTrend(growth),
        riskProjection: riskProjection.toFixed(1),
        riskTrend: riskProjection > metrics.avgRiskScore ? '‚Üë' : '‚Üì',
        trirEOY: trirProjection.toFixed(2),
        trirChange: trirProjection > metrics.trir ? '‚Üë' : '‚Üì'
    };
}

function getLeadingIndicators(type, metrics) {
    const indicators = [];

    const ratioValue = parseFloat(metrics.nearMissRatio);
    const nearMissStatus = Number.isNaN(ratioValue) ? 'üü°' : ratioValue >= 3 ? 'üü¢' : ratioValue >= 2 ? 'üü°' : 'üî¥';
    indicators.push({
        name: 'Near Miss to Injury Ratio',
        current: metrics.nearMissRatio,
        baseline: '3.0:1',
        status: nearMissStatus,
        action: nearMissStatus === 'üî¥' ? 'Launch campaign to boost near miss engagement within 2 weeks.' : 'Maintain recognition programme for hazard identification.'
    });

    const closureStatus = metrics.closureRate >= 90 ? 'üü¢' : metrics.closureRate >= 80 ? 'üü°' : 'üî¥';
    indicators.push({
        name: 'Corrective Action Closure',
        current: `${metrics.closureRate}%`,
        baseline: '90%',
        status: closureStatus,
        action: closureStatus === 'üî¥' ? 'Escalate overdue actions and assign executive sponsor.' : 'Sustain weekly action plan cadence.'
    });

    const riskStatus = metrics.avgRiskScore <= 6 ? 'üü¢' : metrics.avgRiskScore <= 7.5 ? 'üü°' : 'üî¥';
    indicators.push({
        name: 'Average Risk Score',
        current: metrics.avgRiskScore.toFixed(1),
        baseline: '6.0',
        status: riskStatus,
        action: riskStatus === 'üî¥' ? 'Deploy targeted risk mitigation workshops with process owners.' : 'Continue monitoring and refresh controls quarterly.'
    });

    const recordableStatus = metrics.recordableRate <= 5 ? 'üü¢' : metrics.recordableRate <= 8 ? 'üü°' : 'üî¥';
    indicators.push({
        name: 'Recordable Case Rate',
        current: `${metrics.recordableRate}%`,
        baseline: '5%',
        status: recordableStatus,
        action: recordableStatus === 'üî¥' ? 'Perform layered safety audits focused on high-risk tasks.' : 'Keep reinforcing critical safe behaviours.'
    });

    return indicators;
}

function getBenchmarkData(type, metrics) {
    const injuryData = state?.injury?.filteredData || [];
    const nearMissData = state?.nearMiss?.filteredData || [];
    const relevantData = type === 'injury' ? injuryData :
        type === 'nearmiss' ? nearMissData : [...injuryData, ...nearMissData];

    const areaCounts = {};
    relevantData.forEach(row => {
        const area = row.area || row.department || row.location || 'Unknown';
        areaCounts[area] = (areaCounts[area] || 0) + 1;
    });
    const sortedAreas = Object.entries(areaCounts).sort((a, b) => a[1] - b[1]);
    const bestArea = sortedAreas[0] ? sortedAreas[0][0] : 'N/A';
    const worstArea = sortedAreas[sortedAreas.length - 1] ? sortedAreas[sortedAreas.length - 1][0] : 'N/A';

    const totalSites = state?.benchmarking?.totalSites || 12;
    const indicatorsMet = [
        metrics.recordableRate <= 5,
        metrics.avgRiskScore <= 6.5,
        metrics.closureRate >= 85,
        parseFloat(metrics.nearMissRatio) >= 3 || metrics.nearMissRatio === 'N/A',
        metrics.trir <= 2
    ].filter(Boolean).length;
    const aboveAverage = Math.round((indicatorsMet / 5) * 100);

    const performanceScore = indicatorsMet ? 6 - indicatorsMet : 6;
    const siteRank = Math.max(1, Math.min(totalSites, performanceScore));

    const monthlyData = getMonthlyTrendData(type === 'executive' || type === 'wbr' ? 'combined' : type);
    const firstHalf = monthlyData.slice(0, 3).reduce((sum, month) => sum + month.incidents, 0);
    const secondHalf = monthlyData.slice(3).reduce((sum, month) => sum + month.incidents, 0);
    const qoqImprovement = firstHalf ? Number((((firstHalf - secondHalf) / firstHalf) * 100).toFixed(1)) : 0;

    const bestMetric = metrics.recordableRate <= 5 ? 'Recordable rate' : metrics.closureRate >= 90 ? 'Closure discipline' : 'Near miss engagement';
    const worstMetric = metrics.avgRiskScore > 7 ? 'Risk exposure' : metrics.closureRate < 80 ? 'Action closure' : 'Recordable rate';

    return {
        siteRank,
        totalSites,
        aboveAverage,
        bestArea,
        bestMetric,
        worstArea,
        worstMetric,
        qoqImprovement
    };
}
function legacyGenerateWBRReport() {
    showStatus('Generating Safety WBR Report...', 'info');

    try {
        const { jsPDF } = window.jspdf;
        const doc = new jsPDF();

        const REPORT_COLORS = {
            orange: '#FF9900',
            darkBlue: '#232F3E',
            lightBlue: '#146EB4',
            gray: '#767676',
            red: '#D13212',
            green: '#067D62'
        };

        const injuryData = state.injury.filteredData || [];
        const nearMissData = state.nearMiss.filteredData || [];
        const now = new Date();
        const currentWeek = getReportWeekNumber(now);
        const currentYear = now.getFullYear();

        function calculateWBRMetrics() {
            const totalIncidents = injuryData.length + nearMissData.length;
            const recordableIncidents = injuryData.filter(item => Number(item.recordable) === 1).length;
            const highRiskNearMiss = nearMissData.filter(item =>
                item.potential_severity === 'A' || item.potential_severity === 'B' ||
                item.severity === 'A' || item.severity === 'B'
            ).length;

            const hoursWorked = 200000;
            const trirValue = hoursWorked ? ((recordableIncidents / hoursWorked) * 200000) : 0;
            const trir = trirValue.toFixed(2);

            const nmRatio = injuryData.length > 0 ? (nearMissData.length / injuryData.length).toFixed(1) : 'N/A';
            const totalDaysLost = injuryData.reduce((sum, item) => sum + (parseInt(item.total_dafw_days) || 0), 0);
            const avgDaysLost = injuryData.length > 0 ? (totalDaysLost / injuryData.length).toFixed(1) : '0.0';
            const openInvestigations = [...injuryData, ...nearMissData].filter(item =>
                !item.rca_primary_cause || item.rca_primary_cause === 'Not Determined'
            ).length;

            const siteData = {};
            [...injuryData, ...nearMissData].forEach(item => {
                const site = item.site || 'Unknown';
                if (!siteData[site]) {
                    siteData[site] = { injuries: 0, nearMisses: 0, total: 0 };
                }
                if (item.case_number) {
                    siteData[site].injuries++;
                } else {
                    siteData[site].nearMisses++;
                }
                siteData[site].total++;
            });

            const rootCauses = {};
            [...injuryData, ...nearMissData].forEach(item => {
                const cause = item.rca_primary_cause || 'Not Determined';
                rootCauses[cause] = (rootCauses[cause] || 0) + 1;
            });

            const topRootCauses = Object.entries(rootCauses)
                .sort(([, a], [, b]) => b - a)
                .slice(0, 5);

            const recentIncidents = [...injuryData, ...nearMissData]
                .filter(item => {
                    const rawDate = item.incident_date || item.nearmiss_date;
                    if (!rawDate) return false;
                    const date = new Date(rawDate);
                    if (isNaN(date)) return false;
                    const daysDiff = (now - date) / (1000 * 60 * 60 * 24);
                    return daysDiff <= 14;
                })
                .filter(item =>
                    item.severity === 'A' || item.severity === 'B' ||
                    item.potential_severity === 'A' || item.potential_severity === 'B' ||
                    Number(item.recordable) === 1
                )
                .sort((a, b) => {
                    const aDate = new Date(a.incident_date || a.nearmiss_date);
                    const bDate = new Date(b.incident_date || b.nearmiss_date);
                    return bDate - aDate;
                })
                .slice(0, 5);

            const monthlyTrendMap = {};
            [...injuryData, ...nearMissData].forEach(item => {
                const rawDate = item.incident_date || item.nearmiss_date;
                if (!rawDate) return;
                const date = new Date(rawDate);
                if (isNaN(date)) return;
                const key = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;
                if (!monthlyTrendMap[key]) {
                    monthlyTrendMap[key] = { injuries: 0, nearMisses: 0 };
                }
                if (item.case_number) {
                    monthlyTrendMap[key].injuries++;
                } else {
                    monthlyTrendMap[key].nearMisses++;
                }
            });

            const monthlyTrend = Object.entries(monthlyTrendMap)
                .map(([monthKey, data]) => {
                    const [year, month] = monthKey.split('-');
                    const monthDate = new Date(Number(year), Number(month) - 1, 1);
                    const total = data.injuries + data.nearMisses;
                    const ratio = data.injuries > 0
                        ? (data.nearMisses / data.injuries).toFixed(1)
                        : (data.nearMisses > 0 ? 'N/A' : '0.0');
                    return {
                        label: monthDate.toLocaleString('default', { month: 'short', year: 'numeric' }),
                        injuries: data.injuries,
                        nearMisses: data.nearMisses,
                        total,
                        ratio,
                        sortValue: monthDate.getTime()
                    };
                })
                .sort((a, b) => b.sortValue - a.sortValue)
                .map(item => ({
                    label: item.label,
                    injuries: item.injuries,
                    nearMisses: item.nearMisses,
                    total: item.total,
                    ratio: item.ratio
                }));

            return {
                totalIncidents,
                recordableIncidents,
                highRiskNearMiss,
                trir,
                nmRatio,
                avgDaysLost,
                totalDaysLost,
                openInvestigations,
                siteData,
                topRootCauses,
                recentIncidents,
                monthlyTrend
            };
        }

        function getReportWeekNumber(date) {
            const tmp = new Date(date.valueOf());
            const dayNum = (tmp.getDay() + 6) % 7;
            tmp.setDate(tmp.getDate() - dayNum + 3);
            const firstThursday = tmp.valueOf();
            tmp.setMonth(0, 1);
            const firstDay = tmp.getDay();
            const dayOffset = firstDay === 0 ? -6 : 1;
            tmp.setMonth(0, 1 + dayOffset);
            if (tmp.getDay() !== 4) {
                tmp.setMonth(0, 1 + dayOffset + ((4 - tmp.getDay()) + 7) % 7);
            }
            return 1 + Math.round((firstThursday - tmp) / (7 * 24 * 3600 * 1000));
        }

        function addHeader(pageNum) {
            doc.setFillColor(...hexToRgb(REPORT_COLORS.darkBlue));
            doc.rect(0, 0, 210, 25, 'F');

            doc.setTextColor(255, 255, 255);
            doc.setFontSize(16);
            doc.setFont('helvetica', 'bold');
            doc.text('Safety WBR Report - Executive Dashboard', 20, 16);

            doc.setFontSize(10);
            doc.setFont('helvetica', 'normal');
            doc.text(`CW${currentWeek}-${currentYear} | Page ${pageNum}`, 150, 16);
        }

        function addSectionHeader(title, y) {
            doc.setFillColor(...hexToRgb(REPORT_COLORS.orange));
            doc.rect(20, y, 170, 8, 'F');
            doc.setTextColor(255, 255, 255);
            doc.setFontSize(12);
            doc.setFont('helvetica', 'bold');
            doc.text(title, 22, y + 6);
            return y + 15;
        }

        function addMetricBox(x, y, width, height, label, value, color, trend = null) {
            doc.setFillColor(250, 250, 250);
            doc.setDrawColor(...hexToRgb(color));
            doc.setLineWidth(2);
            doc.rect(x, y, width, height, 'FD');

            doc.setFillColor(...hexToRgb(color));
            doc.rect(x, y, width, 4, 'F');

            doc.setTextColor(...hexToRgb(REPORT_COLORS.darkBlue));
            doc.setFontSize(18);
            doc.setFont('helvetica', 'bold');
            doc.text(value.toString(), x + width / 2, y + height / 2 + 2, { align: 'center' });

            doc.setFontSize(9);
            doc.setFont('helvetica', 'normal');
            doc.text(label, x + width / 2, y + height - 4, { align: 'center' });

            if (trend) {
                doc.setFontSize(8);
                const trendColor = trend.includes('‚Üë') ? REPORT_COLORS.red : REPORT_COLORS.green;
                doc.setTextColor(...hexToRgb(trendColor));
                doc.text(trend, x + width - 5, y + 8, { align: 'right' });
            }
        }

        const metrics = calculateWBRMetrics();

        let currentPage = 1;
        addHeader(currentPage);
        let yPos = 35;

        doc.setTextColor(...hexToRgb(REPORT_COLORS.darkBlue));
        doc.setFontSize(10);
        const siteKeys = Object.keys(metrics.siteData);
        const totalSites = siteKeys.length;
        doc.text(`Report Generated: ${now.toLocaleString()}`, 20, yPos);
        doc.text(`Period: Last 30 days | Total Sites: ${totalSites}`, 20, yPos + 6);
        const sitesList = siteKeys.length > 0 ? siteKeys.join(', ') : 'No site data available';
        const sitesText = doc.splitTextToSize(`Sites Included: ${sitesList}`, 170);
        doc.text(sitesText, 20, yPos + 12);
        const siteTextDimensions = doc.getTextDimensions(sitesText);
        const siteTextHeight = (siteTextDimensions && siteTextDimensions.h) ? siteTextDimensions.h : 0;
        yPos += 15 + siteTextHeight;

        yPos = addSectionHeader('Key Performance Indicators', yPos);

        const boxWidth = 42;
        const boxHeight = 25;
        const boxSpacing = 3;

        addMetricBox(20, yPos, boxWidth, boxHeight, 'Total Incidents', metrics.totalIncidents, REPORT_COLORS.orange);
        addMetricBox(20 + boxWidth + boxSpacing, yPos, boxWidth, boxHeight, 'Recordable Cases', metrics.recordableIncidents, REPORT_COLORS.red);
        addMetricBox(20 + 2 * (boxWidth + boxSpacing), yPos, boxWidth, boxHeight, 'High Risk Near Miss', metrics.highRiskNearMiss, REPORT_COLORS.lightBlue);
        addMetricBox(20 + 3 * (boxWidth + boxSpacing), yPos, boxWidth, boxHeight, 'TRIR', metrics.trir, REPORT_COLORS.darkBlue);

        yPos += boxHeight + 10;

        const nmRatioDisplay = metrics.nmRatio === 'N/A' ? 'N/A' : `${metrics.nmRatio}:1`;
        addMetricBox(20, yPos, boxWidth, boxHeight, 'Near Miss Ratio', nmRatioDisplay, REPORT_COLORS.green);
        addMetricBox(20 + boxWidth + boxSpacing, yPos, boxWidth, boxHeight, 'Avg Days Lost', metrics.avgDaysLost, REPORT_COLORS.gray);
        addMetricBox(20 + 2 * (boxWidth + boxSpacing), yPos, boxWidth, boxHeight, 'Open Investigations', metrics.openInvestigations, REPORT_COLORS.orange);
        addMetricBox(20 + 3 * (boxWidth + boxSpacing), yPos, boxWidth, boxHeight, 'Sites w/ Incidents', totalSites, REPORT_COLORS.darkBlue);

        yPos += boxHeight + 15;

        yPos = addSectionHeader('Site Performance Breakdown', yPos);

        const siteTableData = Object.entries(metrics.siteData)
            .sort(([, a], [, b]) => b.total - a.total)
            .map(([site, data]) => {
                const injuryRate = data.total > 0 ? ((data.injuries / data.total) * 100).toFixed(1) : '0.0';
                const riskLevel = data.injuries >= 3 ? 'High Risk' :
                    data.injuries >= 1 ? 'Medium Risk' : 'On Track';
                const riskColor = data.injuries >= 3 ? 'üî¥' :
                    data.injuries >= 1 ? 'üü°' : 'üü¢';
                return [
                    site,
                    data.injuries.toString(),
                    data.nearMisses.toString(),
                    data.total.toString(),
                    `${injuryRate}%`,
                    `${riskColor} ${riskLevel}`
                ];
            });

        doc.autoTable({
            startY: yPos,
            head: [['Site', 'Injuries', 'Near Miss', 'Total', 'Injury Rate', 'Status']],
            body: siteTableData,
            theme: 'grid',
            headStyles: {
                fillColor: hexToRgb(REPORT_COLORS.darkBlue),
                textColor: [255, 255, 255],
                fontSize: 10
            },
            bodyStyles: { fontSize: 9 },
            columnStyles: {
                0: { cellWidth: 40 },
                1: { cellWidth: 20, halign: 'center' },
                2: { cellWidth: 20, halign: 'center' },
                3: { cellWidth: 20, halign: 'center' },
                4: { cellWidth: 30, halign: 'center' },
                5: { cellWidth: 40 }
            },
            margin: { left: 20, right: 20 }
        });

        yPos = doc.lastAutoTable.finalY + 15;

        yPos = addSectionHeader('Primary Root Causes', yPos);

        const rootCauseData = metrics.topRootCauses.map(([cause, count]) => [
            cause.length > 50 ? `${cause.substring(0, 47)}...` : cause,
            count.toString(),
            metrics.totalIncidents > 0 ? `${((count / metrics.totalIncidents) * 100).toFixed(1)}%` : '0.0%'
        ]);

        doc.autoTable({
            startY: yPos,
            head: [['Root Cause', 'Count', 'Percentage']],
            body: rootCauseData,
            theme: 'grid',
            headStyles: {
                fillColor: hexToRgb(REPORT_COLORS.darkBlue),
                textColor: [255, 255, 255],
                fontSize: 10
            },
            bodyStyles: { fontSize: 9 },
            columnStyles: {
                0: { cellWidth: 90 },
                1: { cellWidth: 30, halign: 'center' },
                2: { cellWidth: 30, halign: 'center' }
            },
            margin: { left: 20, right: 20 }
        });

        doc.addPage();
        currentPage++;
        addHeader(currentPage);
        yPos = 35;

        yPos = addSectionHeader('High-Priority Incident Details (Last 2 Weeks)', yPos);

        if (metrics.recentIncidents.length > 0) {
            const incidentTableData = metrics.recentIncidents.map(incident => {
                const isInjury = Boolean(incident.case_number);
                const incidentDate = new Date(incident.incident_date || incident.nearmiss_date);
                const dateLabel = isNaN(incidentDate) ? 'Unknown' : incidentDate.toLocaleDateString();
                const site = incident.site || 'Unknown';
                const severity = incident.severity || incident.potential_severity || 'Unknown';
                const type = isInjury ? 'Injury' : 'Near Miss';
                const status = !incident.rca_primary_cause || incident.rca_primary_cause === 'Not Determined'
                    ? 'Investigation Open'
                    : 'Root Cause Identified';
                const description = incident.initial_info_incident_description ||
                    incident.initial_info_nearmiss_type ||
                    incident.description ||
                    'No description available';
                const summary = description.length > 90 ? `${description.substring(0, 87)}...` : description;

                return [dateLabel, site, type, severity, status, summary];
            });

            doc.autoTable({
                startY: yPos,
                head: [['Date', 'Site', 'Type', 'Severity', 'Investigation', 'Summary']],
                body: incidentTableData,
                theme: 'grid',
                headStyles: {
                    fillColor: hexToRgb(REPORT_COLORS.darkBlue),
                    textColor: [255, 255, 255],
                    fontSize: 10
                },
                bodyStyles: { fontSize: 8 },
                columnStyles: {
                    0: { cellWidth: 22 },
                    1: { cellWidth: 35 },
                    2: { cellWidth: 20, halign: 'center' },
                    3: { cellWidth: 20, halign: 'center' },
                    4: { cellWidth: 35 },
                    5: { cellWidth: 38 }
                },
                margin: { left: 20, right: 20 }
            });

            yPos = doc.lastAutoTable.finalY + 15;
        } else {
            doc.setTextColor(...hexToRgb(REPORT_COLORS.green));
            doc.setFont('helvetica', 'normal');
            doc.setFontSize(12);
            doc.text('No high-priority incidents in the last 2 weeks', 20, yPos + 12);
            yPos += 25;
        }

        yPos = addSectionHeader('Monthly Trend Analysis', yPos);

        const monthlyTrendRows = metrics.monthlyTrend.slice(0, 6).map(data => {
            const ratioText = data.ratio === 'N/A' ? 'N/A' : `${data.ratio}:1`;
            return [
                data.label,
                data.injuries.toString(),
                data.nearMisses.toString(),
                data.total.toString(),
                ratioText
            ];
        });

        if (monthlyTrendRows.length > 0) {
            doc.autoTable({
                startY: yPos,
                head: [['Month', 'Injuries', 'Near Miss', 'Total', 'NM Ratio']],
                body: monthlyTrendRows,
                theme: 'grid',
                headStyles: {
                    fillColor: hexToRgb(REPORT_COLORS.darkBlue),
                    textColor: [255, 255, 255],
                    fontSize: 10
                },
                bodyStyles: { fontSize: 9 },
                columnStyles: {
                    0: { cellWidth: 50 },
                    1: { cellWidth: 25, halign: 'center' },
                    2: { cellWidth: 25, halign: 'center' },
                    3: { cellWidth: 25, halign: 'center' },
                    4: { cellWidth: 35, halign: 'center' }
                },
                margin: { left: 20, right: 20 }
            });

            yPos = doc.lastAutoTable.finalY + 15;
        } else {
            doc.setTextColor(...hexToRgb(REPORT_COLORS.gray));
            doc.setFont('helvetica', 'normal');
            doc.setFontSize(10);
            doc.text('Monthly trend data unavailable for the selected period', 20, yPos + 10);
            yPos += 25;
        }

        yPos = addSectionHeader('Data Insights Summary', yPos);

        doc.setTextColor(...hexToRgb(REPORT_COLORS.darkBlue));
        doc.setFont('helvetica', 'normal');
        doc.setFontSize(9);

        const insights = [];
        if (metrics.nmRatio === 'N/A') {
            insights.push('Near miss ratio cannot be calculated because no injuries were reported.');
        } else {
            insights.push(`Near miss ratio stands at ${metrics.nmRatio}:1 across the reporting period.`);
        }
        insights.push(`Average days lost per injury: ${metrics.avgDaysLost} days.`);
        insights.push(`${metrics.openInvestigations} investigations are pending root cause determination.`);
        if (metrics.topRootCauses.length > 0) {
            const [topCause, count] = metrics.topRootCauses[0];
            insights.push(`Leading root cause: ${topCause} (${count} cases).`);
        }
        const sortedSitesForInsights = Object.entries(metrics.siteData).sort(([, a], [, b]) => b.total - a.total);
        if (sortedSitesForInsights.length > 0) {
            const [topSite, data] = sortedSitesForInsights[0];
            insights.push(`${topSite} recorded the highest incident volume with ${data.total} total cases.`);
        }
        if (metrics.monthlyTrend.length > 0) {
            const latestMonth = metrics.monthlyTrend[0];
            insights.push(`${latestMonth.label} logged ${latestMonth.total} total events (${latestMonth.injuries} injuries, ${latestMonth.nearMisses} near misses).`);
        }
        if (metrics.totalDaysLost && Number(metrics.totalDaysLost) > 0) {
            insights.push(`Total lost time across injuries reached ${metrics.totalDaysLost} days.`);
        }

        let insightY = yPos;
        insights.forEach(insight => {
            const insightText = doc.splitTextToSize(`‚Ä¢ ${insight}`, 170);
            doc.text(insightText, 22, insightY + 6);
            insightY += insightText.length * 5 + 2;
        });

        yPos = insightY + 5;

        const fileName = `Safety_WBR_Report_CW${currentWeek}_${currentYear}.pdf`;
        doc.save(fileName);

        showStatus('Safety WBR Report generated successfully!', 'success');
    } catch (error) {
        console.error('Safety WBR report generation error:', error);
        showStatus('Error generating Safety WBR Report: ' + error.message, 'error');
    }
}

function getReportPeriod() {
    const allData = [...state.injury.filteredData, ...state.nearMiss.filteredData];
    if (allData.length === 0) return 'No data available';
    
    const dates = allData
        .map(r => r.parsedDate)
        .filter(d => d && !isNaN(d))
        .sort((a, b) => a - b);
    
    if (dates.length === 0) return 'Date range not available';
    
    const startDate = dates[0].toLocaleDateString('en-GB');
    const endDate = dates[dates.length - 1].toLocaleDateString('en-GB');
    
    return `${startDate} - ${endDate}`;
}

function getSelectedSites(type) {
    let site = '';
    if (type === 'injury') {
        site = document.getElementById('injurySiteFilter')?.value;
    } else if (type === 'nearmiss') {
        site = document.getElementById('nearMissSiteFilter')?.value;
    } else {
        site = document.getElementById('combinedSiteFilter')?.value ||
               document.getElementById('overviewSiteFilter')?.value;
    }
    return site || 'All Sites';
}

function getKeyFinding(data, type) {
    if (data.length === 0) return 'No data available for analysis';
    
    if (type === 'injury') {
        const severityA = data.filter(r => r.severity === 'A').length;
        const recordable = data.filter(r => r.recordable === 1).length;
        const recordableRate = ((recordable / data.length) * 100).toFixed(1);
        
        if (severityA > 0) {
            return `${severityA} critical severity incidents require immediate attention`;
        }
        if (recordableRate > 50) {
            return `High recordable rate (${recordableRate}%) indicates need for enhanced safety measures`;
        }
        return `Stable safety performance with ${data.length} total incidents`;
    } else {
        const highRisk = data.filter(r => parseFloat(r.risk) >= 7).length;
        const repeatLocations = {};
        data.forEach(r => {
            repeatLocations[r.location] = (repeatLocations[r.location] || 0) + 1;
        });
        const hotspots = Object.values(repeatLocations).filter(count => count >= 3).length;
        
        if (highRisk > 5) {
            return `${highRisk} high-risk near misses indicate potential for serious incidents`;
        }
        if (hotspots > 0) {
            return `${hotspots} locations with repeated near misses require targeted interventions`;
        }
        return `Good hazard identification with ${data.length} near misses reported`;
    }
}

function getAverageSeverity(data) {
    const severityMap = { 'A': 4, 'B': 3, 'C': 2, 'D': 1 };
    const severitySum = data.reduce((sum, r) => sum + (severityMap[r.severity] || 0), 0);
    const avgValue = data.length > 0 ? severitySum / data.length : 0;
    
    if (avgValue >= 3.5) return 'Critical';
    if (avgValue >= 2.5) return 'High';
    if (avgValue >= 1.5) return 'Medium';
    return 'Low';
}

function calculateRiskMatrixSummary(data) {
    const riskScores = data.map(r => {
        if (r.risk) return parseFloat(r.risk) * 2.5; // Scale to 25
        const severityMap = { 'A': 5, 'B': 4, 'C': 3, 'D': 2, 'Unknown': 1 };
        const likelihoodMap = { 
            'Rare': 1, 
            'Unlikely': 2, 
            'Possible': 3, 
            'Likely': 4, 
            'Almost Certain': 5 
        };
        const severity = severityMap[r.severity] || 1;
        const likelihood = likelihoodMap[r.standardized_likelihood] || 3;
        return severity * likelihood;
    });
    
    const critical = riskScores.filter(s => s >= 16).length;
    const high = riskScores.filter(s => s >= 11 && s < 16).length;
    const medium = riskScores.filter(s => s >= 6 && s < 11).length;
    const low = riskScores.filter(s => s < 6).length;
    const total = riskScores.length || 1;
    
    return {
        critical,
        high,
        medium,
        low,
        criticalPercent: ((critical / total) * 100).toFixed(1),
        highPercent: ((high / total) * 100).toFixed(1),
        mediumPercent: ((medium / total) * 100).toFixed(1),
        lowPercent: ((low / total) * 100).toFixed(1)
    };
}

function calculateExecutiveSummaryMetrics() {
    const allData = [...state.injury.filteredData, ...state.nearMiss.filteredData];
    const total = allData.length;
    const recordable = allData.filter(r => r.recordable === 1).length;
    const highSeverity = allData.filter(r => r.severity === 'A' || r.severity === 'B').length;
    const lastRecordable = allData
        .filter(r => r.recordable === 1 && r.parsedDate && !isNaN(r.parsedDate))
        .sort((a, b) => b.parsedDate - a.parsedDate)[0];
    const daysSinceRecordable = lastRecordable
        ? Math.floor((Date.now() - lastRecordable.parsedDate) / (1000 * 60 * 60 * 24))
        : 'N/A';

    const monthly = {};
    const rootCauseCounts = {};
    allData.forEach(row => {
        if (row.parsedDate && !isNaN(row.parsedDate)) {
            const key = `${row.parsedDate.getFullYear()}-${String(row.parsedDate.getMonth() + 1).padStart(2, '0')}`;
            monthly[key] = (monthly[key] || 0) + 1;
        }
        const cause = row.rootCause || 'Unknown';
        rootCauseCounts[cause] = (rootCauseCounts[cause] || 0) + 1;
    });

    const trend = Object.entries(monthly)
        .sort((a, b) => a[0].localeCompare(b[0]))
        .slice(-6);
    const topRootCauses = Object.entries(rootCauseCounts)
        .sort((a, b) => b[1] - a[1])
        .slice(0, 5);

    return {
        total,
        recordable,
        highSeverity,
        daysSinceRecordable,
        trend,
        topRootCauses
    };
}

function addToReportHistory(type, fileName) {
    const historyContainer = document.getElementById('reportHistory');
    if (!historyContainer) return;
    
    const timestamp = new Date().toLocaleString();
    const reportEntry = `
        <div style="padding: 1rem; border-bottom: 1px solid var(--bg-secondary);">
            <strong>${fileName}</strong><br>
            <span style="color: var(--text-secondary); font-size: 0.9rem;">
                Type: ${type.charAt(0).toUpperCase() + type.slice(1)} | Generated: ${timestamp}
            </span>
        </div>
    `;
    
    if (historyContainer.innerHTML.includes('No reports generated yet')) {
        historyContainer.innerHTML = reportEntry;
    } else {
        historyContainer.innerHTML = reportEntry + historyContainer.innerHTML;
    }
}

// Load Sample Data
function loadSampleData() {
    showStatus('Loading sample data...', 'info');
    
    // Sample injury data
    const sampleInjuryData = generateSampleInjuryData();
    state.injury.rawData = sampleInjuryData;
    processInjuryData();
    populateInjuryFilters();
    applyFilters('injury');
    calculateQualityMetrics('injury');
    
    // Sample near miss data
    const sampleNearMissData = generateSampleNearMissData();
    state.nearMiss.rawData = sampleNearMissData;
    processNearMissData();
    populateNearMissFilters();
    applyFilters('nearmiss');
    calculateQualityMetrics('nearmiss');
    
    updateOverview();
    initializeChartSelections();
    showStatus('Sample data loaded successfully!', 'success');
}

function generateSampleInjuryData() {
    const sites = ['VIE1', 'VIE2', 'VIE3', 'VIE4', 'VIE5'];
    const bodyParts = ['Back', 'Hand', 'Shoulder', 'Knee', 'Ankle', 'Wrist', 'Finger', 'Eye'];
    const types = ['Strain/Sprain', 'Cut/Laceration', 'Contusion', 'Fracture', 'Burn'];
    const severities = ['A', 'B', 'C', 'D'];
    const rootCauses = ['Manual Handling', 'Slip/Trip/Fall', 'Equipment Malfunction', 'Ergonomic', 'Process Deviation'];
    const processes = ['Stow', 'Pick', 'Pack', 'Receive', 'Ship', 'ICQA'];
    
    const data = [];
    const startDate = new Date('2024-01-01');
    
    for (let i = 0; i < 50; i++) {
        const date = new Date(startDate);
        date.setDate(date.getDate() + Math.floor(Math.random() * 365));
        
        const severity = severities[Math.floor(Math.random() * severities.length)];
        const isRecordable = severity === 'A' || severity === 'B' || Math.random() > 0.7;
        const dafwDays = isRecordable && Math.random() > 0.5 ? Math.floor(Math.random() * 30) : 0;
        
        data.push({
            case_number: `CASE-2024-${String(i + 1).padStart(3, '0')}`,
            incident_date: date.toISOString().split('T')[0],
            incident_time: `${Math.floor(Math.random() * 24).toString().padStart(2, '0')}:${Math.floor(Math.random() * 60).toString().padStart(2, '0')}`,
            site: sites[Math.floor(Math.random() * sites.length)],
            initial_info_principal_body_part: bodyParts[Math.floor(Math.random() * bodyParts.length)],
            type: types[Math.floor(Math.random() * types.length)],
            severity: severity,
            potential_severity: severity,
            recordable: isRecordable ? 1 : 0,
            initial_info_incident_on_the_road: Math.random() > 0.9,
            total_dafw_days: dafwDays,
            total_rwa_days: isRecordable && Math.random() > 0.8 ? Math.floor(Math.random() * 10) : 0,
            rca_primary_cause: rootCauses[Math.floor(Math.random() * rootCauses.length)],
            rca_contributing_factor_category: 'Human Factors',
            initial_info_process_path: processes[Math.floor(Math.random() * processes.length)],
            initial_info_incident_description: 'Sample incident description for demonstration purposes',
            status: 'Closed',
            austin_url: `https://safety.amazon.com/austin/case-${i + 1}`,
            initial_risk_assessment_likeliness: ['Rare', 'Unlikely', 'Possible', 'Likely', 'Almost Certain'][Math.floor(Math.random() * 5)]
        });
    }
    
    return data;
}

function generateSampleNearMissData() {
    const sites = ['VIE1', 'VIE2', 'VIE3', 'VIE4', 'VIE5'];
    const locations = ['Dock Door 1', 'Aisle P-1-A', 'Break Room', 'Parking Lot', 'Conveyor Belt 3', 'Mezzanine Level 2'];
    const impacts = ['Struck By', 'Caught Between', 'Fall', 'Ergonomic', 'Environmental'];
    const severities = ['A', 'B', 'C', 'D'];
    const likelihoods = ['Rare', 'Unlikely', 'Possible', 'Likely', 'Almost Certain'];
    const processes = ['Stow', 'Pick', 'Pack', 'Receive', 'Ship', 'ICQA'];
    
    const data = [];
    const startDate = new Date('2024-01-01');
    
    for (let i = 0; i < 100; i++) {
        const date = new Date(startDate);
        date.setDate(date.getDate() + Math.floor(Math.random() * 365));
        
        const severity = severities[Math.floor(Math.random() * severities.length)];
        const likelihood = likelihoods[Math.floor(Math.random() * likelihoods.length)];
        
        data.push({
            incident_id: `NM-${sites[i % sites.length]}-2024-${String(i + 1).padStart(3, '0')}`,
            nearmiss_date: date.toISOString().split('T')[0],
            site: sites[Math.floor(Math.random() * sites.length)],
            initial_info_location_event: locations[Math.floor(Math.random() * locations.length)],
            initial_info_process_path: processes[Math.floor(Math.random() * processes.length)],
            initial_info_primary_impact: impacts[Math.floor(Math.random() * impacts.length)],
            potential_severity: severity,
            initial_risk_assessment_likeliness: likelihood,
            risk: calculateRiskScore({ severity, standardized_likelihood: likelihood }),
            rca_contributing_factor_category: 'Environmental Factors',
            initial_info_incident_description: 'Sample near miss description for demonstration purposes',
            rca_primary_cause: 'Hazardous Condition',
            status: 'Closed'
        });
    }
    
    return data;
}

// Refresh Dashboard
function refreshDashboard(type) {
    showStatus('Refreshing dashboard...', 'info');
    
    if (type === 'injury') {
        updateInjuryDashboard();
        updateInjuryTable();
        updateInjuryCharts();
    } else if (type === 'nearmiss') {
        updateNearMissDashboard();
        updateNearMissTable();
        updateNearMissCharts();
    }
    
    updateOverview();
    updateKPIs();
    
    setTimeout(() => {
        showStatus('Dashboard refreshed!', 'success');
    }, 500);
}

// Update All Charts (for theme change)
function updateAllCharts() {
    // Update all injury charts
    if (state.injury.filteredData.length > 0) {
        updateInjuryCharts();
        updateInjuryAdvancedAnalytics();
    }
    
    // Update all near miss charts
    if (state.nearMiss.filteredData.length > 0) {
        updateNearMissCharts();
        updateNearMissAdvancedAnalytics();
    }
    
    // Update overview charts
    updateOverviewCharts();
    
    // Update combined charts
    if (state.currentModule === 'combined') {
        updateCombinedCharts();
    }
}

// Status Messages
function showStatus(message, type = 'info') {
    const container = document.getElementById('statusContainer');
    if (!container) return;
    
    const statusDiv = document.createElement('div');
    statusDiv.className = `status-message status-${type}`;
    
    const icon = type === 'success' ? '‚úÖ' : 
                type === 'error' ? '‚ùå' : 
                type === 'warning' ? '‚ö†Ô∏è' : '‚ÑπÔ∏è';
    
    statusDiv.innerHTML = `
        <span>${icon}</span>
        <span>${message}</span>
    `;
    
    container.appendChild(statusDiv);
    
    setTimeout(() => {
        statusDiv.style.opacity = '0';
        setTimeout(() => {
            statusDiv.remove();
        }, 300);
    }, 3000);
}

// Event Listeners
function setupEventListeners() {
    // Close modal when clicking outside
    window.onclick = function(event) {
        const detailModal = document.getElementById('detailModal');
        const helpModal = document.getElementById('helpModal');
        if (event.target === detailModal) {
            closeModal();
        }
        if (event.target === helpModal) {
            closeHelpModal();
        }
    };
    
    // Keyboard shortcuts
    document.addEventListener('keydown', function(event) {
        // Ctrl/Cmd + S to save/export
        if ((event.ctrlKey || event.metaKey) && event.key === 's') {
            event.preventDefault();
            exportToExcel('all');
        }
        
        // Escape to close modal
        if (event.key === 'Escape') {
            closeModal();
            closeHelpModal();
        }
        
        // Ctrl/Cmd + P to generate PDF
        if ((event.ctrlKey || event.metaKey) && event.key === 'p') {
            event.preventDefault();
            generateWBRReport();
        }
    });
    
    // Window resize handler
    let resizeTimeout;
    window.addEventListener('resize', function() {
        clearTimeout(resizeTimeout);
        resizeTimeout = setTimeout(function() {
            // Update charts on resize
            Chart.helpers.each(Chart.instances, function(instance) {
                instance.resize();
            });
        }, 250);
    });
    
    // Print handler
    window.addEventListener('beforeprint', function() {
        // Add print-specific classes
        document.body.classList.add('printing');
    });
    
    window.addEventListener('afterprint', function() {
        // Remove print-specific classes
        document.body.classList.remove('printing');
    });

    document.querySelectorAll('.help-tab').forEach(tab => {
        tab.addEventListener('click', () => switchHelpSection(tab.dataset.section));
    });
}

// Initialize tooltips and other UI enhancements
document.addEventListener('DOMContentLoaded', function() {
    // Add smooth scroll behavior
    document.documentElement.style.scrollBehavior = 'smooth';
    
    // Initialize any additional UI components
    initializeUIComponents();
});

function initializeUIComponents() {
    // Add loading animation to buttons
    document.querySelectorAll('.btn').forEach(button => {
        button.addEventListener('click', function() {
            if (!this.classList.contains('loading')) {
                this.classList.add('loading');
                setTimeout(() => {
                    this.classList.remove('loading');
                }, 1000);
            }
        });
    });
    
    // Add hover effects to metric cards
    document.querySelectorAll('.metric-card').forEach(card => {
        card.addEventListener('mouseenter', function() {
            this.style.transform = 'translateY(-4px) scale(1.02)';
        });
        
        card.addEventListener('mouseleave', function() {
            this.style.transform = 'translateY(0) scale(1)';
        });
    });
}

// Utility function to format dates
function formatDate(date) {
    if (!date) return 'N/A';
    const d = new Date(date);
    if (isNaN(d)) return 'N/A';
    return d.toLocaleDateString('en-GB');
}

// Utility function to format numbers
function formatNumber(num) {
    if (num === null || num === undefined) return '0';
    return num.toLocaleString();
}

// Export individual functions for module pattern
window.SafetyAnalytics = {
    loadSampleData,
    exportToExcel,
    generatePDFReport,
    generateInjuryReport,
    generateNearMissReport,
    generateWBRReport,
    refreshDashboard,
    switchModule,
    toggleTheme,
    calculateSafetyKPIs,
    generateSiteComparison,
    createProcessPathMatrix,
    calculateTrendIndicators,
    analyzePrimaryImpacts
};

// Expose functions globally for inline event handlers
// Without these assignments, functions defined in this script are not available
// on the global window object when called directly from HTML attributes like
// onclick="switchModule('injury')". Explicitly attach them to window to
// prevent ReferenceError exceptions when the page loads. Only functions
// referenced directly in HTML markup are exposed below.
window.switchModule = switchModule;
window.toggleTheme = toggleTheme;
window.loadSampleData = loadSampleData;
window.exportToExcel = exportToExcel;
window.generatePDFReport = generatePDFReport;
window.generateInjuryReport = generateInjuryReport;
window.generateNearMissReport = generateNearMissReport;
window.generateWBRReport = generateWBRReport;
window.refreshDashboard = refreshDashboard;
// Functions used by various buttons and interactions
window.addNewAction = addNewAction;
window.changePage = changePage;
window.changeTimelinePage = changeTimelinePage;
window.closeModal = closeModal;
window.exportDashboard = exportDashboard;
window.exportInjuryData = exportInjuryData;
window.exportNearMissData = exportNearMissData;
window.exportTable = exportTable;
window.exportNearMissDuplicatesPDF = exportNearMissDuplicatesPDF;
window.captureAnalysisView = captureAnalysisView;
window.captureChart = captureChart;
window.captureChartWithTitle = captureChartWithTitle;
window.markActionComplete = markActionComplete;
window.switchInjuryView = switchInjuryView;
window.switchNearMissView = switchNearMissView;
window.viewDetails = viewDetails;
window.showDuplicateDetails = showDuplicateDetails;
window.showAllDuplicates = showAllDuplicates;
window.openHelpModal = openHelpModal;
window.closeHelpModal = closeHelpModal;
window.switchHelpSection = switchHelpSection;
window.tryNow = tryNow;

// Expose combined filter handler so it can be invoked from the HTML
window.applyCombinedFilters = applyCombinedFilters;
window.calculateSafetyKPIs = calculateSafetyKPIs;
window.generateSiteComparison = generateSiteComparison;
window.createProcessPathMatrix = createProcessPathMatrix;
window.calculateTrendIndicators = calculateTrendIndicators;
window.analyzePrimaryImpacts = analyzePrimaryImpacts;

// Log initialization complete
console.log('Safety Analytics Platform initialized successfully');
console.log('Version: 2.0 | ¬© 2024 Amazon WHS Austria');
console.log('For support, contact: Erwin Esener @eeesener');
 </script>
