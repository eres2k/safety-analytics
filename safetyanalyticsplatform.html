<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Safety Analytics Platform - Amazon WHS Austria | Developed by Erwin Esener @eeesener</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.0/papaparse.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/4.4.0/chart.umd.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.31/jspdf.plugin.autotable.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <style>
        :root {
            --amazon-orange: #FF9900;
            --amazon-orange-dark: #e88600;
            --amazon-blue: #232F3E;
            --amazon-blue-dark: #37475A;
            --amazon-yellow: #FFD814;
            --success: #4CAF50;
            --warning: #FFC107;
            --danger: #FF5722;
            --critical: #B71C1C;
            --bg-primary: #ffffff;
            --bg-secondary: #f5f5f5;
            --text-primary: #212121;
            --text-secondary: #757575;
            --shadow: rgba(0,0,0,0.08);
            --shadow-hover: rgba(0,0,0,0.12);
            --border-radius: 8px;
            --transition: all 0.2s ease;
            --spacing-xs: 0.25rem;
            --spacing-sm: 0.5rem;
            --spacing-md: 1rem;
            --spacing-lg: 1.5rem;
            --spacing-xl: 2rem;
        }

        [data-theme="dark"] {
            --bg-primary: #1a1a1a;
            --bg-secondary: #2d2d2d;
            --text-primary: #ffffff;
            --text-secondary: #b0b0b0;
            --shadow: rgba(255,255,255,0.05);
            --shadow-hover: rgba(255,255,255,0.1);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Amazon Ember', sans-serif;
            background-color: var(--bg-secondary);
            color: var(--text-primary);
            line-height: 1.5;
            transition: var(--transition);
        }

        /* Compact Header */
        .header {
            background: linear-gradient(90deg, var(--amazon-blue) 0%, var(--amazon-blue-dark) 100%);
            color: white;
            padding: 0.75rem 0;
            position: sticky;
            top: 0;
            z-index: 100;
            box-shadow: 0 2px 8px var(--shadow);
        }

        .header-content {
            max-width: 1400px;
            margin: 0 auto;
            padding: 0 var(--spacing-md);
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: var(--spacing-md);
        }

        .header-title {
            display: flex;
            align-items: center;
            gap: var(--spacing-sm);
        }

        .amazon-logo {
            height: 32px;
            display: flex;
            align-items: center;
            font-weight: bold;
            font-size: 1.5rem;
            color: var(--amazon-orange);
        }

        .header h1 {
            font-size: 1.25rem;
            font-weight: 400;
            display: flex;
            align-items: center;
            gap: var(--spacing-sm);
        }

        .header-subtitle {
            font-size: 0.85rem;
            opacity: 0.9;
            display: flex;
            align-items: center;
            gap: var(--spacing-xs);
        }

        .header-actions {
            display: flex;
            gap: var(--spacing-sm);
            align-items: center;
        }

        /* Mode Toggle */
        .mode-toggle {
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 20px;
            padding: 0.4rem 0.8rem;
            color: white;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: var(--spacing-xs);
            transition: var(--transition);
            font-size: 0.85rem;
        }

        .mode-toggle:hover {
            background: rgba(255,255,255,0.2);
        }

        /* Compact Navigation */
        .nav-container {
            background: var(--bg-primary);
            box-shadow: 0 1px 4px var(--shadow);
            position: sticky;
            top: 56px;
            z-index: 90;
        }

        .nav-tabs {
            max-width: 1400px;
            margin: 0 auto;
            padding: 0 var(--spacing-md);
            display: flex;
            gap: 0;
            overflow-x: auto;
            scrollbar-width: thin;
        }

        .nav-tab {
            padding: 0.6rem 1.2rem;
            cursor: pointer;
            transition: var(--transition);
            white-space: nowrap;
            font-weight: 500;
            font-size: 0.9rem;
            position: relative;
            background: transparent;
            color: var(--text-secondary);
            border-bottom: 3px solid transparent;
        }

        .nav-tab:hover {
            color: var(--amazon-orange);
            background: var(--bg-secondary);
        }

        .nav-tab.active {
            color: var(--amazon-orange);
            border-bottom-color: var(--amazon-orange);
            font-weight: 600;
        }

        .nav-tab-icon {
            font-size: 1rem;
            margin-right: var(--spacing-xs);
        }

        /* Container */
        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: var(--spacing-lg) var(--spacing-md);
        }

        /* Compact Cards */
        .card {
            background: var(--bg-primary);
            border-radius: var(--border-radius);
            padding: var(--spacing-md);
            box-shadow: 0 1px 4px var(--shadow);
            transition: var(--transition);
        }

        .card:hover {
            box-shadow: 0 4px 12px var(--shadow-hover);
        }

        /* Compact Metrics Grid */
        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: var(--spacing-md);
            margin-bottom: var(--spacing-lg);
        }

        .metric-card {
            background: var(--bg-primary);
            border-radius: var(--border-radius);
            padding: var(--spacing-md);
            position: relative;
            overflow: hidden;
            box-shadow: 0 1px 4px var(--shadow);
            transition: var(--transition);
            border-left: 4px solid var(--amazon-orange);
        }

        .metric-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px var(--shadow-hover);
        }

        .metric-icon {
            width: 36px;
            height: 36px;
            background: linear-gradient(135deg, var(--amazon-orange), var(--amazon-orange-dark));
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            margin-bottom: var(--spacing-sm);
        }

        .metric-value {
            font-size: 1.8rem;
            font-weight: 700;
            color: var(--text-primary);
            margin: var(--spacing-xs) 0;
        }

        .metric-label {
            color: var(--text-secondary);
            font-size: 0.85rem;
        }

        .metric-trend {
            position: absolute;
            top: var(--spacing-sm);
            right: var(--spacing-sm);
            font-size: 0.8rem;
            padding: 0.2rem 0.5rem;
            border-radius: 12px;
            background: rgba(76, 175, 80, 0.1);
            color: var(--success);
        }

        .metric-trend.down {
            background: rgba(255, 87, 34, 0.1);
            color: var(--danger);
        }

        /* Compact Control Panel */
        .control-panel {
            background: var(--bg-primary);
            border-radius: var(--border-radius);
            padding: var(--spacing-md);
            margin-bottom: var(--spacing-lg);
            box-shadow: 0 1px 4px var(--shadow);
        }

        .control-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: var(--spacing-md);
            flex-wrap: wrap;
            gap: var(--spacing-sm);
        }

        .control-title {
            font-size: 1.25rem;
            font-weight: 600;
            color: var(--text-primary);
        }

        /* Compact Buttons */
        .btn {
            padding: 0.5rem 1rem;
            border: none;
            border-radius: 4px;
            font-size: 0.85rem;
            font-weight: 500;
            cursor: pointer;
            transition: var(--transition);
            display: inline-flex;
            align-items: center;
            gap: var(--spacing-xs);
        }

        .btn-primary {
            background: var(--amazon-orange);
            color: white;
        }

        .btn-primary:hover {
            background: var(--amazon-orange-dark);
            transform: translateY(-1px);
        }

        .btn-secondary {
            background: var(--amazon-blue);
            color: white;
        }

        .btn-secondary:hover {
            background: var(--amazon-blue-dark);
            transform: translateY(-1px);
        }

        .btn-outline {
            background: transparent;
            border: 1px solid var(--amazon-orange);
            color: var(--amazon-orange);
        }

        .btn-outline:hover {
            background: var(--amazon-orange);
            color: white;
        }

        .btn-sm {
            padding: 0.3rem 0.6rem;
            font-size: 0.8rem;
        }

        /* Compact File Upload */
        .upload-area {
            border: 2px dashed var(--amazon-orange);
            border-radius: var(--border-radius);
            padding: var(--spacing-lg);
            text-align: center;
            transition: var(--transition);
            background: rgba(255, 153, 0, 0.02);
            margin-bottom: var(--spacing-md);
        }

        .upload-area:hover {
            border-color: var(--amazon-orange-dark);
            background: rgba(255, 153, 0, 0.05);
        }

        .upload-area.dragging {
            background: rgba(255, 153, 0, 0.1);
            border-color: var(--amazon-orange);
        }

        .file-input {
            display: none;
        }

        .upload-label {
            display: inline-block;
            padding: 0.5rem 1.5rem;
            background: var(--amazon-orange);
            color: white;
            border-radius: 4px;
            cursor: pointer;
            transition: var(--transition);
            font-weight: 500;
            font-size: 0.9rem;
        }

        .upload-label:hover {
            background: var(--amazon-orange-dark);
        }

        /* Compact Filter Section */
        .filter-section {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
            gap: var(--spacing-sm);
            margin-bottom: var(--spacing-md);
        }

        .filter-group {
            display: flex;
            flex-direction: column;
            gap: var(--spacing-xs);
        }

        .filter-label {
            font-size: 0.8rem;
            font-weight: 500;
            color: var(--text-secondary);
        }

        .filter-input {
            padding: 0.4rem 0.6rem;
            border: 1px solid transparent;
            border-radius: 4px;
            background: var(--bg-secondary);
            color: var(--text-primary);
            transition: var(--transition);
            font-size: 0.85rem;
        }

        .filter-input:focus {
            outline: none;
            border-color: var(--amazon-orange);
            background: var(--bg-primary);
        }

        /* Quick Actions Bar */
        .quick-actions {
            display: flex;
            gap: var(--spacing-sm);
            flex-wrap: wrap;
        }

        /* Compact Charts Container */
        .charts-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(450px, 1fr));
            gap: var(--spacing-md);
            margin-bottom: var(--spacing-lg);
        }

        .chart-card {
            background: var(--bg-primary);
            border-radius: var(--border-radius);
            padding: var(--spacing-md);
            box-shadow: 0 1px 4px var(--shadow);
        }

        .chart-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: var(--spacing-sm);
            gap: var(--spacing-sm);
        }

        .chart-title {
            font-size: 1rem;
            font-weight: 600;
            color: var(--text-primary);
        }

        .chart-container {
            position: relative;
            height: 250px;
        }

        /* Data Table */
        .table-container {
            background: var(--bg-primary);
            border-radius: var(--border-radius);
            padding: var(--spacing-md);
            box-shadow: 0 1px 4px var(--shadow);
            overflow: hidden;
        }

        .table-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: var(--spacing-sm);
        }

        .table-wrapper {
            overflow-x: auto;
            margin: -var(--spacing-md);
            padding: var(--spacing-md);
        }

        table {
            width: 100%;
            border-collapse: collapse;
        }

        th {
            background: var(--amazon-blue);
            color: white;
            padding: 0.6rem;
            text-align: left;
            font-weight: 500;
            font-size: 0.85rem;
            position: sticky;
            top: 0;
            z-index: 10;
            white-space: nowrap;
        }

        td {
            padding: 0.5rem 0.6rem;
            border-bottom: 1px solid var(--bg-secondary);
            color: var(--text-primary);
            font-size: 0.85rem;
        }

        tr:hover {
            background: var(--bg-secondary);
        }

        /* Badges */
        .badge {
            display: inline-block;
            padding: 0.15rem 0.5rem;
            border-radius: 12px;
            font-size: 0.75rem;
            font-weight: 600;
        }

        .badge-success {
            background: rgba(76, 175, 80, 0.2);
            color: var(--success);
        }

        .badge-warning {
            background: rgba(255, 193, 7, 0.2);
            color: var(--warning);
        }

        .badge-danger {
            background: rgba(255, 87, 34, 0.2);
            color: var(--danger);
        }

        .badge-critical {
            background: rgba(183, 28, 28, 0.2);
            color: var(--critical);
        }

        .badge-info {
            background: rgba(33, 150, 243, 0.2);
            color: #2196F3;
        }

        /* Risk Matrix */
        .risk-matrix {
            display: grid;
            grid-template-columns: 60px repeat(5, 1fr);
            grid-template-rows: repeat(6, 60px);
            gap: 2px;
            max-width: 500px;
            margin: var(--spacing-lg) auto;
        }

        .matrix-cell {
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 600;
            color: white;
            cursor: pointer;
            transition: var(--transition);
            border-radius: 4px;
            font-size: 0.9rem;
        }

        .matrix-cell:hover {
            transform: scale(1.05);
            z-index: 10;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        }

        .matrix-label {
            background: var(--amazon-blue);
            color: white;
            font-size: 0.8rem;
            font-weight: 500;
        }

        .risk-low { background: var(--success); }
        .risk-medium { background: var(--warning); color: #333; }
        .risk-high { background: var(--danger); }
        .risk-critical { background: var(--critical); }

        /* Timeline */
        .timeline-container {
            background: var(--bg-primary);
            border-radius: var(--border-radius);
            padding: var(--spacing-md);
            box-shadow: 0 1px 4px var(--shadow);
        }

        .timeline-item {
            border-left: 3px solid var(--amazon-orange);
            padding-left: var(--spacing-lg);
            margin-bottom: var(--spacing-lg);
            position: relative;
        }

        .timeline-item::before {
            content: '';
            position: absolute;
            left: -6px;
            top: 0;
            width: 9px;
            height: 9px;
            border-radius: 50%;
            background: var(--amazon-orange);
        }

        .timeline-date {
            font-weight: 600;
            color: var(--amazon-orange);
            margin-bottom: var(--spacing-xs);
            font-size: 0.85rem;
        }

        .timeline-content {
            background: var(--bg-secondary);
            padding: var(--spacing-sm);
            border-radius: 4px;
            font-size: 0.85rem;
        }

        /* Quality Assessment Styles */
        .quality-score-card {
            background: linear-gradient(135deg, var(--amazon-blue) 0%, var(--amazon-blue-dark) 100%);
            color: white;
            border-radius: var(--border-radius);
            padding: var(--spacing-lg);
            text-align: center;
            margin-bottom: var(--spacing-lg);
            display: flex;
            justify-content: center;
        }

        .quality-score-value {
            font-size: 3rem;
            font-weight: 700;
            margin: 0;
        }

        .quality-metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: var(--spacing-md);
            margin-top: var(--spacing-md);
        }

        .quality-metric {
            background: rgba(255, 255, 255, 0.1);
            padding: var(--spacing-md);
            border-radius: var(--border-radius);
        }

        .quality-metrics-container {
            max-width: 800px;
            margin: 0 auto;
        }

        .quality-score-circle {
            width: 160px;
            height: 160px;
            border-radius: 50%;
            background: var(--bg-primary);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            margin: 0 auto;
            color: var(--text-primary);
            box-shadow: 0 2px 8px var(--shadow);
        }

        .quality-score-circle.success { border: 6px solid var(--success); }
        .quality-score-circle.warning { border: 6px solid var(--warning); }
        .quality-score-circle.danger { border: 6px solid var(--danger); }

        .quality-score-label {
            font-size: 0.875rem;
            color: var(--text-secondary);
            margin-top: var(--spacing-xs);
        }

        .quality-section {
            margin-top: var(--spacing-xl);
        }

        .duplicate-list {
            display: grid;
            gap: var(--spacing-sm);
            margin-top: var(--spacing-sm);
        }

        .duplicate-item {
            background: var(--bg-primary);
            padding: var(--spacing-sm);
            border-radius: var(--border-radius);
            box-shadow: 0 1px 3px var(--shadow);
        }

        .missing-fields-chart {
            height: 300px;
        }

        .recommendations-list {
            display: grid;
            gap: var(--spacing-sm);
        }

        .word-heatmap {
            display: flex;
            flex-wrap: wrap;
            gap: var(--spacing-xs);
        }

        .word-heatmap .heatmap-item {
            padding: var(--spacing-xs) var(--spacing-sm);
            border-radius: 4px;
            color: #fff;
            font-size: 0.85rem;
        }

        .recommendation-item {
            display: flex;
            align-items: center;
            gap: var(--spacing-sm);
            padding: var(--spacing-sm);
            border-radius: var(--border-radius);
            background: var(--bg-primary);
            box-shadow: 0 1px 3px var(--shadow);
        }

        .recommendation-item.critical { border-left: 4px solid var(--critical); }
        .recommendation-item.warning { border-left: 4px solid var(--warning); }
        .recommendation-item.success { border-left: 4px solid var(--success); }

        .rec-icon {
            font-size: 1.2rem;
        }

        /* Status Messages */
        .status-message {
            padding: 0.6rem 1rem;
            border-radius: 4px;
            margin: var(--spacing-sm) 0;
            display: flex;
            align-items: center;
            gap: var(--spacing-sm);
            animation: slideIn 0.3s ease-out;
            font-size: 0.85rem;
        }

        @keyframes slideIn {
            from {
                transform: translateY(-10px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        .status-success {
            background: rgba(76, 175, 80, 0.1);
            color: var(--success);
            border: 1px solid rgba(76, 175, 80, 0.3);
        }

        .status-error {
            background: rgba(255, 87, 34, 0.1);
            color: var(--danger);
            border: 1px solid rgba(255, 87, 34, 0.3);
        }

        .status-info {
            background: rgba(33, 150, 243, 0.1);
            color: #2196F3;
            border: 1px solid rgba(33, 150, 243, 0.3);
        }

        /* Austin Link */
        .austin-link {
            background: var(--amazon-yellow);
            color: var(--amazon-blue);
            padding: 0.3rem 0.6rem;
            border-radius: 3px;
            text-decoration: none;
            font-size: 0.75rem;
            font-weight: 600;
            transition: var(--transition);
            display: inline-flex;
            align-items: center;
            gap: 0.2rem;
        }

        .austin-link:hover {
            background: #ffc700;
            transform: translateY(-1px);
        }

        /* Loading Spinner */
        .spinner {
            width: 30px;
            height: 30px;
            border: 3px solid var(--bg-secondary);
            border-top: 3px solid var(--amazon-orange);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: var(--spacing-lg) auto;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            .header-content {
                flex-direction: column;
                text-align: center;
                gap: var(--spacing-sm);
            }

            .nav-tabs {
                overflow-x: scroll;
            }

            .charts-grid {
                grid-template-columns: 1fr;
            }

            .filter-section {
                grid-template-columns: 1fr;
            }

            .risk-matrix {
                grid-template-columns: 30px repeat(5, 1fr);
                grid-template-rows: repeat(6, 50px);
                font-size: 0.7rem;
            }

            .chart-container {
                height: 200px;
            }
        }

        /* Tab Content */
        .tab-content {
            display: none;
            animation: fadeIn 0.3s ease-out;
        }

        .tab-content.active {
            display: block;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* Hidden class */
        .hidden {
            display: none !important;
        }

        /* Sub Navigation */
        .sub-nav {
            display: flex;
            gap: 0;
            margin-bottom: var(--spacing-md);
            border-bottom: 1px solid var(--bg-secondary);
        }

        .sub-nav-item {
            padding: 0.5rem 1rem;
            cursor: pointer;
            transition: var(--transition);
            font-size: 0.85rem;
            position: relative;
            color: var(--text-secondary);
            border-bottom: 2px solid transparent;
        }

        .sub-nav-item:hover {
            color: var(--amazon-orange);
            background: var(--bg-secondary);
        }

        .sub-nav-item.active {
            color: var(--amazon-orange);
            border-bottom-color: var(--amazon-orange);
        }

        /* Modal */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 1000;
            animation: fadeIn 0.3s;
        }

        .modal-content {
            position: relative;
            background: var(--bg-primary);
            margin: 5% auto;
            padding: var(--spacing-lg);
            width: 90%;
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
            border-radius: var(--border-radius);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            animation: slideDown 0.3s;
        }

        @keyframes slideDown {
            from {
                transform: translateY(-50px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: var(--spacing-md);
            border-bottom: 1px solid var(--bg-secondary);
            padding-bottom: var(--spacing-sm);
        }

        .modal-close {
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            color: var(--text-secondary);
            transition: var(--transition);
        }

        .modal-close:hover {
            color: var(--text-primary);
            transform: rotate(90deg);
        }

        /* Pagination */
        .pagination {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: var(--spacing-sm);
            margin-top: var(--spacing-md);
        }

        .pagination-info {
            color: var(--text-secondary);
            font-size: 0.85rem;
        }

        /* KPI Dashboard */
        .kpi-container {
            background: linear-gradient(135deg, var(--amazon-blue) 0%, var(--amazon-blue-dark) 100%);
            color: white;
            border-radius: var(--border-radius);
            padding: var(--spacing-lg);
            margin-bottom: var(--spacing-lg);
        }

        .kpi-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: var(--spacing-lg);
            margin-top: var(--spacing-md);
        }

        .kpi-item {
            text-align: center;
        }

        .kpi-value {
            font-size: 2rem;
            font-weight: 700;
            margin-bottom: var(--spacing-xs);
        }

        .kpi-label {
            font-size: 0.85rem;
            opacity: 0.9;
        }

        /* Footer */
        .footer {
            background: var(--amazon-blue);
            color: white;
            padding: var(--spacing-lg) 0;
            margin-top: 3rem;
            text-align: center;
            font-size: 0.85rem;
        }

        .footer a {
            color: var(--amazon-orange);
            text-decoration: none;
        }

        .footer a:hover {
            text-decoration: underline;
        }

        /* Amazon Prime Style Welcome */
        .welcome-screen {
            text-align: center;
            padding: 3rem var(--spacing-lg);
        }

        .welcome-title {
            font-size: 2rem;
            margin-bottom: var(--spacing-sm);
            background: linear-gradient(135deg, var(--amazon-orange), var(--amazon-orange-dark));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .welcome-subtitle {
            font-size: 1.1rem;
            color: var(--text-secondary);
            margin-bottom: var(--spacing-xl);
        }

        .welcome-actions {
            display: flex;
            gap: var(--spacing-sm);
            justify-content: center;
            flex-wrap: wrap;
        }

        /* Export Options */
        .export-section {
            background: var(--bg-primary);
            border-radius: var(--border-radius);
            padding: var(--spacing-md);
            margin-top: var(--spacing-lg);
            box-shadow: 0 1px 4px var(--shadow);
        }

        .export-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: var(--spacing-sm);
            margin-top: var(--spacing-sm);
        }

        /* Print Styles */
        @media print {
            body {
                background: white;
            }
            
            .header, .nav-container, .mode-toggle, .btn, .upload-area {
                display: none !important;
            }
            
            .card, .table-container {
                break-inside: avoid;
                box-shadow: none;
                border: 1px solid #ddd;
            }
        }

        /* Amazon Smile */
        .amazon-smile {
            color: var(--amazon-orange);
            font-size: 1.2rem;
            margin-right: var(--spacing-xs);
        }
    </style>
</head>
<body>
    <!-- Header -->
    <header class="header">
        <div class="header-content">
            <div class="header-title">
                <div class="amazon-logo">
                    <span class="amazon-smile">‚Üí</span>
                    <span>amazon</span>
                </div>
                <div>
                    <h1>Safety Analytics Platform</h1>
                    <div class="header-subtitle">
                        <span>WHS Austria</span>
                        <span style="opacity: 0.7;">|</span>
                        <span>Developed by Erwin Esener @eeesener</span>
                    </div>
                </div>
            </div>
            <div class="header-actions">
                <button class="mode-toggle" onclick="toggleTheme()">
                    <span id="themeIcon">üåô</span>
                    <span id="themeText">Dark Mode</span>
                </button>
            </div>
        </div>
    </header>

    <!-- Navigation -->
    <nav class="nav-container">
        <div class="nav-tabs">
            <div class="nav-tab active" onclick="switchModule('overview')">
                <span class="nav-tab-icon">üìä</span>
                <span>Overview</span>
            </div>
            <div class="nav-tab" onclick="switchModule('injury')">
                <span class="nav-tab-icon">üè•</span>
                <span>Injury & Illness</span>
            </div>
            <div class="nav-tab" onclick="switchModule('nearmiss')">
                <span class="nav-tab-icon">‚ö†Ô∏è</span>
                <span>Near Miss</span>
            </div>
            <div class="nav-tab" onclick="switchModule('combined')">
                <span class="nav-tab-icon">üìà</span>
                <span>Combined Analytics</span>
            </div>
            <div class="nav-tab" onclick="switchModule('reports')">
                <span class="nav-tab-icon">üìÑ</span>
                <span>Reports</span>
            </div>
            <div class="nav-tab" onclick="switchModule('actions')">
                <span class="nav-tab-icon">‚úÖ</span>
                <span>Actions</span>
            </div>
        </div>
    </nav>

    <div class="container">
        <!-- Status Message Container -->
        <div id="statusContainer"></div>

        <!-- Overview Module -->
        <div id="overview" class="tab-content active">
            <div class="welcome-screen" id="welcomeScreen">
                <h2 class="welcome-title">Welcome to Safety Analytics</h2>
                <p class="welcome-subtitle">Your comprehensive platform for workplace safety data analysis</p>
                <div class="welcome-actions">
                    <button class="btn btn-primary" onclick="switchModule('injury')">
                        <span>üè•</span> Analyze Injuries
                    </button>
                    <button class="btn btn-primary" onclick="switchModule('nearmiss')">
                        <span>‚ö†Ô∏è</span> Review Near Misses
                    </button>
                    <button class="btn btn-secondary" onclick="loadSampleData()">
                        <span>üß™</span> Load Sample Data
                    </button>
                </div>
            </div>

            <!-- Unified Filters for Overview Dashboards -->
            <div id="overviewFilters" class="filter-section" style="display: none; margin-top: 1rem; gap: 1rem;">
                <div class="filter-group">
                    <label class="filter-label">Site</label>
                    <select class="filter-input" id="overviewSiteFilter" onchange="applyOverviewFilters()">
                        <option value="">All Sites</option>
                    </select>
                </div>
                <div class="filter-group">
                    <label class="filter-label">Severity</label>
                    <select class="filter-input" id="overviewSeverityFilter" onchange="applyOverviewFilters()">
                        <option value="">All Severities</option>
                        <option value="A">A - Critical</option>
                        <option value="B">B - High</option>
                        <option value="C">C - Medium</option>
                        <option value="D">D - Low</option>
                    </select>
                </div>
                <div class="filter-group">
                    <label class="filter-label">Date From</label>
                    <input type="date" class="filter-input" id="overviewDateFrom" onchange="applyOverviewFilters()">
                </div>
                <div class="filter-group">
                    <label class="filter-label">Date To</label>
                    <input type="date" class="filter-input" id="overviewDateTo" onchange="applyOverviewFilters()">
                </div>
                <!-- Additional unified filters to mirror both modules -->
                <div class="filter-group">
                    <label class="filter-label">Body Part</label>
                    <select class="filter-input" id="overviewBodyPartFilter" onchange="applyOverviewFilters()">
                        <option value="">All Body Parts</option>
                    </select>
                </div>
                <div class="filter-group">
                    <label class="filter-label">Impact</label>
                    <select class="filter-input" id="overviewImpactFilter" onchange="applyOverviewFilters()">
                        <option value="">All Impacts</option>
                    </select>
                </div>
                <div class="filter-group">
                    <label class="filter-label">Location</label>
                    <select class="filter-input" id="overviewLocationFilter" onchange="applyOverviewFilters()">
                        <option value="">All Locations</option>
                    </select>
                </div>
                <div class="filter-group">
                    <label class="filter-label">Process Path</label>
                    <select class="filter-input" id="overviewProcessFilter" onchange="applyOverviewFilters()">
                        <option value="">All Processes</option>
                    </select>
                </div>
                <div class="filter-group">
                    <label class="filter-label">Likelihood</label>
                    <select class="filter-input" id="overviewLikelihoodFilter" onchange="applyOverviewFilters()">
                        <option value="">All Likelihoods</option>
                    </select>
                </div>
            </div>

            <!-- KPI Dashboard -->
            <div class="kpi-container" id="kpiDashboard" style="display: none;">
                <h3>Key Performance Indicators - Austria Region</h3>
                <div class="kpi-grid">
                    <div class="kpi-item">
                        <div class="kpi-value" id="kpiTRIR">0.00</div>
                        <div class="kpi-label">TRIR</div>
                    </div>
                    <div class="kpi-item">
                        <div class="kpi-value" id="kpiLTIR">0.00</div>
                        <div class="kpi-label">LTIR</div>
                    </div>
                    <div class="kpi-item">
                        <div class="kpi-value" id="kpiDAFWR">0.00</div>
                        <div class="kpi-label">DAFWR</div>
                    </div>
                    <div class="kpi-item">
                        <div class="kpi-value" id="kpiNMFR">0.00</div>
                        <div class="kpi-label">NMFR</div>
                    </div>
                </div>
            </div>

            <!-- Combined Metrics Overview -->
            <div class="metrics-grid" id="overviewMetrics" style="display: none;">
                <div class="metric-card">
                    <div class="metric-icon">üìä</div>
                    <div class="metric-value" id="totalIncidents">0</div>
                    <div class="metric-label">Total Safety Events</div>
                    <div class="metric-trend">‚Üì 12%</div>
                </div>
                <div class="metric-card">
                    <div class="metric-icon">üè•</div>
                    <div class="metric-value" id="injuryCount">0</div>
                    <div class="metric-label">Injuries & Illnesses</div>
                </div>
                <div class="metric-card">
                    <div class="metric-icon">‚ö†Ô∏è</div>
                    <div class="metric-value" id="nearMissCount">0</div>
                    <div class="metric-label">Near Misses</div>
                </div>
                <div class="metric-card">
                    <div class="metric-icon">üìà</div>
                    <div class="metric-value" id="riskScore">0.0</div>
                    <div class="metric-label">Overall Risk Score</div>
                </div>
            </div>

            <!-- Quick Charts -->
            <div class="charts-grid" id="overviewCharts" style="display: none;">
                <div class="chart-card">
                    <div class="chart-header">
                        <h3 class="chart-title">Safety Trend Overview</h3>
                        <button class="btn btn-sm btn-outline" onclick="exportChart('overviewTrendChart')">
                            <span>üì∏</span> Export
                        </button>
                    </div>
                    <div class="chart-container">
                        <canvas id="overviewTrendChart"></canvas>
                    </div>
                </div>
                <div class="chart-card">
                    <div class="chart-header">
                        <h3 class="chart-title">Site Comparison</h3>
                        <button class="btn btn-sm btn-outline" onclick="exportChart('overviewSiteChart')">
                            <span>üì∏</span> Export
                        </button>
                    </div>
                    <div class="chart-container">
                        <canvas id="overviewSiteChart"></canvas>
                    </div>
                </div>
            </div>
        </div>

        <!-- Injury & Illness Module -->
        <div id="injury" class="tab-content">
            <!-- Sub Navigation -->
            <div class="sub-nav">
                <div class="sub-nav-item active" onclick="switchInjuryView('dashboard')">Dashboard</div>
                <div class="sub-nav-item" onclick="switchInjuryView('riskMatrix')">Risk Matrix</div>
                <div class="sub-nav-item" onclick="switchInjuryView('timeline')">Timeline</div>
                <div class="sub-nav-item" onclick="switchInjuryView('quality')">Quality Assessment</div>
                <div class="sub-nav-item" onclick="switchInjuryView('analytics')">Advanced Analytics</div>
            </div>

            <!-- Dashboard View -->
            <div id="injuryDashboard" class="injury-view">
                <div class="control-panel">
                    <div class="control-header">
                        <h2 class="control-title">Injury & Illness Analysis</h2>
                        <div class="quick-actions">
                            <button class="btn btn-primary" onclick="generatePDFReport('injury')">
                                <span>üìÑ</span> Generate Report
                            </button>
                            <button class="btn btn-secondary" onclick="exportInjuryData()">
                                <span>üìä</span> Export Excel
                            </button>
                        </div>
                    </div>

                    <div class="upload-area" id="injuryUploadArea" ondrop="handleDrop(event, 'injury')" ondragover="handleDragOver(event)" ondragleave="handleDragLeave(event)">
                        <p style="margin-bottom: 0.5rem;">üìÅ Drag and drop your injury CSV file here</p>
                        <label for="injuryFile" class="upload-label">Choose File</label>
                        <input type="file" id="injuryFile" class="file-input" accept=".csv" onchange="handleFileUpload(event, 'injury')">
                        <p style="margin-top: 0.5rem; font-size: 0.8rem; color: var(--text-secondary);">
                            Supports CSV files with injury/illness data including Austin case study links
                        </p>
                    </div>

                    <div class="filter-section">
                        <div class="filter-group">
                            <label class="filter-label">Site</label>
                            <select class="filter-input" id="injurySiteFilter" onchange="applyFilters('injury')">
                                <option value="">All Sites</option>
                            </select>
                        </div>
                        <div class="filter-group">
                            <label class="filter-label">Severity</label>
                            <select class="filter-input" id="injurySeverityFilter" onchange="applyFilters('injury')">
                                <option value="">All Severities</option>
                                <option value="A">A - Critical</option>
                                <option value="B">B - High</option>
                                <option value="C">C - Medium</option>
                                <option value="D">D - Low</option>
                            </select>
                        </div>
                        <div class="filter-group">
                            <label class="filter-label">Recordable</label>
                            <select class="filter-input" id="injuryRecordableFilter" onchange="applyFilters('injury')">
                                <option value="">All Cases</option>
                                <option value="1">Recordable Only</option>
                                <option value="0">Non-Recordable Only</option>
                            </select>
                        </div>
                        <div class="filter-group">
                            <label class="filter-label">OTR Status</label>
                            <select class="filter-input" id="injuryOTRFilter" onchange="applyFilters('injury')">
                                <option value="">All</option>
                                <option value="yes">On The Road</option>
                                <option value="no">Under the Roof</option>
                            </select>
                        </div>
                        <div class="filter-group">
                            <label class="filter-label">Body Part</label>
                            <select class="filter-input" id="injuryBodyPartFilter" onchange="applyFilters('injury')">
                                <option value="">All Body Parts</option>
                            </select>
                        </div>
                        <div class="filter-group">
                            <label class="filter-label">Root Cause</label>
                            <select class="filter-input" id="injuryRootCauseFilter" onchange="applyFilters('injury')">
                                <option value="">All Causes</option>
                            </select>
                        </div>
                        <div class="filter-group">
                            <label class="filter-label">Date From</label>
                            <input type="date" class="filter-input" id="injuryDateFrom" onchange="applyFilters('injury')">
                        </div>
                        <div class="filter-group">
                            <label class="filter-label">Date To</label>
                            <input type="date" class="filter-input" id="injuryDateTo" onchange="applyFilters('injury')">
                        </div>
                    </div>
                </div>

                <!-- Injury Metrics -->
                <div class="metrics-grid" id="injuryMetrics">
                    <div class="metric-card">
                        <div class="metric-icon">üè•</div>
                        <div class="metric-value" id="injuryTotal">0</div>
                        <div class="metric-label">Total Incidents</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-icon">üìù</div>
                        <div class="metric-value" id="injuryRecordable">0</div>
                        <div class="metric-label">Recordable Cases</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-icon">üìÖ</div>
                        <div class="metric-value" id="injuryLostTime">0</div>
                        <div class="metric-label">Lost Time Cases</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-icon">‚è±Ô∏è</div>
                        <div class="metric-value" id="injuryDaysLost">0</div>
                        <div class="metric-label">Days Away From Work</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-icon">üöó</div>
                        <div class="metric-value" id="injuryOTR">0</div>
                        <div class="metric-label">OTR Incidents</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-icon">üìä</div>
                        <div class="metric-value" id="injuryRecordableRate">0.0</div>
                        <div class="metric-label">Recordable Rate</div>
                    </div>
                </div>

                <!-- Injury Charts -->
                <div class="charts-grid">
                    <div class="chart-card">
                        <div class="chart-header">
                            <h3 class="chart-title">Analysis View 1</h3>
                            <select class="filter-input" style="width: auto;" onchange="updateInjuryChart(1, this.value)">
                                <option value="severity">Severity Distribution</option>
                                <option value="site">Site Comparison</option>
                                <option value="trend">Monthly Trend</option>
                                <option value="bodyPart">Body Parts Affected</option>
                                <option value="rootCause">Root Causes</option>
                                <option value="processPath">Process Paths</option>
                                <option value="recordableTrend">Recordable Trend</option>
                                <option value="impactType">Impact Types</option>
                            </select>
                        </div>
                        <div class="chart-container">
                            <canvas id="injuryChart1"></canvas>
                        </div>
                    </div>
                    <div class="chart-card">
                        <div class="chart-header">
                            <h3 class="chart-title">Analysis View 2</h3>
                            <select class="filter-input" style="width: auto;" onchange="updateInjuryChart(2, this.value)">
                                <option value="severity">Severity Distribution</option>
                                <option value="site">Site Comparison</option>
                                <option value="trend">Monthly Trend</option>
                                <option value="bodyPart">Body Parts Affected</option>
                                <option value="rootCause">Root Causes</option>
                                <option value="processPath">Process Paths</option>
                                <option value="recordableTrend">Recordable Trend</option>
                                <option value="impactType">Impact Types</option>
                            </select>
                        </div>
                        <div class="chart-container">
                            <canvas id="injuryChart2"></canvas>
                        </div>
                    </div>
                    <div class="chart-card">
                        <div class="chart-header">
                            <h3 class="chart-title">Analysis View 3</h3>
                            <select class="filter-input" style="width: auto;" onchange="updateInjuryChart(3, this.value)">
                                <option value="severity">Severity Distribution</option>
                                <option value="site">Site Comparison</option>
                                <option value="trend">Monthly Trend</option>
                                <option value="bodyPart">Body Parts Affected</option>
                                <option value="rootCause">Root Causes</option>
                                <option value="processPath">Process Paths</option>
                                <option value="recordableTrend">Recordable Trend</option>
                                <option value="impactType">Impact Types</option>
                            </select>
                        </div>
                        <div class="chart-container">
                            <canvas id="injuryChart3"></canvas>
                        </div>
                    </div>
                    <div class="chart-card">
                        <div class="chart-header">
                            <h3 class="chart-title">Analysis View 4</h3>
                            <select class="filter-input" style="width: auto;" onchange="updateInjuryChart(4, this.value)">
                                <option value="severity">Severity Distribution</option>
                                <option value="site">Site Comparison</option>
                                <option value="trend">Monthly Trend</option>
                                <option value="bodyPart">Body Parts Affected</option>
                                <option value="rootCause">Root Causes</option>
                                <option value="processPath">Process Paths</option>
                                <option value="recordableTrend">Recordable Trend</option>
                                <option value="impactType">Impact Types</option>
                            </select>
                        </div>
                        <div class="chart-container">
                            <canvas id="injuryChart4"></canvas>
                        </div>
                    </div>
                </div>

                <!-- Injury Table -->
                <div class="table-container">
                    <div class="table-header">
                        <h3>Recent Injury & Illness Cases</h3>
                        <button class="btn btn-sm btn-outline" onclick="exportTable('injury')">
                            <span>üìä</span> Export
                        </button>
                    </div>
                    <div class="table-wrapper">
                        <table id="injuryTable">
                            <thead>
                                <tr>
                                    <th>Case Number</th>
                                    <th>Date</th>
                                    <th>Site</th>
                                    <th>Body Part</th>
                                    <th>Type</th>
                                    <th>Severity</th>
                                    <th>Recordable</th>
                                    <th>OTR</th>
                                    <th>DAFW Days</th>
                                    <th>Root Cause</th>
                                    <th>Actions</th>
                                </tr>
                            </thead>
                            <tbody id="injuryTableBody">
                                <tr>
                                    <td colspan="11" style="text-align: center; padding: 2rem;">
                                        No data loaded. Please upload a CSV file.
                                    </td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                    <div class="pagination">
                        <button class="btn btn-sm" onclick="changePage('injury', -1)" id="injuryPrevBtn">Previous</button>
                        <span class="pagination-info" id="injuryPageInfo">Page 1 of 1</span>
                        <button class="btn btn-sm" onclick="changePage('injury', 1)" id="injuryNextBtn">Next</button>
                    </div>
                </div>
            </div>

            <!-- Risk Matrix View -->
            <div id="injuryRiskMatrix" class="injury-view hidden">
                <div class="card">
                    <h3 style="margin-bottom: 1rem;">Injury & Illness Risk Assessment Matrix</h3>
                    <p style="color: var(--text-secondary); margin-bottom: 0.5rem; font-size: 0.85rem;">
                        Click on any cell to view incidents in that risk category
                    </p>
                    <div class="risk-matrix" id="injuryRiskMatrixGrid">
                        <!-- Will be populated dynamically -->
                    </div>
                    <div style="margin-top: 1.5rem; text-align: center;">
                        <h4 style="font-size: 0.9rem;">Risk Levels:</h4>
                        <div style="display: flex; gap: 1.5rem; justify-content: center; margin-top: 0.5rem; font-size: 0.8rem;">
                            <span><span style="display: inline-block; width: 16px; height: 16px; background: #4CAF50; vertical-align: middle; border-radius: 3px;"></span> Low (1-5)</span>
                            <span><span style="display: inline-block; width: 16px; height: 16px; background: #FFC107; vertical-align: middle; border-radius: 3px;"></span> Medium (6-10)</span>
                            <span><span style="display: inline-block; width: 16px; height: 16px; background: #FF5722; vertical-align: middle; border-radius: 3px;"></span> High (11-15)</span>
                            <span><span style="display: inline-block; width: 16px; height: 16px; background: #B71C1C; vertical-align: middle; border-radius: 3px;"></span> Critical (16-25)</span>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Timeline View -->
            <div id="injuryTimeline" class="injury-view hidden">
                <div class="timeline-container">
                    <h3 style="margin-bottom: 1rem;">Injury & Illness Timeline</h3>
                    <div id="injuryTimelineContent">
                        <p style="text-align: center; padding: 2rem;">Timeline will be displayed after data is loaded.</p>
                    </div>
                    <div class="pagination">
                        <button class="btn btn-sm" onclick="changeTimelinePage('injury', -1)">Previous</button>
                        <span class="pagination-info" id="injuryTimelinePageInfo">Page 1 of 1</span>
                        <button class="btn btn-sm" onclick="changeTimelinePage('injury', 1)">Next</button>
                    </div>
                </div>
            </div>

            <!-- Quality Assessment View -->
            <div id="injuryQuality" class="injury-view hidden">
                <div class="quality-score-card">
                    <h3>Data Quality Assessment</h3>
                    <div class="quality-score-value" id="injuryQualityScore">0%</div>
                    <div class="quality-metrics">
                        <div class="quality-metric">
                            <div style="font-size: 1.5rem; font-weight: 700;" id="injuryCompleteness">0%</div>
                            <div style="font-size: 0.85rem;">Completeness</div>
                        </div>
                        <div class="quality-metric">
                            <div style="font-size: 1.5rem; font-weight: 700;" id="injuryAccuracy">0%</div>
                            <div style="font-size: 0.85rem;">Accuracy</div>
                        </div>
                        <div class="quality-metric">
                            <div style="font-size: 1.5rem; font-weight: 700;" id="injuryConsistency">0%</div>
                            <div style="font-size: 0.85rem;">Consistency</div>
                        </div>
                        <div class="quality-metric">
                            <div style="font-size: 1.5rem; font-weight: 700;" id="injuryTimeliness">0%</div>
                            <div style="font-size: 0.85rem;">Timeliness</div>
                        </div>
                    </div>
                </div>

                <div class="card" style="margin-top: 1rem;">
                    <h4 style="margin-bottom: 1rem;">Quality Issues Detected</h4>
                    <div id="injuryQualityIssues">
                        <p style="color: var(--text-secondary);">Quality assessment will appear after data is loaded.</p>
                    </div>
                </div>

                <div class="card" style="margin-top: 1rem;">
                    <h4 style="margin-bottom: 1rem;">Duplicate Detection</h4>
                    <div id="injuryDuplicates">
                        <p style="color: var(--text-secondary);">Duplicate analysis will appear after data is loaded.</p>
                    </div>
                </div>
            </div>

            <!-- Advanced Analytics View -->
            <div id="injuryAnalytics" class="injury-view hidden">
                <div class="charts-grid">
                    <div class="chart-card">
                        <div class="chart-header">
                            <h3 class="chart-title">Recordable Rate Trend</h3>
                        </div>
                        <div class="chart-container">
                            <canvas id="injuryRecordableRateTrendChart"></canvas>
                        </div>
                    </div>
                    <div class="chart-card">
                        <div class="chart-header">
                            <h3 class="chart-title">Body Part Heat Map</h3>
                        </div>
                        <div class="chart-container">
                            <canvas id="injuryBodyPartHeatMapChart"></canvas>
                        </div>
                    </div>
                    <div class="chart-card">
                        <div class="chart-header">
                            <h3 class="chart-title">Root Cause by Site</h3>
                        </div>
                        <div class="chart-container">
                            <canvas id="injuryRootCauseBySiteChart"></canvas>
                        </div>
                    </div>
                    <div class="chart-card">
                        <div class="chart-header">
                            <h3 class="chart-title">DAFW Distribution</h3>
                        </div>
                        <div class="chart-container">
                            <canvas id="injuryDAFWDistributionChart"></canvas>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Near Miss Module -->
        <div id="nearmiss" class="tab-content">
            <!-- Sub Navigation -->
            <div class="sub-nav">
                <div class="sub-nav-item active" onclick="switchNearMissView('dashboard')">Dashboard</div>
                <div class="sub-nav-item" onclick="switchNearMissView('riskMatrix')">Risk Matrix</div>
                <div class="sub-nav-item" onclick="switchNearMissView('timeline')">Timeline</div>
                <div class="sub-nav-item" onclick="switchNearMissView('quality')">Quality Assessment</div>
                <div class="sub-nav-item" onclick="switchNearMissView('analytics')">Advanced Analytics</div>
            </div>

            <!-- Dashboard View -->
            <div id="nearMissDashboard" class="nearmiss-view">
                <div class="control-panel">
                    <div class="control-header">
                        <h2 class="control-title">Near Miss Analysis</h2>
                        <div class="quick-actions">
                            <button class="btn btn-primary" onclick="generatePDFReport('nearmiss')">
                                <span>üìÑ</span> Generate Report
                            </button>
                            <button class="btn btn-secondary" onclick="exportNearMissData()">
                                <span>üìä</span> Export Excel
                            </button>
                        </div>
                    </div>

                    <div class="upload-area" id="nearMissUploadArea" ondrop="handleDrop(event, 'nearmiss')" ondragover="handleDragOver(event)" ondragleave="handleDragLeave(event)">
                        <p style="margin-bottom: 0.5rem;">üìÅ Drag and drop your near miss CSV file here</p>
                        <label for="nearMissFile" class="upload-label">Choose File</label>
                        <input type="file" id="nearMissFile" class="file-input" accept=".csv" onchange="handleFileUpload(event, 'nearmiss')">
                        <p style="margin-top: 0.5rem; font-size: 0.8rem; color: var(--text-secondary);">
                            Supports CSV files with near miss tracking data
                        </p>
                    </div>

                    <div class="filter-section">
                        <div class="filter-group">
                            <label class="filter-label">Site</label>
                            <select class="filter-input" id="nearMissSiteFilter" onchange="applyFilters('nearmiss')">
                                <option value="">All Sites</option>
                            </select>
                        </div>
                        <div class="filter-group">
                            <label class="filter-label">Potential Severity</label>
                            <select class="filter-input" id="nearMissSeverityFilter" onchange="applyFilters('nearmiss')">
                                <option value="">All Severities</option>
                                <option value="A">A - Critical</option>
                                <option value="B">B - High</option>
                                <option value="C">C - Medium</option>
                                <option value="D">D - Low</option>
                            </select>
                        </div>
                        <div class="filter-group">
                            <label class="filter-label">Primary Impact</label>
                            <select class="filter-input" id="nearMissPrimaryImpactFilter" onchange="applyFilters('nearmiss')">
                                <option value="">All Impacts</option>
                            </select>
                        </div>
                        <div class="filter-group">
                            <label class="filter-label">Location</label>
                            <select class="filter-input" id="nearMissLocationFilter" onchange="applyFilters('nearmiss')">
                                <option value="">All Locations</option>
                            </select>
                        </div>
                        <div class="filter-group">
                            <label class="filter-label">Process Path</label>
                            <select class="filter-input" id="nearMissProcessFilter" onchange="applyFilters('nearmiss')">
                                <option value="">All Processes</option>
                            </select>
                        </div>
                        <div class="filter-group">
                            <label class="filter-label">Likelihood</label>
                            <select class="filter-input" id="nearMissLikelihoodFilter" onchange="applyFilters('nearmiss')">
                                <option value="">All Likelihoods</option>
                                <option value="Rare">Rare</option>
                                <option value="Unlikely">Unlikely</option>
                                <option value="Possible">Possible</option>
                                <option value="Likely">Likely</option>
                                <option value="Almost Certain">Almost Certain</option>
                            </select>
                        </div>
                        <div class="filter-group">
                            <label class="filter-label">Date From</label>
                            <input type="date" class="filter-input" id="nearMissDateFrom" onchange="applyFilters('nearmiss')">
                        </div>
                        <div class="filter-group">
                            <label class="filter-label">Date To</label>
                            <input type="date" class="filter-input" id="nearMissDateTo" onchange="applyFilters('nearmiss')">
                        </div>
                    </div>
                </div>

                <!-- Near Miss Metrics -->
                <div class="metrics-grid" id="nearMissMetrics">
                    <div class="metric-card">
                        <div class="metric-icon">‚ö†Ô∏è</div>
                        <div class="metric-value" id="nearMissTotal">0</div>
                        <div class="metric-label">Total Near Misses</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-icon">üìä</div>
                        <div class="metric-value" id="nearMissRisk">0.0</div>
                        <div class="metric-label">Average Risk Score</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-icon">üö®</div>
                        <div class="metric-value" id="nearMissHigh">0</div>
                        <div class="metric-label">High Severity (A & B)</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-icon">‚úÖ</div>
                        <div class="metric-value" id="nearMissRepeat">0%</div>
                        <div class="metric-label">Closure Rate</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-icon">‚ö°</div>
                        <div class="metric-value" id="nearMissActionable">0</div>
                        <div class="metric-label">Requires Action</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-icon">üìà</div>
                        <div class="metric-value" id="nearMissFrequency">0.0</div>
                        <div class="metric-label">Frequency Rate</div>
                    </div>
                </div>

                <!-- Near Miss Charts -->
                <div class="charts-grid">
                    <div class="chart-card">
                        <div class="chart-header">
                            <h3 class="chart-title">Analysis View 1</h3>
                            <select class="filter-input" style="width: auto;" onchange="updateNearMissChart(1, this.value)">
                                <option value="severity">Severity Distribution</option>
                                <option value="site">Site Comparison</option>
                                <option value="trend">Monthly Trend</option>
                                <option value="location">Top Locations</option>
                                <option value="impact">Primary Impacts</option>
                                <option value="process">Process Paths</option>
                                <option value="likelihood">Likelihood Analysis</option>
                                <option value="riskTrend">Risk Score Trend</option>
                            </select>
                        </div>
                        <div class="chart-container">
                            <canvas id="nearMissChart1"></canvas>
                        </div>
                    </div>
                    <div class="chart-card">
                        <div class="chart-header">
                            <h3 class="chart-title">Analysis View 2</h3>
                            <select class="filter-input" style="width: auto;" onchange="updateNearMissChart(2, this.value)">
                                <option value="severity">Severity Distribution</option>
                                <option value="site">Site Comparison</option>
                                <option value="trend">Monthly Trend</option>
                                <option value="location">Top Locations</option>
                                <option value="impact">Primary Impacts</option>
                                <option value="process">Process Paths</option>
                                <option value="likelihood">Likelihood Analysis</option>
                                <option value="riskTrend">Risk Score Trend</option>
                            </select>
                        </div>
                        <div class="chart-container">
                            <canvas id="nearMissChart2"></canvas>
                        </div>
                    </div>
                    <div class="chart-card">
                        <div class="chart-header">
                            <h3 class="chart-title">Analysis View 3</h3>
                            <select class="filter-input" style="width: auto;" onchange="updateNearMissChart(3, this.value)">
                                <option value="severity">Severity Distribution</option>
                                <option value="site">Site Comparison</option>
                                <option value="trend">Monthly Trend</option>
                                <option value="location">Top Locations</option>
                                <option value="impact">Primary Impacts</option>
                                <option value="process">Process Paths</option>
                                <option value="likelihood">Likelihood Analysis</option>
                                <option value="riskTrend">Risk Score Trend</option>
                            </select>
                        </div>
                        <div class="chart-container">
                            <canvas id="nearMissChart3"></canvas>
                        </div>
                    </div>
                    <div class="chart-card">
                        <div class="chart-header">
                            <h3 class="chart-title">Analysis View 4</h3>
                            <select class="filter-input" style="width: auto;" onchange="updateNearMissChart(4, this.value)">
                                <option value="severity">Severity Distribution</option>
                                <option value="site">Site Comparison</option>
                                <option value="trend">Monthly Trend</option>
                                <option value="location">Top Locations</option>
                                <option value="impact">Primary Impacts</option>
                                <option value="process">Process Paths</option>
                                <option value="likelihood">Likelihood Analysis</option>
                                <option value="riskTrend">Risk Score Trend</option>
                            </select>
                        </div>
                        <div class="chart-container">
                            <canvas id="nearMissChart4"></canvas>
                        </div>
                    </div>
                </div>

                <!-- Near Miss Table -->
                <div class="table-container">
                    <div class="table-header">
                        <h3>Recent Near Miss Reports</h3>
                        <button class="btn btn-sm btn-outline" onclick="exportTable('nearmiss')">
                            <span>üìä</span> Export
                        </button>
                    </div>
                    <div class="table-wrapper">
                        <table id="nearMissTable">
                            <thead>
                                <tr>
                                    <th>Near Miss ID</th>
                                    <th>Date</th>
                                    <th>Site</th>
                                    <th>Location</th>
                                    <th>Process Path</th>
                                    <th>Primary Impact</th>
                                    <th>Severity</th>
                                    <th>Likelihood</th>
                                    <th>Risk Score</th>
                                    <th>Actions</th>
                                </tr>
                            </thead>
                            <tbody id="nearMissTableBody">
                                <tr>
                                    <td colspan="10" style="text-align: center; padding: 2rem;">
                                        No data loaded. Please upload a CSV file.
                                    </td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                    <div class="pagination">
                        <button class="btn btn-sm" onclick="changePage('nearmiss', -1)" id="nearMissPrevBtn">Previous</button>
                        <span class="pagination-info" id="nearMissPageInfo">Page 1 of 1</span>
                        <button class="btn btn-sm" onclick="changePage('nearmiss', 1)" id="nearMissNextBtn">Next</button>
                    </div>
                </div>
            </div>

            <!-- Risk Matrix View -->
            <div id="nearMissRiskMatrix" class="nearmiss-view hidden">
                <div class="card">
                    <h3 style="margin-bottom: 1rem;">Near Miss Risk Assessment Matrix</h3>
                    <p style="color: var(--text-secondary); margin-bottom: 0.5rem; font-size: 0.85rem;">
                        Click on any cell to view incidents in that risk category
                    </p>
                    <div class="risk-matrix" id="nearMissRiskMatrixGrid">
                        <!-- Will be populated dynamically -->
                    </div>
                </div>
            </div>

            <!-- Timeline View -->
            <div id="nearMissTimeline" class="nearmiss-view hidden">
                <div class="timeline-container">
                    <h3 style="margin-bottom: 1rem;">Near Miss Timeline</h3>
                    <div id="nearMissTimelineContent">
                        <p style="text-align: center; padding: 2rem;">Timeline will be displayed after data is loaded.</p>
                    </div>
                    <div class="pagination">
                        <button class="btn btn-sm" onclick="changeTimelinePage('nearmiss', -1)">Previous</button>
                        <span class="pagination-info" id="nearMissTimelinePageInfo">Page 1 of 1</span>
                        <button class="btn btn-sm" onclick="changeTimelinePage('nearmiss', 1)">Next</button>
                    </div>
                </div>
            </div>

            <!-- Quality Assessment View -->
            <div id="nearMissQuality" class="nearmiss-view hidden">
                <div class="quality-score-card">
                    <h3>Data Quality Assessment</h3>
                    <div class="quality-score-value" id="nearMissQualityScore">0%</div>
                    <div class="quality-metrics">
                        <div class="quality-metric">
                            <div style="font-size: 1.5rem; font-weight: 700;" id="nearMissCompleteness">0%</div>
                            <div style="font-size: 0.85rem;">Completeness</div>
                        </div>
                        <div class="quality-metric">
                            <div style="font-size: 1.5rem; font-weight: 700;" id="nearMissAccuracy">0%</div>
                            <div style="font-size: 0.85rem;">Accuracy</div>
                        </div>
                        <div class="quality-metric">
                            <div style="font-size: 1.5rem; font-weight: 700;" id="nearMissConsistency">0%</div>
                            <div style="font-size: 0.85rem;">Consistency</div>
                        </div>
                        <div class="quality-metric">
                            <div style="font-size: 1.5rem; font-weight: 700;" id="nearMissTimeliness">0%</div>
                            <div style="font-size: 0.85rem;">Timeliness</div>
                        </div>
                    </div>
                </div>

                <div class="card" style="margin-top: 1rem;">
                    <h4 style="margin-bottom: 1rem;">Quality Issues Detected</h4>
                    <div id="nearMissQualityIssues">
                        <p style="color: var(--text-secondary);">Quality assessment will appear after data is loaded.</p>
                    </div>
                </div>

        <div class="card" style="margin-top: 1rem;">
                    <h4 style="margin-bottom: 1rem;">Duplicate Detection</h4>
                    <div id="nearMissDuplicates">
                        <p style="color: var(--text-secondary);">Duplicate analysis will appear after data is loaded.</p>
                    </div>
                </div>
                <!-- Word count and heat map for near miss quality -->
                <div class="card" style="margin-top: 1rem;">
                    <h4 style="margin-bottom: 1rem;">Word Count Summary</h4>
                    <p id="nearMissWordCount" style="font-size: 0.9rem; color: var(--text-secondary);">Word count analysis will appear after data is loaded.</p>
                </div>
                <div class="card" style="margin-top: 1rem;">
                    <h4 style="margin-bottom: 1rem;">Word Heat Map</h4>
                    <div id="nearMissWordHeatMap" class="word-heatmap"></div>
                </div>
            </div>

            <!-- Advanced Analytics View -->
            <div id="nearMissAnalytics" class="nearmiss-view hidden">
                <div class="charts-grid">
                    <div class="chart-card">
                        <div class="chart-header">
                            <h3 class="chart-title">Risk Trend Analysis</h3>
                        </div>
                        <div class="chart-container">
                            <canvas id="nearMissRiskTrendChart"></canvas>
                        </div>
                    </div>
                    <div class="chart-card">
                        <div class="chart-header">
                            <h3 class="chart-title">Impact vs Severity</h3>
                        </div>
                        <div class="chart-container">
                            <canvas id="nearMissImpactAnalysisChart"></canvas>
                        </div>
                    </div>
                    <div class="chart-card">
                        <div class="chart-header">
                            <h3 class="chart-title">Location Risk Map</h3>
                        </div>
                        <div class="chart-container">
                            <canvas id="nearMissLocationRiskChart"></canvas>
                        </div>
                    </div>
                    <div class="chart-card">
                        <div class="chart-header">
                            <h3 class="chart-title">Process Risk Analysis</h3>
                        </div>
                        <div class="chart-container">
                            <canvas id="nearMissProcessRiskChart"></canvas>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Combined Analytics Module -->
        <div id="combined" class="tab-content">
            <div class="control-panel">
                <div class="control-header">
                    <h2 class="control-title">Combined Safety Analytics</h2>
                    <div>
                        <button class="btn btn-primary" onclick="generatePDFReport('combined')">
                            <span>üìÑ</span> Generate Combined Report
                        </button>
                    </div>
                </div>
                <!-- Unified filters for the combined analytics.  This mirrors the overview
                     and module-specific filters so users can slice data consistently across
                     all dashboards.  The filter ids are namespaced with "combined" to
                     avoid duplicate IDs on the page.  Each dropdown calls
                     applyCombinedFilters() on change to propagate selections to the
                     underlying injury and near miss modules, refresh the overview, and
                     update the combined analytics itself.  Options are populated
                     dynamically once data is loaded. -->
                <div id="combinedFilters" class="filter-section" style="display: none; margin-top: 1rem; gap: 1rem;">
                    <div class="filter-group">
                        <label class="filter-label">Site</label>
                        <select class="filter-input" id="combinedSiteFilter" onchange="applyCombinedFilters()">
                            <option value="">All Sites</option>
                        </select>
                    </div>
                    <div class="filter-group">
                        <label class="filter-label">Severity</label>
                        <select class="filter-input" id="combinedSeverityFilter" onchange="applyCombinedFilters()">
                            <option value="">All Severities</option>
                            <option value="A">A - Critical</option>
                            <option value="B">B - High</option>
                            <option value="C">C - Medium</option>
                            <option value="D">D - Low</option>
                        </select>
                    </div>
                    <div class="filter-group">
                        <label class="filter-label">Date From</label>
                        <input type="date" class="filter-input" id="combinedDateFrom" onchange="applyCombinedFilters()">
                    </div>
                    <div class="filter-group">
                        <label class="filter-label">Date To</label>
                        <input type="date" class="filter-input" id="combinedDateTo" onchange="applyCombinedFilters()">
                    </div>
                    <div class="filter-group">
                        <label class="filter-label">Body Part</label>
                        <select class="filter-input" id="combinedBodyPartFilter" onchange="applyCombinedFilters()">
                            <option value="">All Body Parts</option>
                        </select>
                    </div>
                    <div class="filter-group">
                        <label class="filter-label">Impact</label>
                        <select class="filter-input" id="combinedImpactFilter" onchange="applyCombinedFilters()">
                            <option value="">All Impacts</option>
                        </select>
                    </div>
                    <div class="filter-group">
                        <label class="filter-label">Location</label>
                        <select class="filter-input" id="combinedLocationFilter" onchange="applyCombinedFilters()">
                            <option value="">All Locations</option>
                        </select>
                    </div>
                    <div class="filter-group">
                        <label class="filter-label">Process Path</label>
                        <select class="filter-input" id="combinedProcessFilter" onchange="applyCombinedFilters()">
                            <option value="">All Processes</option>
                        </select>
                    </div>
                    <div class="filter-group">
                        <label class="filter-label">Likelihood</label>
                        <select class="filter-input" id="combinedLikelihoodFilter" onchange="applyCombinedFilters()">
                            <option value="">All Likelihoods</option>
                        </select>
                    </div>
                </div>
            </div>

            <!-- Combined Metrics -->
            <div class="metrics-grid">
                <div class="metric-card">
                    <div class="metric-icon">üìä</div>
                    <div class="metric-value" id="combinedTotal">0</div>
                    <div class="metric-label">Total Safety Events</div>
                </div>
                <div class="metric-card">
                    <div class="metric-icon">‚ö†Ô∏è</div>
                    <div class="metric-value" id="combinedHighRisk">0</div>
                    <div class="metric-label">High Risk Events</div>
                </div>
                <div class="metric-card">
                    <div class="metric-icon">üìà</div>
                    <div class="metric-value" id="combinedTrend">0%</div>
                    <div class="metric-label">Monthly Trend</div>
                </div>
                <div class="metric-card">
                    <div class="metric-icon">üéØ</div>
                    <div class="metric-value" id="combinedTargetSites">0</div>
                    <div class="metric-label">Sites Requiring Focus</div>
                </div>
            </div>

            <!-- Risk Matrix -->
            <div class="card">
                <h3 style="margin-bottom: 1rem;">Combined Risk Assessment Matrix</h3>
                <div class="risk-matrix" id="combinedRiskMatrix">
                    <!-- Will be populated dynamically -->
                </div>
            </div>

            <!-- Combined Charts -->
            <div class="charts-grid">
                <div class="chart-card">
                    <div class="chart-header">
                        <h3 class="chart-title">Safety Performance Trend</h3>
                    </div>
                    <div class="chart-container">
                        <canvas id="combinedTrendChart"></canvas>
                    </div>
                </div>
                <div class="chart-card">
                    <div class="chart-header">
                        <h3 class="chart-title">Site Safety Comparison</h3>
                    </div>
                    <div class="chart-container">
                        <canvas id="combinedSiteChart"></canvas>
                    </div>
                </div>
                <div class="chart-card">
                    <div class="chart-header">
                        <h3 class="chart-title">Severity Analysis</h3>
                    </div>
                    <div class="chart-container">
                        <canvas id="combinedSeverityChart"></canvas>
                    </div>
                </div>
                <div class="chart-card">
                    <div class="chart-header">
                        <h3 class="chart-title">Prevention Effectiveness</h3>
                    </div>
                    <div class="chart-container">
                        <canvas id="combinedPreventionChart"></canvas>
                    </div>
                </div>
            </div>

            <!-- Insights -->
            <div class="card" style="margin-top: 1.5rem;">
                <h3 style="margin-bottom: 1rem;">Key Insights & Correlations</h3>
                <div id="combinedInsights">
                    <p style="color: var(--text-secondary);">Load data to see insights and correlations between injuries and near misses</p>
                </div>
            </div>
        </div>

        <!-- Reports Module -->
        <div id="reports" class="tab-content">
            <div class="control-panel">
                <div class="control-header">
                    <h2 class="control-title">Report Generation Center</h2>
                </div>
            </div>

            <div class="export-section">
                <h3 style="margin-bottom: 1rem;">Available Reports</h3>
                <div class="export-grid">
                    <button class="btn btn-primary" onclick="generatePDFReport('injury')">
                        <span>üìÑ</span> 
                        <div>
                            <div>Injury Report</div>
                            <small style="font-size: 0.75rem; opacity: 0.8;">Comprehensive analysis</small>
                        </div>
                    </button>
                    <button class="btn btn-primary" onclick="generatePDFReport('nearmiss')">
                        <span>üìÑ</span>
                        <div>
                            <div>Near Miss Report</div>
                            <small style="font-size: 0.75rem; opacity: 0.8;">Trends & patterns</small>
                        </div>
                    </button>
                    <button class="btn btn-primary" onclick="generatePDFReport('combined')">
                        <span>üìÑ</span>
                        <div>
                            <div>Combined Report</div>
                            <small style="font-size: 0.75rem; opacity: 0.8;">Full analysis</small>
                        </div>
                    </button>
                    <button class="btn btn-primary" onclick="generatePDFReport('executive')">
                        <span>üìÑ</span>
                        <div>
                            <div>Executive Summary</div>
                            <small style="font-size: 0.75rem; opacity: 0.8;">High-level overview</small>
                        </div>
                    </button>
                    <button class="btn btn-secondary" onclick="exportToExcel('all')">
                        <span>üìä</span>
                        <div>
                            <div>Export All Data</div>
                            <small style="font-size: 0.75rem; opacity: 0.8;">Excel format</small>
                        </div>
                    </button>
                    <button class="btn btn-secondary" onclick="exportDashboard()">
                        <span>üì∏</span>
                        <div>
                            <div>Dashboard Snapshot</div>
                            <small style="font-size: 0.75rem; opacity: 0.8;">PNG image</small>
                        </div>
                    </button>
                </div>
            </div>

            <div class="card" style="margin-top: 1.5rem;">
                <h3 style="margin-bottom: 1rem;">Report History</h3>
                <div id="reportHistory">
                    <p style="color: var(--text-secondary);">No reports generated yet</p>
                </div>
            </div>
        </div>

        <!-- Action Tracking Module -->
        <div id="actions" class="tab-content">
            <div class="control-panel">
                <div class="control-header">
                    <h2 class="control-title">Action Item Tracking</h2>
                    <button class="btn btn-primary" onclick="addNewAction()">
                        <span>‚ûï</span> Add Action
                    </button>
                </div>
            </div>

            <div class="card">
                <h4 style="color: var(--danger); margin-bottom: 1rem;">
                    <span style="margin-right: 0.5rem;">üö®</span>
                    Immediate Actions Required
                </h4>
                <div id="immediateActions">
                    <p style="color: var(--text-secondary);">No immediate actions identified. Load data to see recommendations.</p>
                </div>
            </div>

            <div class="card" style="margin-top: 1rem;">
                <h4 style="color: var(--warning); margin-bottom: 1rem;">
                    <span style="margin-right: 0.5rem;">‚ö°</span>
                    Short-term Actions (30 days)
                </h4>
                <div id="shortTermActions">
                    <p style="color: var(--text-secondary);">Actions will be generated based on data analysis.</p>
                </div>
            </div>

            <div class="card" style="margin-top: 1rem;">
                <h4 style="color: #2196F3; margin-bottom: 1rem;">
                    <span style="margin-right: 0.5rem;">üéØ</span>
                    Long-term Improvements
                </h4>
                <div id="longTermActions">
                    <p style="color: var(--text-secondary);">Strategic improvements will be suggested based on trends.</p>
                </div>
            </div>
        </div>
    </div>

    <!-- Modal for details -->
    <div id="detailModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 id="modalTitle">Details</h3>
                <button class="modal-close" onclick="closeModal()">&times;</button>
            </div>
            <div id="modalBody">
                <!-- Content will be populated dynamically -->
            </div>
        </div>
    </div>

    <!-- Footer -->
    <footer class="footer">
        <p>
            Safety Analytics Platform v2.0 | Amazon WHS Austria | 
            Developed by <a href="https://twitter.com/eeesener" target="_blank">Erwin Esener @eeesener</a> | 
            ¬© 2024 Amazon.com, Inc.
        </p>
    </footer>

    <script>
       // Global State Management
const state = {
    injury: {
        rawData: [],
        filteredData: [],
        charts: {},
        currentPage: 1,
        timelinePage: 1,
        qualityMetrics: {},
        sort: { column: 'incident_date', direction: 'desc' }
    },
    nearMiss: {
        rawData: [],
        filteredData: [],
        charts: {},
        currentPage: 1,
        timelinePage: 1,
        qualityMetrics: {},
        sort: { column: 'nearmiss_date', direction: 'desc' }
    },
    currentModule: 'overview',
    theme: 'light',
    itemsPerPage: 20
};

// Constants
const SEVERITY_COLORS = {
    'A': '#B71C1C',
    'B': '#FF5722',
    'C': '#FFC107',
    'D': '#4CAF50',
    'Unknown': '#9E9E9E'
};

// Amazon Brand Colors
const AMAZON_COLORS = {
    orange: '#FF9900',
    darkBlue: '#232F3E',
    lightBlue: '#37475A',
    gray: '#131A22',
    smile: '#FF9900'
};

/**
 * Convert a hex colour (e.g. "#FF9900") into an RGB array.
 * jsPDF requires colour values to be provided as separate R, G, B numbers.  When
 * passing the raw hex codes directly to jsPDF it attempts to parse the
 * individual digits which results in invalid colour values and errors like
 * "Invalid argument passed to jsPDF.f2".  This helper ensures colours are
 * properly converted before being used in the PDF generator.
 *
 * @param {string} hex A hexadecimal colour string beginning with '#'.
 * @returns {number[]} An array [r, g, b] representing the colour.
 */
function hexToRgb(hex) {
    if (!hex) return [0, 0, 0];
    let h = hex.replace('#', '');
    // If a shorthand hex code is provided (e.g. #abc) expand it to full form.
    if (h.length === 3) {
        h = h.split('').map(ch => ch + ch).join('');
    }
    const bigint = parseInt(h, 16);
    const r = (bigint >> 16) & 255;
    const g = (bigint >> 8) & 255;
    const b = bigint & 255;
    return [r, g, b];
}

// Initialize Application
document.addEventListener('DOMContentLoaded', function() {
    console.log('Safety Analytics Platform - Amazon WHS Austria');
    console.log('Developed by Erwin Esener @eeesener');
    initializeCharts();
    setupEventListeners();
    createRiskMatrices();
    setupTableSorting('injury');
    setupTableSorting('nearmiss');

    // Check for saved theme preference
    const savedTheme = localStorage.getItem('theme') || 'light';
    if (savedTheme === 'dark') {
        toggleTheme();
    }
});

// Standardized and categorized chart options for all views
const CHART_OPTIONS = {
    injury: [
        // Distribution & Overview
        { value: 'severity', label: 'üìä Severity Distribution', category: 'distribution' },
        { value: 'site', label: 'üè¢ Site Comparison', category: 'distribution' },
        { value: 'recordableDistribution', label: 'üìù Recordable vs Non-Recordable', category: 'distribution' },

        // Trends
        { value: 'trend', label: 'üìà Monthly Injury Trend', category: 'trends' },
        { value: 'recordableTrend', label: 'üìä Recordable Rate Trend', category: 'trends' },
        { value: 'severityTrend', label: 'üéØ Severity Trend Over Time', category: 'trends' },

        // Body Part Analysis (Injury-specific)
        { value: 'bodyPart', label: 'ü¶¥ Body Parts Affected', category: 'anatomy' },
        { value: 'bodyPartTrend', label: 'üìä Body Part Trends', category: 'anatomy' },
        { value: 'bodyPartHeatmap', label: 'üî• Body Part by Severity', category: 'anatomy' },
        { value: 'bodyPartBySite', label: 'üè¢ Body Parts by Site', category: 'anatomy' },

        // Type & Mechanism (Injury-specific)
        { value: 'injuryType', label: 'üè• Injury Types', category: 'type' },
        { value: 'mechanismOfInjury', label: '‚öôÔ∏è How Injuries Occur', category: 'type' },
        { value: 'injuryTypeByProcess', label: 'üîÑ Injury Type by Process', category: 'type' },

        // Process & Operations
        { value: 'processPath', label: 'üîÑ Process Path Analysis', category: 'operations' },
        { value: 'shiftAnalysis', label: 'üïê Injuries by Shift', category: 'operations' },
        { value: 'departmentAnalysis', label: 'üè≠ Department Analysis', category: 'operations' },

        // Root Cause & Contributing Factors
        { value: 'rootCause', label: 'üîç Root Cause Analysis', category: 'causation' },
        { value: 'contributingFactors', label: 'üîó Contributing Factors', category: 'causation' },
        { value: 'rootCauseBySite', label: 'üè¢ Root Causes by Site', category: 'causation' },
        { value: 'rootCauseTrend', label: 'üìà Root Cause Trends', category: 'causation' },

        // Performance Metrics (Injury-specific)
        { value: 'recordableRate', label: 'üìä Recordable Rate by Site', category: 'metrics' },
        { value: 'dafwAnalysis', label: 'üìÖ Days Away From Work', category: 'metrics' },
        { value: 'dafwDistribution', label: 'üìä DAFW Distribution', category: 'metrics' },
        { value: 'otrAnalysis', label: 'üöó OTR vs UTR Analysis', category: 'metrics' },
        { value: 'lostTimeAnalysis', label: '‚è±Ô∏è Lost Time Analysis', category: 'metrics' },

        // Advanced Analytics
        { value: 'severityPrediction', label: 'üîÆ Severity Patterns', category: 'advanced' },
        { value: 'recoveryTimeAnalysis', label: 'üè• Recovery Time Analysis', category: 'advanced' },
        { value: 'costImpactAnalysis', label: 'üí∞ Cost Impact Analysis', category: 'advanced' }
    ],

    nearMiss: [
        // Distribution & Overview
        { value: 'severity', label: 'üìä Potential Severity Distribution', category: 'distribution' },
        { value: 'site', label: 'üè¢ Site Comparison', category: 'distribution' },
        { value: 'statusDistribution', label: 'üìã Status Overview', category: 'distribution' },

        // Trends
        { value: 'trend', label: 'üìà Near Miss Trend', category: 'trends' },
        { value: 'riskTrend', label: 'üé≤ Risk Score Trend', category: 'trends' },
        { value: 'severityTrend', label: 'üéØ Severity Trend Over Time', category: 'trends' },

        // Location Analysis (Near Miss-specific)
        { value: 'location', label: 'üìç Top Incident Locations', category: 'location' },
        { value: 'locationHeatmap', label: 'üî• Location Risk Heat Map', category: 'location' },
        { value: 'locationTrend', label: 'üìà Location Trends', category: 'location' },
        { value: 'locationBySeverity', label: 'üéØ Location by Severity', category: 'location' },

        // Impact Analysis (Near Miss-specific)
        { value: 'impact', label: 'üí• Primary Impact Types', category: 'impact' },
        { value: 'impactSeverity', label: 'üéØ Impact vs Severity', category: 'impact' },
        { value: 'impactByLocation', label: 'üìç Impact by Location', category: 'impact' },
        { value: 'impactTrend', label: 'üìà Impact Type Trends', category: 'impact' },

        // Process & Operations
        { value: 'processPath', label: 'üîÑ Process Path Analysis', category: 'operations' },
        { value: 'processRisk', label: '‚ö†Ô∏è Process Risk Score', category: 'operations' },
        { value: 'processHeatmap', label: 'üî• Process Risk Heat Map', category: 'operations' },

        // Risk Analysis (Near Miss-specific)
        { value: 'riskScore', label: 'üé≤ Risk Score Distribution', category: 'risk' },
        { value: 'riskMatrix', label: '‚¨ú Risk Matrix Overview', category: 'risk' },
        { value: 'likelihood', label: 'üìä Likelihood Analysis', category: 'risk' },
        { value: 'likelihoodTrend', label: 'üìà Likelihood Trends', category: 'risk' },

        // Contributing Factors
        { value: 'contributingFactors', label: 'üîó Contributing Factors', category: 'causation' },
        { value: 'rootCause', label: 'üîç Root Cause Analysis', category: 'causation' },
        { value: 'hazardCategories', label: '‚ö†Ô∏è Hazard Categories', category: 'causation' },

        // Prevention & Mitigation
        { value: 'preventionEffectiveness', label: 'üõ°Ô∏è Prevention Opportunities', category: 'prevention' },
        { value: 'mitigationStatus', label: '‚úÖ Mitigation Status', category: 'prevention' },
        { value: 'closureAnalysis', label: 'üìä Closure Rate Analysis', category: 'prevention' },

        // Advanced Analytics
        { value: 'nearMissToInjuryRatio', label: 'üìä Near Miss/Injury Correlation', category: 'advanced' },
        { value: 'predictiveRisk', label: 'üîÆ Predictive Risk Areas', category: 'advanced' },
        { value: 'hotspotAnalysis', label: 'üî• Risk Hotspot Analysis', category: 'advanced' }
    ]
};

// Theme Toggle
function toggleTheme() {
    const body = document.body;
    const themeIcon = document.getElementById('themeIcon');
    const themeText = document.getElementById('themeText');
    
    if (body.getAttribute('data-theme') === 'dark') {
        body.removeAttribute('data-theme');
        themeIcon.textContent = 'üåô';
        themeText.textContent = 'Dark Mode';
        state.theme = 'light';
    } else {
        body.setAttribute('data-theme', 'dark');
        themeIcon.textContent = '‚òÄÔ∏è';
        themeText.textContent = 'Light Mode';
        state.theme = 'dark';
    }
    
    localStorage.setItem('theme', state.theme);
    updateAllCharts();
}

// Module Switching
function switchModule(module) {
    document.querySelectorAll('.nav-tab').forEach(tab => {
        tab.classList.remove('active');
    });
    event.target.closest('.nav-tab').classList.add('active');
    
    document.querySelectorAll('.tab-content').forEach(content => {
        content.classList.remove('active');
    });
    
    document.getElementById(module).classList.add('active');
    state.currentModule = module;
    
    if (module === 'injury') {
        updateInjuryDashboard();
        updateInjuryTable();
        updateInjuryCharts();
    } else if (module === 'nearmiss') {
        updateNearMissDashboard();
        updateNearMissTable();
        updateNearMissCharts();
    } else if (module === 'combined') {
        updateCombinedAnalytics();
    } else if (module === 'actions') {
        updateActionItems();
    }
}

// Sub-view switching for Injury module
function switchInjuryView(view) {
    document.querySelectorAll('#injury .sub-nav-item').forEach(item => {
        item.classList.remove('active');
    });
    event.target.classList.add('active');
    
    document.querySelectorAll('.injury-view').forEach(v => {
        v.classList.add('hidden');
    });
    
    document.getElementById('injury' + view.charAt(0).toUpperCase() + view.slice(1)).classList.remove('hidden');
    
    if (view === 'timeline') {
        updateInjuryTimeline();
    } else if (view === 'analytics') {
        updateInjuryAdvancedAnalytics();
    } else if (view === 'riskMatrix') {
        updateInjuryRiskMatrix();
    } else if (view === 'quality') {
        updateInjuryQualityMetrics();
    }
}

// Sub-view switching for Near Miss module
function switchNearMissView(view) {
    document.querySelectorAll('#nearmiss .sub-nav-item').forEach(item => {
        item.classList.remove('active');
    });
    event.target.classList.add('active');
    
    document.querySelectorAll('.nearmiss-view').forEach(v => {
        v.classList.add('hidden');
    });
    
    document.getElementById('nearMiss' + view.charAt(0).toUpperCase() + view.slice(1)).classList.remove('hidden');
    
    if (view === 'timeline') {
        updateNearMissTimeline();
    } else if (view === 'analytics') {
        updateNearMissAdvancedAnalytics();
    } else if (view === 'riskMatrix') {
        updateNearMissRiskMatrix();
    } else if (view === 'quality') {
        updateNearMissQualityMetrics();
    }
}

// File Handling
function handleFileUpload(event, type) {
    const file = event.target.files[0];
    if (!file) return;
    
    showStatus(`Processing ${type} file...`, 'info');
    
    const reader = new FileReader();
    reader.onload = function(e) {
        parseCSV(e.target.result, type);
    };
    reader.onerror = function() {
        showStatus('Error reading file', 'error');
    };
    reader.readAsText(file);
}

// Drag and Drop
function handleDrop(event, type) {
    event.preventDefault();
    event.stopPropagation();
    
    const uploadArea = event.target.closest('.upload-area');
    uploadArea.classList.remove('dragging');
    
    const files = event.dataTransfer.files;
    if (files.length > 0) {
        const file = files[0];
        if (file.type === 'text/csv' || file.name.endsWith('.csv')) {
            const input = type === 'injury' ? 
                document.getElementById('injuryFile') : 
                document.getElementById('nearMissFile');
            
            const dataTransfer = new DataTransfer();
            dataTransfer.items.add(file);
            input.files = dataTransfer.files;
            
            handleFileUpload({ target: input }, type);
        } else {
            showStatus('Please upload a CSV file', 'error');
        }
    }
}

function handleDragOver(event) {
    event.preventDefault();
    event.stopPropagation();
    event.target.closest('.upload-area').classList.add('dragging');
}

function handleDragLeave(event) {
    event.preventDefault();
    event.stopPropagation();
    event.target.closest('.upload-area').classList.remove('dragging');
}

// CSV Parsing
function parseCSV(csvText, type) {
    Papa.parse(csvText, {
        header: true,
        dynamicTyping: true,
        skipEmptyLines: true,
        complete: function(results) {
            if (type === 'injury') {
                state.injury.rawData = results.data;
                processInjuryData();
                populateInjuryFilters();
                applyFilters('injury');
                calculateQualityMetrics('injury');
                showStatus(`Loaded ${results.data.length} injury records successfully!`, 'success');
            } else {
                state.nearMiss.rawData = results.data;
                processNearMissData();
                populateNearMissFilters();
                applyFilters('nearmiss');
                calculateQualityMetrics('nearmiss');
                showStatus(`Loaded ${results.data.length} near miss records successfully!`, 'success');
            }
            
            updateOverview();
            initializeChartSelections();
        },
        error: function(error) {
            showStatus('Failed to parse CSV: ' + error.message, 'error');
        }
    });
}

// Initialize chart selections with categorized options
function initializeChartSelections() {
    // Helper function to create categorized dropdown HTML
    const createCategorizedOptions = (options) => {
        const categories = {};

        // Group options by category
        options.forEach(option => {
            if (!categories[option.category]) {
                categories[option.category] = [];
            }
            categories[option.category].push(option);
        });

        // Build HTML with optgroups
        let html = '';
        const categoryLabels = {
            'distribution': 'üìä Distribution & Overview',
            'trends': 'üìà Trend Analysis',
            'anatomy': 'ü¶¥ Body Part Analysis',
            'type': 'üè• Injury Type Analysis',
            'location': 'üìç Location Analysis',
            'impact': 'üí• Impact Analysis',
            'operations': 'üîÑ Operations & Process',
            'causation': 'üîç Root Cause Analysis',
            'metrics': 'üìä Performance Metrics',
            'risk': 'üé≤ Risk Analysis',
            'prevention': 'üõ°Ô∏è Prevention & Mitigation',
            'advanced': 'üî¨ Advanced Analytics'
        };

        Object.entries(categories).forEach(([category, categoryOptions]) => {
            html += `<optgroup label="${categoryLabels[category] || category}">`;
            categoryOptions.forEach(opt => {
                html += `<option value="${opt.value}">${opt.label}</option>`;
            });
            html += '</optgroup>';
        });

        return html;
    };

    // Update Injury chart selectors
    const injuryOptionsHTML = createCategorizedOptions(CHART_OPTIONS.injury);
    const injurySelectors = document.querySelectorAll('#injury .chart-header select');
    injurySelectors.forEach((selector, index) => {
        selector.innerHTML = injuryOptionsHTML;
        // Set different default values for each view
        const injuryDefaults = ['severity', 'bodyPart', 'rootCause', 'trend'];
        selector.value = injuryDefaults[index] || 'severity';
    });

    // Update Near Miss chart selectors
    const nearMissOptionsHTML = createCategorizedOptions(CHART_OPTIONS.nearMiss);
    const nearMissSelectors = document.querySelectorAll('#nearmiss .chart-header select');
    nearMissSelectors.forEach((selector, index) => {
        selector.innerHTML = nearMissOptionsHTML;
        // Set different defaults for near miss
        const nearMissDefaults = ['severity', 'location', 'impact', 'riskTrend'];
        selector.value = nearMissDefaults[index] || 'severity';
    });
}

// Data Processing - Injury
function processInjuryData() {
    state.injury.rawData.forEach((row, index) => {
        // Parse dates
        if (row.incident_date) {
            row.parsedDate = new Date(row.incident_date);
        }
        
        // Standardize severity
        row.severity = standardizeSeverity(row.severity || row.potential_severity);
        
        // Ensure numeric values
        row.recordable = parseInt(row.recordable) || 0;
        row.total_dafw_days = parseInt(row.total_dafw_days) || 0;
        row.total_rwa_days = parseInt(row.total_rwa_days) || 0;
        
        // Generate ID if needed
        if (!row.case_number) {
            row.case_number = `CASE-${index + 1}`;
        }
        
        // Extract body part
        row.bodyPart = row.initial_info_principal_body_part || 
                      row.initial_info_detailed_body_part || 
                      'Unknown';
        
        // Extract OTR status
        if (row.initial_info_incident_on_the_road === true) {
            row.otr = 'yes';
        } else if (row.initial_info_incident_on_the_road === false) {
            row.otr = 'no';
        } else {
            row.otr = row.initial_info_incident_on_the_road || 'no';
            if (typeof row.otr === 'string') {
                row.otr = row.otr.toLowerCase();
            }
            if (row.otr === '1' || row.otr === 'true' || row.otr === 'yes' || row.otr === 'y') {
                row.otr = 'yes';
            } else {
                row.otr = 'no';
            }
        }
        
        // Extract root cause
        row.rootCause = row.rca_primary_cause || 'Under Investigation';
        
        // Extract contributing factors
        row.contributingFactor = row.rca_contributing_factor_category || 'Unknown';
        
        // Process path
        row.processPath = row.initial_info_process_path || 'Unknown';
        
        // Extract Austin URL - check multiple possible column names
        row.austin_url = row.austin_url || 
                        row.austin_case_study_url || 
                        row.austin_link || 
                        row.case_study_url ||
                        row.austin_case_url ||
                        row.incident_url ||
                        '#'; // Fallback to # if no URL found
        
        // Validate URL format
        if (row.austin_url && row.austin_url !== '#') {
            if (!row.austin_url.startsWith('http://') && !row.austin_url.startsWith('https://')) {
                row.austin_url = 'https://' + row.austin_url;
            }
        }
        
        // Standardize likelihood
        row.standardized_likelihood = standardizeLikelihood(row.initial_risk_assessment_likeliness);
        
        // Extract impact type
        row.impactType = row.initial_info_impact_type_primary || row.type || 'Unknown';
    });
}

// Data Processing - Near Miss
function processNearMissData() {
    state.nearMiss.rawData.forEach((row, index) => {
        // Parse dates
        if (row.nearmiss_date) {
            row.parsedDate = new Date(row.nearmiss_date);
        }
        
        // Use potential_severity
        row.severity = standardizeSeverity(row.potential_severity || row.severity);
        
        // Standardize likelihood
        row.standardized_likelihood = standardizeLikelihood(row.initial_risk_assessment_likeliness);
        
        // Calculate risk score if not present
        if (!row.risk || row.risk === '' || row.risk === 0) {
            row.risk = calculateRiskScore(row);
        }
        
        // Generate ID if needed
        if (!row.incident_id) {
            const date = row.parsedDate || new Date();
            const site = (row.site && row.site.trim()) ? row.site.trim() : 'XX';
            const year = date.getFullYear();
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const seq = String(index + 1).padStart(3, '0');
            row.incident_id = `NM-${site}-${year}${month}-${seq}`;
        }
        
        // Extract primary impact
        row.primaryImpact = row.initial_info_primary_impact || 'Unknown';
        row.impactType = row.primaryImpact; // Standardize for chart compatibility
        
        // Extract location
        row.location = row.initial_info_location_event || 'Unknown';
        
        // Process path
        row.processPath = row.initial_info_process_path || 'Unknown';

        // Extract Austin URL - check multiple possible column names
        row.austin_url = row.austin_url || 
                        row.austin_case_study_url || 
                        row.austin_link || 
                        row.case_study_url ||
                        row.austin_case_url ||
                        row.incident_url ||
                        row.case_url ||
                        row.link ||
                        '#'; // Fallback to # if no URL found

        // Validate URL format
        if (row.austin_url && row.austin_url !== '#') {
            if (!row.austin_url.startsWith('http://') && !row.austin_url.startsWith('https://')) {
                row.austin_url = 'https://' + row.austin_url;
            }
        }

        // Contributing factors
        row.contributingFactor = row.rca_contributing_factor_category || 'Unknown';
        
        // Root cause (for standardization with injury)
        row.rootCause = row.rca_primary_cause || 'Under Investigation';
    });
}

// Calculate Quality Metrics
function calculateQualityMetrics(type) {
    const data = type === 'injury' ? state.injury.rawData : state.nearMiss.rawData;
    const metrics = {
        totalRecords: data.length,
        duplicates: 0,
        missingCriticalFields: 0,
        dataCompleteness: 0,
        qualityScore: 0,
        duplicateDetails: [],
        missingFieldsDetails: {},
        recommendations: [],
        // Add word analysis metrics
        wordAnalysis: {
            totalWords: 0,
            averageWords: 0,
            minWords: Infinity,
            maxWords: 0,
            distribution: {}
        }
    };

    // Check for duplicates
    if (type === 'nearmiss') {
        const seen = new Map();
        data.forEach((row, index) => {
            const key = `${row.nearmiss_date}-${row.site}-${row.location}-${row.initial_info_primary_impact}`;
            if (seen.has(key)) {
                metrics.duplicates++;
                const existingIndex = seen.get(key);
                // Group duplicates together
                const found = metrics.duplicateDetails.find(d => d.indices.includes(existingIndex));
                if (found) {
                    found.indices.push(index);
                } else {
                    metrics.duplicateDetails.push({
                        key,
                        indices: [existingIndex, index],
                        data: {
                            date: row.nearmiss_date,
                            site: row.site,
                            location: row.location || 'Unknown',
                            impact: row.initial_info_primary_impact || 'Unknown'
                        }
                    });
                }
            } else {
                seen.set(key, index);
            }
        });
    }

    // Word count analysis for near miss
    if (type === 'nearmiss') {
        data.forEach(row => {
            let wordCount = 0;
            // Count words in description and other text fields
            const textFields = [
                row.initial_info_incident_description,
                row.initial_info_nearmiss_type,
                row.rca_comments,
                row.investigation_evidence_near_incident_location
            ];

            textFields.forEach(field => {
                if (field && typeof field === 'string') {
                    const words = field.trim().split(/\s+/).filter(w => w.length > 0);
                    wordCount += words.length;
                }
            });

            metrics.wordAnalysis.totalWords += wordCount;
            metrics.wordAnalysis.minWords = Math.min(metrics.wordAnalysis.minWords, wordCount);
            metrics.wordAnalysis.maxWords = Math.max(metrics.wordAnalysis.maxWords, wordCount);

            // Word count distribution
            const range = wordCount === 0 ? '0' :
                         wordCount <= 10 ? '1-10' :
                         wordCount <= 25 ? '11-25' :
                         wordCount <= 50 ? '26-50' : '50+';
            metrics.wordAnalysis.distribution[range] = (metrics.wordAnalysis.distribution[range] || 0) + 1;
        });

        metrics.wordAnalysis.averageWords = data.length > 0 ? 
            Math.round(metrics.wordAnalysis.totalWords / data.length) : 0;

        if (metrics.wordAnalysis.minWords === Infinity) {
            metrics.wordAnalysis.minWords = 0;
        }
    }

    // Check critical fields
    const criticalFields = type === 'injury' ? 
        ['incident_date', 'site', 'severity', 'bodyPart', 'recordable'] :
        ['nearmiss_date', 'site', 'severity', 'location', 'risk'];

    criticalFields.forEach(field => {
        metrics.missingFieldsDetails[field] = 0;
    });

    data.forEach(row => {
        criticalFields.forEach(field => {
            const value = field === 'bodyPart' ? row.bodyPart : 
                         field === 'location' ? row.location :
                         row[field];

            if (!value || value === 'Unknown' || value === '') {
                metrics.missingFieldsDetails[field]++;
                metrics.missingCriticalFields++;
            }
        });
    });

    // Calculate completeness
    const totalFields = data.length * criticalFields.length;
    const filledFields = totalFields - metrics.missingCriticalFields;
    metrics.dataCompleteness = totalFields > 0 ? 
        Math.round((filledFields / totalFields) * 100) : 0;

    // Calculate quality score for near miss with word count consideration
    if (type === 'nearmiss') {
        const duplicatePenalty = metrics.totalRecords > 0
            ? Math.max(0, 100 - (metrics.duplicates / metrics.totalRecords) * 100)
            : 100;
        const completenessPenalty = metrics.dataCompleteness;
        const wordCountScore = metrics.wordAnalysis.averageWords >= 15 ? 100 :
                              metrics.wordAnalysis.averageWords >= 10 ? 80 :
                              metrics.wordAnalysis.averageWords >= 5 ? 60 : 40;

        metrics.qualityScore = Math.round((duplicatePenalty + completenessPenalty + wordCountScore) / 3);
    } else {
        metrics.qualityScore = metrics.dataCompleteness;
    }

    // Generate recommendations
    if (type === 'nearmiss') {
        if (metrics.duplicates > 0) {
            metrics.recommendations.push({
                type: 'warning',
                text: `Found ${metrics.duplicates} potential duplicate records. Review and consolidate.`,
                icon: 'üîÑ'
            });
        }

        if (metrics.wordAnalysis.averageWords < 10) {
            metrics.recommendations.push({
                type: 'critical',
                text: `Low description quality: Average ${metrics.wordAnalysis.averageWords} words per record. Aim for 15+ words.`,
                icon: 'üìù'
            });
        }

        if (metrics.dataCompleteness < 80) {
            metrics.recommendations.push({
                type: 'warning',
                text: `Data completeness is ${metrics.dataCompleteness}%. Fill in missing location and risk data.`,
                icon: '‚ö†Ô∏è'
            });
        }

        const lowWordCount = metrics.wordAnalysis.distribution['0'] || 0;
        if (lowWordCount > data.length * 0.2) {
            metrics.recommendations.push({
                type: 'critical',
                text: `${lowWordCount} records (${Math.round(lowWordCount/data.length*100)}%) have no description.`,
                icon: '‚ùå'
            });
        }
    }

    // Store metrics
    if (type === 'injury') {
        state.injury.qualityMetrics = metrics;
    } else {
        state.nearMiss.qualityMetrics = metrics;
    }

    return metrics;
}

// Update Quality Metrics Display
function updateInjuryQualityMetrics() {
    const metrics = state.injury.qualityMetrics;
    updateQualityDisplay('injury', metrics);
}

function updateNearMissQualityMetrics() {
    const metrics = state.nearMiss.qualityMetrics;
    updateQualityDisplay('nearmiss', metrics);
}

function updateQualityDisplay(type, metrics) {
    const containerId = type === 'nearmiss' ? 'nearMissQuality' : `${type}Quality`;
    const container = document.getElementById(containerId);
    if (!container || !metrics || !metrics.totalRecords) {
        if (container) {
            container.innerHTML = '<p style="text-align: center; padding: 2rem;">No data loaded for quality analysis.</p>';
        }
        return;
    }

    const qualityClass = metrics.qualityScore >= 90 ? 'excellent' : 
                        metrics.qualityScore >= 70 ? 'good' : 
                        metrics.qualityScore >= 50 ? 'warning' : 'poor';

    const qualityEmoji = metrics.qualityScore >= 90 ? 'üåü' : 
                        metrics.qualityScore >= 70 ? '‚úÖ' : 
                        metrics.qualityScore >= 50 ? '‚ö†Ô∏è' : '‚ùå';

    // Enhanced HTML with better visual design
    container.innerHTML = `
        <div class="quality-metrics-container">
            <!-- Main Score Card -->
            <div class="quality-score-card-enhanced">
                <div class="quality-score-visual">
                    <div class="quality-score-circle ${qualityClass}">
                        <div class="quality-score-inner">
                            <div class="quality-emoji">${qualityEmoji}</div>
                            <div class="quality-score-value">${metrics.qualityScore}%</div>
                            <div class="quality-score-label">Overall Quality</div>
                        </div>
                    </div>
                    <div class="quality-score-ring">
                        <svg viewBox="0 0 200 200">
                            <circle cx="100" cy="100" r="90" fill="none" stroke="#e0e0e0" stroke-width="10"/>
                            <circle cx="100" cy="100" r="90" fill="none" 
                                stroke="${qualityClass === 'excellent' ? '#4CAF50' : 
                                         qualityClass === 'good' ? '#FFC107' : 
                                         qualityClass === 'warning' ? '#FF9800' : '#FF5722'}"
                                stroke-width="10"
                                stroke-dasharray="${metrics.qualityScore * 5.65} 565"
                                stroke-dashoffset="0"
                                transform="rotate(-90 100 100)"
                                style="transition: stroke-dasharray 1s ease;"/>
                        </svg>
                    </div>
                </div>
                
                ${type === 'nearmiss' ? `
                <!-- Word Analysis Summary -->
                <div class="word-analysis-summary">
                    <h4>üìù Description Quality</h4>
                    <div class="word-stats-grid">
                        <div class="word-stat">
                            <div class="word-stat-value">${metrics.wordAnalysis.averageWords}</div>
                            <div class="word-stat-label">Avg Words</div>
                        </div>
                        <div class="word-stat">
                            <div class="word-stat-value">${metrics.wordAnalysis.minWords}-${metrics.wordAnalysis.maxWords}</div>
                            <div class="word-stat-label">Range</div>
                        </div>
                        <div class="word-stat">
                            <div class="word-stat-value">${metrics.totalRecords}</div>
                            <div class="word-stat-label">Records</div>
                        </div>
                    </div>
                </div>
                ` : ''}
            </div>
            
            <!-- Key Metrics Cards -->
            <div class="quality-metrics-grid">
                <div class="quality-metric-card">
                    <div class="metric-icon-large">üìä</div>
                    <div class="metric-content">
                        <div class="metric-value">${metrics.totalRecords}</div>
                        <div class="metric-label">Total Records</div>
                    </div>
                </div>
                
                ${type === 'nearmiss' ? `
                <div class="quality-metric-card ${metrics.duplicates > 0 ? 'has-issue' : ''}">
                    <div class="metric-icon-large">üîÑ</div>
                    <div class="metric-content">
                        <div class="metric-value">${metrics.duplicates}</div>
                        <div class="metric-label">Duplicates Found</div>
                    </div>
                </div>
                
                <div class="quality-metric-card">
                    <div class="metric-icon-large">üìù</div>
                    <div class="metric-content">
                        <div class="metric-value">${metrics.wordAnalysis.totalWords}</div>
                        <div class="metric-label">Total Words</div>
                    </div>
                </div>
                ` : `
                <div class="quality-metric-card">
                    <div class="metric-icon-large">‚ö†Ô∏è</div>
                    <div class="metric-content">
                        <div class="metric-value">${metrics.missingCriticalFields}</div>
                        <div class="metric-label">Missing Fields</div>
                    </div>
                </div>
                `}
                
                <div class="quality-metric-card">
                    <div class="metric-icon-large">‚úÖ</div>
                    <div class="metric-content">
                        <div class="metric-value">${metrics.dataCompleteness}%</div>
                        <div class="metric-label">Completeness</div>
                    </div>
                </div>
            </div>
            
            ${type === 'nearmiss' && metrics.duplicateDetails.length > 0 ? `
            <!-- Duplicate Records Section -->
            <div class="quality-section duplicate-section">
                <div class="section-header">
                    <h4><span class="section-icon">üîÑ</span> Duplicate Records Detected</h4>
                    <span class="duplicate-count">${metrics.duplicateDetails.length} groups</span>
                </div>
                <div class="duplicate-list">
                    ${metrics.duplicateDetails.slice(0, 5).map((dup, index) => `
                        <div class="duplicate-item">
                            <div class="duplicate-number">${index + 1}</div>
                            <div class="duplicate-content">
                                <div class="duplicate-key">
                                    <span class="dup-field"><i>üìÖ</i> ${dup.data.date || 'No date'}</span>
                                    <span class="dup-field"><i>üè¢</i> ${dup.data.site}</span>
                                    <span class="dup-field"><i>üìç</i> ${dup.data.location}</span>
                                </div>
                                <div class="duplicate-rows">
                                    Rows: ${dup.indices.map(i => `<span class="row-badge">#${i + 1}</span>`).join(' ')}
                                    <span class="duplicate-action" onclick="showDuplicateDetails(${index}, '${type}')">‚Üí Review & Merge</span>
                                </div>
                            </div>
                        </div>
                    `).join('')}
                    ${metrics.duplicateDetails.length > 5 ?
                        `<div class="more-duplicates" onclick="showAllDuplicates('${type}')">
                            <i>‚ûï</i> ${metrics.duplicateDetails.length - 5} more duplicate groups...
                        </div>` : ''}
                </div>
            </div>
            ` : ''}
            
            ${type === 'nearmiss' ? `
            <!-- Word Count Distribution -->
            <div class="quality-section">
                <h4><span class="section-icon">üìä</span> Description Word Count Distribution</h4>
                <div class="word-distribution">
                    ${Object.entries(metrics.wordAnalysis.distribution).map(([range, count]) => {
                        const percentage = (count / metrics.totalRecords * 100).toFixed(1);
                        const barClass = range === '0' ? 'bar-critical' : 
                                       range === '1-10' ? 'bar-warning' : 
                                       range === '11-25' ? 'bar-good' : 'bar-excellent';
                        return `
                            <div class="distribution-row">
                                <div class="dist-label">${range} words</div>
                                <div class="dist-bar-container">
                                    <div class="dist-bar ${barClass}" style="width: ${percentage}%"></div>
                                    <span class="dist-value">${count} (${percentage}%)</span>
                                </div>
                            </div>
                        `;
                    }).join('')}
                </div>
            </div>
            
            <!-- Word Heat Map -->
            <div class="quality-section">
                <h4><span class="section-icon">üî•</span> Most Common Words</h4>
                <div id="nearMissWordHeatMap" class="word-heatmap-enhanced"></div>
            </div>
            ` : `
            <!-- Missing Fields Chart -->
            <div class="quality-section">
                <h4><span class="section-icon">üìä</span> Missing Fields Analysis</h4>
                <div class="missing-fields-chart">
                    <canvas id="${type}MissingFieldsChart"></canvas>
                </div>
            </div>
            `}
            
            <!-- Recommendations -->
            <div class="quality-section recommendations-section">
                <h4><span class="section-icon">üí°</span> Quality Improvement Recommendations</h4>
                <div class="recommendations-list">
                    ${metrics.recommendations.map(rec => `
                        <div class="recommendation-item ${rec.type}">
                            <div class="rec-icon">${rec.icon || (rec.type === 'critical' ? 'üö®' : '‚ö†Ô∏è')}</div>
                            <div class="rec-content">
                                <div class="rec-text">${rec.text}</div>
                                ${rec.type === 'critical' ? 
                                    '<div class="rec-priority">High Priority</div>' : ''}
                            </div>
                        </div>
                    `).join('')}
                    ${metrics.recommendations.length === 0 ? 
                        '<div class="recommendation-item success"><div class="rec-icon">üéâ</div><div class="rec-content"><div class="rec-text">Excellent data quality! Keep up the good work.</div></div></div>' : ''}
                </div>
            </div>
        </div>
    `;
    
    // Add enhanced CSS styles
    const styleId = 'quality-enhancement-styles';
    if (!document.getElementById(styleId)) {
        const style = document.createElement('style');
        style.id = styleId;
        style.textContent = `
            .quality-score-card-enhanced {
                background: linear-gradient(135deg, #f5f5f5 0%, #ffffff 100%);
                border-radius: 16px;
                padding: 2rem;
                margin-bottom: 2rem;
                box-shadow: 0 4px 20px rgba(0,0,0,0.08);
                display: flex;
                gap: 3rem;
                align-items: center;
            }
            
            [data-theme="dark"] .quality-score-card-enhanced {
                background: linear-gradient(135deg, #2d2d2d 0%, #1a1a1a 100%);
            }
            
            .quality-score-visual {
                position: relative;
                width: 200px;
                height: 200px;
            }
            
            .quality-score-circle {
                width: 180px;
                height: 180px;
                border-radius: 50%;
                display: flex;
                align-items: center;
                justify-content: center;
                position: absolute;
                top: 10px;
                left: 10px;
                background: white;
                z-index: 2;
            }
            
            [data-theme="dark"] .quality-score-circle {
                background: #1a1a1a;
            }
            
            .quality-score-ring {
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                z-index: 1;
            }
            
            .quality-score-inner {
                text-align: center;
            }
            
            .quality-emoji {
                font-size: 3rem;
                margin-bottom: 0.5rem;
            }
            
            .quality-score-value {
                font-size: 2.5rem;
                font-weight: 700;
                margin: 0;
            }
            
            .quality-score-circle.excellent { color: #4CAF50; }
            .quality-score-circle.good { color: #FFC107; }
            .quality-score-circle.warning { color: #FF9800; }
            .quality-score-circle.poor { color: #FF5722; }
            
            .word-analysis-summary {
                flex: 1;
                background: rgba(255, 153, 0, 0.05);
                border-radius: 12px;
                padding: 1.5rem;
                border: 1px solid rgba(255, 153, 0, 0.2);
            }
            
            .word-analysis-summary h4 {
                margin: 0 0 1rem 0;
                color: var(--amazon-orange);
            }
            
            .word-stats-grid {
                display: grid;
                grid-template-columns: repeat(3, 1fr);
                gap: 1rem;
            }
            
            .word-stat {
                text-align: center;
            }
            
            .word-stat-value {
                font-size: 1.5rem;
                font-weight: 700;
                color: var(--text-primary);
            }
            
            .word-stat-label {
                font-size: 0.8rem;
                color: var(--text-secondary);
                margin-top: 0.25rem;
            }
            
            .quality-metrics-grid {
                display: grid;
                grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
                gap: 1rem;
                margin-bottom: 2rem;
            }
            
            .quality-metric-card {
                background: white;
                border-radius: 12px;
                padding: 1.5rem;
                display: flex;
                align-items: center;
                gap: 1rem;
                box-shadow: 0 2px 8px rgba(0,0,0,0.06);
                transition: all 0.3s ease;
                border: 1px solid transparent;
            }
            
            [data-theme="dark"] .quality-metric-card {
                background: #2d2d2d;
            }
            
            .quality-metric-card:hover {
                transform: translateY(-2px);
                box-shadow: 0 4px 16px rgba(0,0,0,0.1);
            }
            
            .quality-metric-card.has-issue {
                border-color: var(--danger);
                background: rgba(255, 87, 34, 0.05);
            }
            
            .metric-icon-large {
                font-size: 2.5rem;
            }
            
            .metric-content {
                flex: 1;
            }
            
            .duplicate-section {
                background: rgba(255, 87, 34, 0.05);
                border: 1px solid rgba(255, 87, 34, 0.2);
                border-radius: 12px;
                padding: 1.5rem;
                margin: 1.5rem 0;
            }
            
            .section-header {
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 1rem;
            }
            
            .section-header h4 {
                margin: 0;
                display: flex;
                align-items: center;
                gap: 0.5rem;
                color: var(--danger);
            }
            
            .section-icon {
                font-size: 1.2rem;
            }
            
            .duplicate-count {
                background: var(--danger);
                color: white;
                padding: 0.25rem 0.75rem;
                border-radius: 20px;
                font-size: 0.85rem;
                font-weight: 600;
            }
            
            .duplicate-list {
                display: grid;
                gap: 0.75rem;
            }
            
            .duplicate-item {
                background: white;
                border-radius: 8px;
                padding: 1rem;
                display: flex;
                gap: 1rem;
                align-items: center;
                border: 1px solid rgba(0,0,0,0.1);
            }
            
            [data-theme="dark"] .duplicate-item {
                background: #1a1a1a;
            }
            
            .duplicate-number {
                width: 32px;
                height: 32px;
                background: var(--danger);
                color: white;
                border-radius: 50%;
                display: flex;
                align-items: center;
                justify-content: center;
                font-weight: 700;
                flex-shrink: 0;
            }
            
            .duplicate-content {
                flex: 1;
            }
            
            .duplicate-key {
                display: flex;
                gap: 1rem;
                margin-bottom: 0.5rem;
                flex-wrap: wrap;
            }
            
            .dup-field {
                font-size: 0.85rem;
                color: var(--text-secondary);
                display: flex;
                align-items: center;
                gap: 0.25rem;
            }
            
            .dup-field i {
                font-style: normal;
                opacity: 0.7;
            }
            
            .duplicate-rows {
                font-size: 0.8rem;
                color: var(--text-secondary);
                display: flex;
                align-items: center;
                gap: 0.5rem;
            }
            
            .row-badge {
                background: var(--bg-secondary);
                padding: 0.15rem 0.5rem;
                border-radius: 10px;
                font-weight: 600;
            }
            
            .duplicate-action {
                margin-left: auto;
                color: var(--amazon-orange);
                font-weight: 600;
                cursor: pointer;
            }
            
            .more-duplicates {
                text-align: center;
                color: var(--text-secondary);
                font-size: 0.85rem;
                padding: 1rem;
                border-top: 1px dashed rgba(0,0,0,0.1);
                cursor: pointer;
            }
            
            .word-distribution {
                margin-top: 1rem;
            }
            
            .distribution-row {
                display: flex;
                align-items: center;
                gap: 1rem;
                margin-bottom: 0.75rem;
            }
            
            .dist-label {
                width: 80px;
                font-size: 0.85rem;
                color: var(--text-secondary);
            }
            
            .dist-bar-container {
                flex: 1;
                background: var(--bg-secondary);
                border-radius: 20px;
                height: 24px;
                position: relative;
                overflow: hidden;
            }
            
            .dist-bar {
                height: 100%;
                border-radius: 20px;
                transition: width 1s ease;
                position: relative;
            }
            
            .dist-value {
                position: absolute;
                right: 10px;
                top: 50%;
                transform: translateY(-50%);
                font-size: 0.75rem;
                font-weight: 600;
                color: var(--text-primary);
            }
            
            .bar-critical { background: var(--danger); }
            .bar-warning { background: var(--warning); }
            .bar-good { background: #2196F3; }
            .bar-excellent { background: var(--success); }
            
            .word-heatmap-enhanced {
                display: flex;
                flex-wrap: wrap;
                gap: 0.5rem;
                margin-top: 1rem;
            }
            
            .word-heatmap-enhanced .heatmap-item {
                padding: 0.5rem 1rem;
                border-radius: 20px;
                color: white;
                font-size: 0.85rem;
                font-weight: 600;
                transition: all 0.2s ease;
                cursor: pointer;
            }
            
            .word-heatmap-enhanced .heatmap-item:hover {
                transform: scale(1.05);
                box-shadow: 0 2px 8px rgba(0,0,0,0.2);
            }
            
            .recommendations-section {
                margin-top: 2rem;
            }
            
            .recommendations-list {
                display: grid;
                gap: 0.75rem;
                margin-top: 1rem;
            }
            
            .recommendation-item {
                display: flex;
                align-items: flex-start;
                gap: 1rem;
                padding: 1rem;
                border-radius: 8px;
                background: white;
                border: 1px solid transparent;
                transition: all 0.2s ease;
            }
            
            [data-theme="dark"] .recommendation-item {
                background: #2d2d2d;
            }
            
            .recommendation-item.critical {
                border-color: var(--critical);
                background: rgba(183, 28, 28, 0.05);
            }
            
            .recommendation-item.warning {
                border-color: var(--warning);
                background: rgba(255, 193, 7, 0.05);
            }
            
            .recommendation-item.success {
                border-color: var(--success);
                background: rgba(76, 175, 80, 0.05);
            }
            
            .rec-icon {
                font-size: 1.5rem;
                flex-shrink: 0;
            }
            
            .rec-content {
                flex: 1;
            }
            
            .rec-text {
                color: var(--text-primary);
                font-size: 0.9rem;
                line-height: 1.5;
            }
            
            .rec-priority {
                margin-top: 0.25rem;
                font-size: 0.75rem;
                color: var(--critical);
                font-weight: 600;
                text-transform: uppercase;
            }
        `;
        document.head.appendChild(style);
    }
    
    // Update charts and word analysis after a short delay
    setTimeout(() => {
        if (type === 'injury') {
            const ctx = document.getElementById(`${type}MissingFieldsChart`);
            if (ctx) {
                new Chart(ctx.getContext('2d'), {
                    type: 'bar',
                    data: {
                        labels: Object.keys(metrics.missingFieldsDetails),
                        datasets: [{
                            label: 'Missing Records',
                            data: Object.values(metrics.missingFieldsDetails),
                            backgroundColor: AMAZON_COLORS.orange,
                            borderColor: AMAZON_COLORS.darkBlue,
                            borderWidth: 1
                        }]
                    },
                    options: {
                        ...getChartOptions('bar'),
                        scales: {
                            y: {
                                beginAtZero: true,
                                title: {
                                    display: true,
                                    text: 'Number of Records'
                                }
                            }
                        }
                    }
                });
            }
        }
        
        if (type === 'nearmiss') {
            updateNearMissWordHeatMap(metrics);
        }
    }, 100);
}

// Enhanced word heat map function
function updateNearMissWordHeatMap(metrics) {
    const words = [];
    state.nearMiss.filteredData.forEach(row => {
        ['initial_info_incident_description', 'initial_info_nearmiss_type', 'initial_info_primary_impact'].forEach(field => {
            const text = row[field];
            if (text && typeof text === 'string') {
                text.split(/\s+/).forEach(word => {
                    const cleaned = word.toLowerCase().replace(/[^a-z0-9]/g, '');
                    if (cleaned && cleaned.length > 3) words.push(cleaned);
                });
            }
        });
    });
    
    const wordCounts = {};
    words.forEach(w => {
        wordCounts[w] = (wordCounts[w] || 0) + 1;
    });
    
    // Filter out common words
    const commonWords = ['that', 'this', 'with', 'from', 'have', 'been', 'were', 'their'];
    const topWords = Object.entries(wordCounts)
        .filter(([word]) => !commonWords.includes(word))
        .sort((a, b) => b[1] - a[1])
        .slice(0, 20);
    
    const container = document.getElementById('nearMissWordHeatMap');
    if (container) {
        const maxCount = Math.max(...topWords.map(entry => entry[1]));
        const minCount = Math.min(...topWords.map(entry => entry[1]));
        
        container.innerHTML = topWords.map(([word, count]) => {
            const intensity = (count - minCount) / (maxCount - minCount);
            const size = 0.8 + (intensity * 0.6);
            const colors = [
                '#FFE0B2', '#FFCC80', '#FFB74D', '#FFA726',
                '#FF9800', '#FB8C00', '#F57C00', '#EF6C00'
            ];
            const colorIndex = Math.floor(intensity * (colors.length - 1));
            
            return `<div class="heatmap-item" 
                style="background: ${colors[colorIndex]}; 
                       color: ${intensity > 0.5 ? '#fff' : '#333'};
                       font-size: ${size}rem;"
                title="${count} occurrences">
                ${word} (${count})
            </div>`;
        }).join('');
    }
}

// Standardize severity
function standardizeSeverity(severity) {
    if (!severity) return 'Unknown';
    const severityStr = String(severity).toUpperCase().trim();
    
    if (['A', 'B', 'C', 'D'].includes(severityStr)) {
        return severityStr;
    }
    
    const lower = severityStr.toLowerCase();
    if (lower.includes('critical') || lower.includes('severe')) return 'A';
    if (lower.includes('high') || lower.includes('major')) return 'B';
    if (lower.includes('medium') || lower.includes('moderate')) return 'C';
    if (lower.includes('low') || lower.includes('minor')) return 'D';
    
    return 'Unknown';
}

// Standardize likelihood
function standardizeLikelihood(likelihood) {
    if (!likelihood) return 'Possible';
    
    const likelihoodStr = String(likelihood).toLowerCase().trim();
    
    if (likelihoodStr.includes('rare')) return 'Rare';
    if (likelihoodStr.includes('unlikely')) return 'Unlikely';
    if (likelihoodStr.includes('possible')) return 'Possible';
    if (likelihoodStr.includes('likely') && !likelihoodStr.includes('unlikely')) {
        if (likelihoodStr.includes('almost') || likelihoodStr.includes('certain')) {
            return 'Almost Certain';
        }
        return 'Likely';
    }
    if (likelihoodStr.includes('certain')) return 'Almost Certain';
    
    const numValue = parseInt(likelihoodStr);
    if (!isNaN(numValue)) {
        switch(numValue) {
            case 1: return 'Rare';
            case 2: return 'Unlikely';
            case 3: return 'Possible';
            case 4: return 'Likely';
            case 5: return 'Almost Certain';
        }
    }
    
    return 'Possible';
}

// Calculate risk score
function calculateRiskScore(row) {
    const severityMap = { 'A': 5, 'B': 4, 'C': 3, 'D': 2, 'Unknown': 1 };
    const likelihoodMap = { 
        'Rare': 1, 
        'Unlikely': 2, 
        'Possible': 3, 
        'Likely': 4, 
        'Almost Certain': 5 
    };
    
    const severity = severityMap[row.severity] || 1;
    const likelihood = likelihoodMap[row.standardized_likelihood] || 3;
    
    return ((severity * likelihood) / 5 * 2).toFixed(1);
}

// Populate Filters
function populateInjuryFilters() {
    // Sites
    const sites = [...new Set(state.injury.rawData.map(r => r.site).filter(Boolean))];
    const siteFilter = document.getElementById('injurySiteFilter');
    siteFilter.innerHTML = '<option value="">All Sites</option>';
    sites.sort().forEach(site => {
        siteFilter.innerHTML += `<option value="${site}">${site}</option>`;
    });
    
    // Body Parts
    const bodyParts = [...new Set(state.injury.rawData.map(r => r.bodyPart).filter(Boolean))];
    const bodyPartFilter = document.getElementById('injuryBodyPartFilter');
    bodyPartFilter.innerHTML = '<option value="">All Body Parts</option>';
    bodyParts.sort().slice(0, 20).forEach(part => {
        const truncated = part.length > 30 ? part.substring(0, 30) + '...' : part;
        bodyPartFilter.innerHTML += `<option value="${part}">${truncated}</option>`;
    });
    
    // Root Causes
    const rootCauses = [...new Set(state.injury.rawData.map(r => r.rootCause).filter(Boolean))];
    const rootCauseFilter = document.getElementById('injuryRootCauseFilter');
    rootCauseFilter.innerHTML = '<option value="">All Causes</option>';
    rootCauses.sort().forEach(cause => {
        const truncated = cause.length > 30 ? cause.substring(0, 30) + '...' : cause;
        rootCauseFilter.innerHTML += `<option value="${cause}">${truncated}</option>`;
    });
}

function populateNearMissFilters() {
    // Sites
    const sites = [...new Set(state.nearMiss.rawData.map(r => r.site).filter(Boolean))];
    const siteFilter = document.getElementById('nearMissSiteFilter');
    siteFilter.innerHTML = '<option value="">All Sites</option>';
    sites.sort().forEach(site => {
        siteFilter.innerHTML += `<option value="${site}">${site}</option>`;
    });
    
    // Primary Impacts
    const impacts = [...new Set(state.nearMiss.rawData.map(r => r.primaryImpact).filter(Boolean))];
    const impactFilter = document.getElementById('nearMissPrimaryImpactFilter');
    impactFilter.innerHTML = '<option value="">All Impacts</option>';
    impacts.sort().forEach(impact => {
        impactFilter.innerHTML += `<option value="${impact}">${impact}</option>`;
    });
    
    // Locations
    const locations = [...new Set(state.nearMiss.rawData.map(r => r.location).filter(Boolean))];
    const locationFilter = document.getElementById('nearMissLocationFilter');
    locationFilter.innerHTML = '<option value="">All Locations</option>';
    locations.sort().slice(0, 20).forEach(location => {
        const truncated = location.length > 30 ? location.substring(0, 30) + '...' : location;
        locationFilter.innerHTML += `<option value="${location}">${truncated}</option>`;
    });
    
    // Process Paths
    const processes = [...new Set(state.nearMiss.rawData.map(r => r.processPath).filter(Boolean))];
    const processFilter = document.getElementById('nearMissProcessFilter');
    processFilter.innerHTML = '<option value="">All Processes</option>';
    processes.sort().forEach(process => {
        processFilter.innerHTML += `<option value="${process}">${process}</option>`;
    });
}

// Apply Filters
function applyFilters(type) {
    if (type === 'injury') {
        const siteFilter = document.getElementById('injurySiteFilter').value;
        const severityFilter = document.getElementById('injurySeverityFilter').value;
        const recordableFilter = document.getElementById('injuryRecordableFilter').value;
        const otrFilter = document.getElementById('injuryOTRFilter').value;
        const bodyPartFilter = document.getElementById('injuryBodyPartFilter').value;
        const rootCauseFilter = document.getElementById('injuryRootCauseFilter').value;
        const dateFrom = document.getElementById('injuryDateFrom').value;
        const dateTo = document.getElementById('injuryDateTo').value;
        
        state.injury.filteredData = state.injury.rawData.filter(row => {
            if (siteFilter && row.site !== siteFilter) return false;
            if (severityFilter && row.severity !== severityFilter) return false;
            if (recordableFilter !== '' && row.recordable != recordableFilter) return false;
            if (otrFilter && row.otr !== otrFilter) return false;
            if (bodyPartFilter && row.bodyPart !== bodyPartFilter) return false;
            if (rootCauseFilter && row.rootCause !== rootCauseFilter) return false;
            
            if (dateFrom || dateTo) {
                const rowDate = row.parsedDate;
                if (!rowDate || isNaN(rowDate)) return false;
                if (dateFrom && rowDate < new Date(dateFrom)) return false;
                if (dateTo && rowDate > new Date(dateTo)) return false;
            }
            
            return true;
        });

        sortData('injury');
        updateSortIndicators('injury');

        state.injury.currentPage = 1;
        updateInjuryDashboard();
        updateInjuryTable();
        updateInjuryCharts();
    } else {
        const siteFilter = document.getElementById('nearMissSiteFilter').value;
        const severityFilter = document.getElementById('nearMissSeverityFilter').value;
        const impactFilter = document.getElementById('nearMissPrimaryImpactFilter').value;
        const locationFilter = document.getElementById('nearMissLocationFilter').value;
        const processFilter = document.getElementById('nearMissProcessFilter').value;
        const likelihoodFilter = document.getElementById('nearMissLikelihoodFilter').value;
        const dateFrom = document.getElementById('nearMissDateFrom').value;
        const dateTo = document.getElementById('nearMissDateTo').value;
        
        state.nearMiss.filteredData = state.nearMiss.rawData.filter(row => {
            if (siteFilter && row.site !== siteFilter) return false;
            if (severityFilter && row.severity !== severityFilter) return false;
            if (impactFilter && row.primaryImpact !== impactFilter) return false;
            if (locationFilter && row.location !== locationFilter) return false;
            if (processFilter && row.processPath !== processFilter) return false;
            if (likelihoodFilter && row.standardized_likelihood !== likelihoodFilter) return false;
            
            if (dateFrom || dateTo) {
                const rowDate = row.parsedDate;
                if (!rowDate || isNaN(rowDate)) return false;
                if (dateFrom && rowDate < new Date(dateFrom)) return false;
                if (dateTo && rowDate > new Date(dateTo)) return false;
            }
            
            return true;
        });

        sortData('nearmiss');
        updateSortIndicators('nearmiss');

        state.nearMiss.currentPage = 1;
        updateNearMissDashboard();
        updateNearMissTable();
        updateNearMissCharts();
    }
    
    updateOverview();
    updateKPIs();
    // Ensure the combined analytics reflect the latest filtered data
    updateCombinedAnalytics();
}

// Populate overview filter options based on loaded data
function populateOverviewFilters() {
    const siteSelect = document.getElementById('overviewSiteFilter');
    if (!siteSelect) return;
    // If options already populated beyond default, skip
    if (siteSelect.options.length > 1) return;
    const sites = new Set();
    state.injury.rawData.forEach(row => {
        if (row.site) sites.add(row.site);
    });
    state.nearMiss.rawData.forEach(row => {
        if (row.site) sites.add(row.site);
    });
    sites.forEach(site => {
        const option = document.createElement('option');
        option.value = site;
        option.textContent = site;
        siteSelect.appendChild(option);
    });

    // Populate body part options (from injury data)
    const bodySelect = document.getElementById('overviewBodyPartFilter');
    if (bodySelect && bodySelect.options.length <= 1) {
        const parts = new Set();
        state.injury.rawData.forEach(row => {
            if (row.bodyPart) parts.add(row.bodyPart);
        });
        parts.forEach(part => {
            const opt = document.createElement('option');
            opt.value = part;
            opt.textContent = part;
            bodySelect.appendChild(opt);
        });
    }

    // Populate impact options (from near miss data)
    const impactSelect = document.getElementById('overviewImpactFilter');
    if (impactSelect && impactSelect.options.length <= 1) {
        const impacts = new Set();
        state.nearMiss.rawData.forEach(row => {
            if (row.primaryImpact) impacts.add(row.primaryImpact);
        });
        impacts.forEach(impact => {
            const opt = document.createElement('option');
            opt.value = impact;
            opt.textContent = impact;
            impactSelect.appendChild(opt);
        });
    }

    // Populate location options (from near miss data)
    const locationSelect = document.getElementById('overviewLocationFilter');
    if (locationSelect && locationSelect.options.length <= 1) {
        const locations = new Set();
        state.nearMiss.rawData.forEach(row => {
            if (row.location) locations.add(row.location);
        });
        locations.forEach(loc => {
            const opt = document.createElement('option');
            opt.value = loc;
            opt.textContent = loc;
            locationSelect.appendChild(opt);
        });
    }

    // Populate process path options (from near miss data)
    const processSelect = document.getElementById('overviewProcessFilter');
    if (processSelect && processSelect.options.length <= 1) {
        const processes = new Set();
        state.nearMiss.rawData.forEach(row => {
            if (row.processPath) processes.add(row.processPath);
        });
        processes.forEach(proc => {
            const opt = document.createElement('option');
            opt.value = proc;
            opt.textContent = proc;
            processSelect.appendChild(opt);
        });
    }

    // Populate likelihood options (from near miss data)
    const likelihoodSelect = document.getElementById('overviewLikelihoodFilter');
    if (likelihoodSelect && likelihoodSelect.options.length <= 1) {
        const liks = new Set();
        state.nearMiss.rawData.forEach(row => {
            const val = row.standardized_likelihood || row.initial_risk_assessment_likeliness;
            if (val) liks.add(val);
        });
        liks.forEach(lk => {
            const opt = document.createElement('option');
            opt.value = lk;
            opt.textContent = lk;
            likelihoodSelect.appendChild(opt);
        });
    }
}

// Populate combined filter options based on loaded data.  This mirrors
// populateOverviewFilters but targets the combined-specific select
// elements.  It is invoked when updating the combined analytics and
// ensures the dropdowns only populate once data has been loaded.  To
// avoid redundant work, it checks whether options beyond the default
// already exist before appending new ones.
function populateCombinedFilters() {
    const siteSelect = document.getElementById('combinedSiteFilter');
    if (!siteSelect) return;
    // If options already populated beyond default, skip
    if (siteSelect.options.length > 1) return;
    const sites = new Set();
    state.injury.rawData.forEach(row => {
        if (row.site) sites.add(row.site);
    });
    state.nearMiss.rawData.forEach(row => {
        if (row.site) sites.add(row.site);
    });
    sites.forEach(site => {
        const option = document.createElement('option');
        option.value = site;
        option.textContent = site;
        siteSelect.appendChild(option);
    });

    // Populate body part options (from injury data)
    const bodySelect = document.getElementById('combinedBodyPartFilter');
    if (bodySelect && bodySelect.options.length <= 1) {
        const parts = new Set();
        state.injury.rawData.forEach(row => {
            if (row.bodyPart) parts.add(row.bodyPart);
        });
        parts.forEach(part => {
            const opt = document.createElement('option');
            opt.value = part;
            opt.textContent = part;
            bodySelect.appendChild(opt);
        });
    }

    // Populate impact options (from near miss data)
    const impactSelect = document.getElementById('combinedImpactFilter');
    if (impactSelect && impactSelect.options.length <= 1) {
        const impacts = new Set();
        state.nearMiss.rawData.forEach(row => {
            if (row.primaryImpact) impacts.add(row.primaryImpact);
        });
        impacts.forEach(im => {
            const opt = document.createElement('option');
            opt.value = im;
            opt.textContent = im;
            impactSelect.appendChild(opt);
        });
    }

    // Populate location options (from near miss data)
    const locationSelect = document.getElementById('combinedLocationFilter');
    if (locationSelect && locationSelect.options.length <= 1) {
        const locs = new Set();
        state.nearMiss.rawData.forEach(row => {
            if (row.location) locs.add(row.location);
        });
        locs.forEach(loc => {
            const opt = document.createElement('option');
            opt.value = loc;
            opt.textContent = loc;
            locationSelect.appendChild(opt);
        });
    }

    // Populate process options (from near miss data)
    const processSelect = document.getElementById('combinedProcessFilter');
    if (processSelect && processSelect.options.length <= 1) {
        const procs = new Set();
        state.nearMiss.rawData.forEach(row => {
            if (row.processPath) procs.add(row.processPath);
        });
        procs.forEach(proc => {
            const opt = document.createElement('option');
            opt.value = proc;
            opt.textContent = proc;
            processSelect.appendChild(opt);
        });
    }

    // Populate likelihood options (from near miss data).  If there are no
    // custom values we fall back to the defaults defined in the HTML.
    const likelihoodSelect = document.getElementById('combinedLikelihoodFilter');
    if (likelihoodSelect && likelihoodSelect.options.length <= 1) {
        const liks = new Set();
        state.nearMiss.rawData.forEach(row => {
            const val = row.standardized_likelihood || row.initial_risk_assessment_likeliness;
            if (val) liks.add(val);
        });
        liks.forEach(lk => {
            const opt = document.createElement('option');
            opt.value = lk;
            opt.textContent = lk;
            likelihoodSelect.appendChild(opt);
        });
    }
}

// Apply combined filters to both injury and near miss modules and refresh
// the overview and combined analytics.  This function reads values from
// the combined filter dropdowns, sets the corresponding values on
// underlying module-specific selects, and then triggers the same logic
// used by applyFilters() and applyOverviewFilters().
function applyCombinedFilters() {
    const site = document.getElementById('combinedSiteFilter').value;
    const severity = document.getElementById('combinedSeverityFilter').value;
    const dateFrom = document.getElementById('combinedDateFrom').value;
    const dateTo = document.getElementById('combinedDateTo').value;
    const bodyPart = document.getElementById('combinedBodyPartFilter') ? document.getElementById('combinedBodyPartFilter').value : '';
    const impact = document.getElementById('combinedImpactFilter') ? document.getElementById('combinedImpactFilter').value : '';
    const locationVal = document.getElementById('combinedLocationFilter') ? document.getElementById('combinedLocationFilter').value : '';
    const processVal = document.getElementById('combinedProcessFilter') ? document.getElementById('combinedProcessFilter').value : '';
    const likelihood = document.getElementById('combinedLikelihoodFilter') ? document.getElementById('combinedLikelihoodFilter').value : '';

    // Propagate selections to module-specific filters
    const injurySiteSel = document.getElementById('injurySiteFilter');
    const nearMissSiteSel = document.getElementById('nearMissSiteFilter');
    if (injurySiteSel) injurySiteSel.value = site;
    if (nearMissSiteSel) nearMissSiteSel.value = site;
    const injurySeveritySel = document.getElementById('injurySeverityFilter');
    const nearMissSeveritySel = document.getElementById('nearMissSeverityFilter');
    if (injurySeveritySel) injurySeveritySel.value = severity;
    if (nearMissSeveritySel) nearMissSeveritySel.value = severity;
    const injuryFrom = document.getElementById('injuryDateFrom');
    const injuryTo = document.getElementById('injuryDateTo');
    const nearMissFrom = document.getElementById('nearMissDateFrom');
    const nearMissTo = document.getElementById('nearMissDateTo');
    if (injuryFrom) injuryFrom.value = dateFrom;
    if (injuryTo) injuryTo.value = dateTo;
    if (nearMissFrom) nearMissFrom.value = dateFrom;
    if (nearMissTo) nearMissTo.value = dateTo;
    // Body part only applies to injury
    const injuryBodySel = document.getElementById('injuryBodyPartFilter');
    if (injuryBodySel) injuryBodySel.value = bodyPart;
    // Impact, location, process, likelihood apply to near miss
    const nearMissImpactSel = document.getElementById('nearMissPrimaryImpactFilter');
    if (nearMissImpactSel) nearMissImpactSel.value = impact;
    const nearMissLocationSel = document.getElementById('nearMissLocationFilter');
    if (nearMissLocationSel) nearMissLocationSel.value = locationVal;
    const nearMissProcessSel = document.getElementById('nearMissProcessFilter');
    if (nearMissProcessSel) nearMissProcessSel.value = processVal;
    const nearMissLikelihoodSel = document.getElementById('nearMissLikelihoodFilter');
    if (nearMissLikelihoodSel) nearMissLikelihoodSel.value = likelihood;

    // Also update the overview unified filters so the UI remains in sync
    const overviewSiteSel = document.getElementById('overviewSiteFilter');
    if (overviewSiteSel) overviewSiteSel.value = site;
    const overviewSeveritySel = document.getElementById('overviewSeverityFilter');
    if (overviewSeveritySel) overviewSeveritySel.value = severity;
    const overviewBodySel = document.getElementById('overviewBodyPartFilter');
    if (overviewBodySel) overviewBodySel.value = bodyPart;
    const overviewImpactSel = document.getElementById('overviewImpactFilter');
    if (overviewImpactSel) overviewImpactSel.value = impact;
    const overviewLocationSel = document.getElementById('overviewLocationFilter');
    if (overviewLocationSel) overviewLocationSel.value = locationVal;
    const overviewProcessSel = document.getElementById('overviewProcessFilter');
    if (overviewProcessSel) overviewProcessSel.value = processVal;
    const overviewLikelihoodSel = document.getElementById('overviewLikelihoodFilter');
    if (overviewLikelihoodSel) overviewLikelihoodSel.value = likelihood;
    const overviewFrom = document.getElementById('overviewDateFrom');
    const overviewTo = document.getElementById('overviewDateTo');
    if (overviewFrom) overviewFrom.value = dateFrom;
    if (overviewTo) overviewTo.value = dateTo;

    // Reapply filters on the underlying data and refresh the dashboards
    applyFilters('injury');
    applyFilters('nearmiss');
    // Explicitly update combined analytics in case the combined tab is active
    updateCombinedAnalytics();
    // Also refresh the overview KPI and charts so they reflect the selection
    updateOverview();
}

// Apply overview filters to both injury and near miss modules
function applyOverviewFilters() {
    const site = document.getElementById('overviewSiteFilter').value;
    const severity = document.getElementById('overviewSeverityFilter').value;
    const dateFrom = document.getElementById('overviewDateFrom').value;
    const dateTo = document.getElementById('overviewDateTo').value;

    // Additional filters
    const bodyPart = document.getElementById('overviewBodyPartFilter') ? document.getElementById('overviewBodyPartFilter').value : '';
    const impact = document.getElementById('overviewImpactFilter') ? document.getElementById('overviewImpactFilter').value : '';
    const locationVal = document.getElementById('overviewLocationFilter') ? document.getElementById('overviewLocationFilter').value : '';
    const processVal = document.getElementById('overviewProcessFilter') ? document.getElementById('overviewProcessFilter').value : '';
    const likelihood = document.getElementById('overviewLikelihoodFilter') ? document.getElementById('overviewLikelihoodFilter').value : '';
    // Update underlying module filters
    const injurySiteSel = document.getElementById('injurySiteFilter');
    const nearMissSiteSel = document.getElementById('nearMissSiteFilter');
    if (injurySiteSel) injurySiteSel.value = site;
    if (nearMissSiteSel) nearMissSiteSel.value = site;
    const injurySeveritySel = document.getElementById('injurySeverityFilter');
    const nearMissSeveritySel = document.getElementById('nearMissSeverityFilter');
    if (injurySeveritySel) injurySeveritySel.value = severity;
    if (nearMissSeveritySel) nearMissSeveritySel.value = severity;
    const injuryFrom = document.getElementById('injuryDateFrom');
    const injuryTo = document.getElementById('injuryDateTo');
    const nearMissFrom = document.getElementById('nearMissDateFrom');
    const nearMissTo = document.getElementById('nearMissDateTo');
    if (injuryFrom) injuryFrom.value = dateFrom;
    if (injuryTo) injuryTo.value = dateTo;
    if (nearMissFrom) nearMissFrom.value = dateFrom;
    if (nearMissTo) nearMissTo.value = dateTo;

    // Propagate body part filter to injury module
    const injuryBodySel = document.getElementById('injuryBodyPartFilter');
    if (injuryBodySel) injuryBodySel.value = bodyPart;
    // Propagate impact, location, process, likelihood to near miss module
    const nearMissImpactSel = document.getElementById('nearMissPrimaryImpactFilter');
    if (nearMissImpactSel) nearMissImpactSel.value = impact;
    const nearMissLocationSel = document.getElementById('nearMissLocationFilter');
    if (nearMissLocationSel) nearMissLocationSel.value = locationVal;
    const nearMissProcessSel = document.getElementById('nearMissProcessFilter');
    if (nearMissProcessSel) nearMissProcessSel.value = processVal;
    const nearMissLikelihoodSel = document.getElementById('nearMissLikelihoodFilter');
    if (nearMissLikelihoodSel) nearMissLikelihoodSel.value = likelihood;
    // Reapply filters for each module
    applyFilters('injury');
    applyFilters('nearmiss');
    // Refresh overview dashboard after filters propagate
    updateOverview();
    // Explicitly refresh combined analytics based on updated filters
    updateCombinedAnalytics();
}

// Update KPIs
function updateKPIs() {
    if (state.injury.rawData.length === 0 && state.nearMiss.rawData.length === 0) return;
    
    const hoursWorked = 200000;
    
    // TRIR
    const recordableCount = state.injury.filteredData.filter(r => r.recordable === 1).length;
    const trir = ((recordableCount / hoursWorked) * 200000).toFixed(2);
    document.getElementById('kpiTRIR').textContent = trir;
    
    // LTIR
    const lostTimeCount = state.injury.filteredData.filter(r => r.total_dafw_days > 0).length;
    const ltir = ((lostTimeCount / hoursWorked) * 200000).toFixed(2);
    document.getElementById('kpiLTIR').textContent = ltir;
    
    // DAFWR
    const totalDaysLost = state.injury.filteredData.reduce((sum, r) => sum + (r.total_dafw_days || 0), 0);
    const dafwr = ((totalDaysLost / hoursWorked) * 200000).toFixed(2);
    document.getElementById('kpiDAFWR').textContent = dafwr;
    
    // NMFR
    const nearMissCount = state.nearMiss.filteredData.length;
    const nmfr = ((nearMissCount / hoursWorked) * 200000).toFixed(2);
    document.getElementById('kpiNMFR').textContent = nmfr;
}

// Update Dashboards
function updateInjuryDashboard() {
    const data = state.injury.filteredData;
    
    document.getElementById('injuryTotal').textContent = data.length;
    document.getElementById('injuryRecordable').textContent = 
        data.filter(r => r.recordable === 1).length;
    document.getElementById('injuryLostTime').textContent = 
        data.filter(r => r.total_dafw_days > 0).length;
    document.getElementById('injuryDaysLost').textContent = 
        data.reduce((sum, r) => sum + (r.total_dafw_days || 0), 0);
    document.getElementById('injuryOTR').textContent = 
        data.filter(r => r.otr === 'yes').length;
    
    const recordableCount = data.filter(r => r.recordable === 1).length;
    const recordableRate = data.length > 0 ? 
        ((recordableCount / data.length) * 100).toFixed(1) : '0.0';
    document.getElementById('injuryRecordableRate').textContent = recordableRate + '%';
}

function updateNearMissDashboard() {
    const data = state.nearMiss.filteredData;
    
    document.getElementById('nearMissTotal').textContent = data.length;
    
    const risks = data.map(r => parseFloat(r.risk)).filter(r => !isNaN(r));
    const avgRisk = risks.length > 0 ? 
        (risks.reduce((a, b) => a + b, 0) / risks.length).toFixed(1) : '0.0';
    document.getElementById('nearMissRisk').textContent = avgRisk;
    
    document.getElementById('nearMissHigh').textContent = 
        data.filter(r => r.severity === 'A' || r.severity === 'B').length;
    
    // Calculate closure rate (more meaningful metric)
    const closedCount = data.filter(r => r.status === 'Closed' || r.status === 'Completed').length;
    const closureRate = data.length > 0 ? ((closedCount / data.length) * 100).toFixed(0) : '0';
    document.getElementById('nearMissRepeat').textContent = closureRate + '%';
    
    const actionableCount = data.filter(r => parseFloat(r.risk) >= 7).length;
    document.getElementById('nearMissActionable').textContent = actionableCount;
    
    const frequencyRate = data.length > 0 ? 
        (data.length / 30).toFixed(1) : '0.0';
    document.getElementById('nearMissFrequency').textContent = frequencyRate;
}

// Update Tables with Pagination
function updateInjuryTable() {
    const tbody = document.getElementById('injuryTableBody');
    const data = state.injury.filteredData;
    const currentPage = state.injury.currentPage;
    const startIndex = (currentPage - 1) * state.itemsPerPage;
    const endIndex = Math.min(startIndex + state.itemsPerPage, data.length);
    const pageData = data.slice(startIndex, endIndex);
    
    if (pageData.length === 0) {
        tbody.innerHTML = '<tr><td colspan="11" style="text-align: center; padding: 3rem;">No data matches the current filters.</td></tr>';
        updatePaginationInfo('injury', 0, 0);
        return;
    }
    
    tbody.innerHTML = pageData.map(row => {
        const austinUrl = row.austin_url && row.austin_url !== '#' ? row.austin_url : '#';
        const austinLinkHtml = austinUrl !== '#' ?
            `<a href="${austinUrl}" target="_blank" class="austin-link" title="Austin Link">
                <span>üìö</span>
            </a>` :
            `<span class="austin-link disabled" title="No Austin Link available">üìö</span>`;
        
        return `
            <tr>
                <td>${row.case_number || 'N/A'}</td>
                <td>${row.incident_date || 'N/A'}</td>
                <td>${row.site || 'N/A'}</td>
                <td title="${row.bodyPart || ''}">${(row.bodyPart || 'N/A').substring(0, 20)}${row.bodyPart?.length > 20 ? '...' : ''}</td>
                <td>${row.type || 'N/A'}</td>
                <td><span class="badge badge-${getSeverityClass(row.severity)}">${row.severity}</span></td>
                <td><span class="badge badge-${row.recordable === 1 ? 'danger' : 'success'}">${row.recordable === 1 ? 'Yes' : 'No'}</span></td>
                <td><span class="badge badge-${row.otr === 'yes' ? 'warning' : 'info'}">${row.otr === 'yes' ? 'Yes' : 'No'}</span></td>
                <td>${row.total_dafw_days || 0}</td>
                <td title="${row.rootCause || ''}">${(row.rootCause || 'N/A').substring(0, 20)}${row.rootCause?.length > 20 ? '...' : ''}</td>
                <td>
                    <button class="btn btn-sm btn-outline" onclick="viewDetails('injury', '${row.case_number}')">View</button>
                    ${austinLinkHtml}
                </td>
            </tr>
        `;
    }).join('');
    
    updatePaginationInfo('injury', currentPage, Math.ceil(data.length / state.itemsPerPage));
}

function updateNearMissTable() {
    const tbody = document.getElementById('nearMissTableBody');
    const data = state.nearMiss.filteredData;
    const currentPage = state.nearMiss.currentPage;
    const startIndex = (currentPage - 1) * state.itemsPerPage;
    const endIndex = Math.min(startIndex + state.itemsPerPage, data.length);
    const pageData = data.slice(startIndex, endIndex);
    
    if (pageData.length === 0) {
        tbody.innerHTML = '<tr><td colspan="10" style="text-align: center; padding: 3rem;">No data matches the current filters.</td></tr>';
        updatePaginationInfo('nearmiss', 0, 0);
        return;
    }
    
    tbody.innerHTML = pageData.map(row => {
        const austinUrl = row.austin_url && row.austin_url !== '#' ? row.austin_url : '#';
        const austinLinkHtml = austinUrl !== '#' ?
            `<a href="${austinUrl}" target="_blank" class="austin-link" title="Austin Link">
                <span>üìö</span>
            </a>` :
            `<span class="austin-link disabled" title="No Austin Link available">üìö</span>`;

        return `
        <tr>
            <td>${row.incident_id || 'N/A'}</td>
            <td>${row.nearmiss_date || 'N/A'}</td>
            <td>${row.site || 'N/A'}</td>
            <td title="${row.location || ''}">${(row.location || 'N/A').substring(0, 25)}${row.location?.length > 25 ? '...' : ''}</td>
            <td title="${row.processPath || ''}">${(row.processPath || 'N/A').substring(0, 20)}${row.processPath?.length > 20 ? '...' : ''}</td>
            <td title="${row.primaryImpact || ''}">${(row.primaryImpact || 'N/A').substring(0, 20)}${row.primaryImpact?.length > 20 ? '...' : ''}</td>
            <td><span class="badge badge-${getSeverityClass(row.severity)}">${row.severity}</span></td>
            <td><span class="badge badge-info">${row.standardized_likelihood || 'N/A'}</span></td>
            <td><span class="badge badge-${getRiskClass(row.risk)}">${row.risk || 'N/A'}</span></td>
            <td>
                <button class="btn btn-sm btn-outline" onclick="viewDetails('nearmiss', '${row.incident_id}')">View</button>
                ${austinLinkHtml}
            </td>
        </tr>
        `;
    }).join('');
    
    updatePaginationInfo('nearmiss', currentPage, Math.ceil(data.length / state.itemsPerPage));
}

// Pagination
function changePage(type, direction) {
    const data = type === 'injury' ? state.injury.filteredData : state.nearMiss.filteredData;
    const totalPages = Math.ceil(data.length / state.itemsPerPage);
    
    if (type === 'injury') {
        state.injury.currentPage += direction;
        if (state.injury.currentPage < 1) state.injury.currentPage = 1;
        if (state.injury.currentPage > totalPages) state.injury.currentPage = totalPages;
        updateInjuryTable();
    } else {
        state.nearMiss.currentPage += direction;
        if (state.nearMiss.currentPage < 1) state.nearMiss.currentPage = 1;
        if (state.nearMiss.currentPage > totalPages) state.nearMiss.currentPage = totalPages;
        updateNearMissTable();
    }
}

function updatePaginationInfo(type, currentPage, totalPages) {
    const pageInfo = document.getElementById(`${type}PageInfo`);
    const prevBtn = document.getElementById(`${type}PrevBtn`);
    const nextBtn = document.getElementById(`${type}NextBtn`);
    
    if (pageInfo) pageInfo.textContent = `Page ${currentPage} of ${totalPages || 1}`;
    if (prevBtn) prevBtn.disabled = currentPage <= 1;
    if (nextBtn) nextBtn.disabled = currentPage >= totalPages;
}

// Get severity class for badges
function getSeverityClass(severity) {
    switch(severity) {
        case 'A': return 'critical';
        case 'B': return 'danger';
        case 'C': return 'warning';
        case 'D': return 'success';
        default: return 'secondary';
    }
}

function getRiskClass(risk) {
    const riskValue = parseFloat(risk);
    if (riskValue >= 8) return 'critical';
    if (riskValue >= 6) return 'danger';
    if (riskValue >= 4) return 'warning';
    if (riskValue >= 2) return 'success';
    return 'info';
}

// Table Sorting Utilities
function sortData(type) {
    const sort = state[type].sort;
    const data = state[type].filteredData;
    const column = sort.column;
    const direction = sort.direction === 'asc' ? 1 : -1;
    data.sort((a, b) => {
        let valA = a[column];
        let valB = b[column];
        if (column === 'incident_date' || column === 'nearmiss_date') {
            valA = a.parsedDate;
            valB = b.parsedDate;
            if (valA === undefined || valA === null || isNaN(valA)) return -1 * direction;
            if (valB === undefined || valB === null || isNaN(valB)) return 1 * direction;
            return (valA - valB) * direction;
        }
        if (valA === undefined || valA === null) return -1 * direction;
        if (valB === undefined || valB === null) return 1 * direction;
        const numA = parseFloat(valA);
        const numB = parseFloat(valB);
        if (!isNaN(numA) && !isNaN(numB)) {
            return (numA - numB) * direction;
        }
        return valA.toString().localeCompare(valB.toString()) * direction;
    });
}

function toggleSort(type, column) {
    const sort = state[type].sort;
    if (sort.column === column) {
        sort.direction = sort.direction === 'asc' ? 'desc' : 'asc';
    } else {
        sort.column = column;
        sort.direction = column === 'incident_date' || column === 'nearmiss_date' ? 'desc' : 'asc';
    }
}

function updateSortIndicators(type) {
    const tableId = type === 'injury' ? 'injuryTable' : 'nearMissTable';
    const columns = type === 'injury' ?
        ['case_number','incident_date','site','bodyPart','type','severity','recordable','otr','total_dafw_days','rootCause'] :
        ['incident_id','nearmiss_date','site','location','processPath','primaryImpact','severity','standardized_likelihood','risk'];
    const headers = document.querySelectorAll(`#${tableId} thead th`);
    headers.forEach((th, index) => {
        if (index >= columns.length) return;
        const column = columns[index];
        const base = th.dataset.originalText || th.textContent;
        th.dataset.originalText = base;
        let text = base;
        const sort = state[type].sort;
        if (sort.column === column) {
            text += sort.direction === 'asc' ? ' ‚ñ≤' : ' ‚ñº';
        }
        th.textContent = text;
    });
}

function setupTableSorting(type) {
    const tableId = type === 'injury' ? 'injuryTable' : 'nearMissTable';
    const columns = type === 'injury' ?
        ['case_number','incident_date','site','bodyPart','type','severity','recordable','otr','total_dafw_days','rootCause'] :
        ['incident_id','nearmiss_date','site','location','processPath','primaryImpact','severity','standardized_likelihood','risk'];
    const headers = document.querySelectorAll(`#${tableId} thead th`);
    headers.forEach((th, index) => {
        if (index >= columns.length) return;
        const column = columns[index];
        th.style.cursor = 'pointer';
        th.addEventListener('click', () => {
            toggleSort(type, column);
            sortData(type);
            if (type === 'injury') {
                updateInjuryTable();
            } else {
                updateNearMissTable();
            }
            updateSortIndicators(type);
        });
    });
    updateSortIndicators(type);
}

// Initialize Charts
function initializeCharts() {
    // Injury Charts
    for (let i = 1; i <= 4; i++) {
        const ctx = document.getElementById(`injuryChart${i}`)?.getContext('2d');
        if (ctx) {
            state.injury.charts[`chart${i}`] = new Chart(ctx, {
                type: 'doughnut',
                data: { labels: [], datasets: [] },
                options: getChartOptions('doughnut')
            });
        }
    }
    
    // Near Miss Charts
    for (let i = 1; i <= 4; i++) {
        const ctx = document.getElementById(`nearMissChart${i}`)?.getContext('2d');
        if (ctx) {
            state.nearMiss.charts[`chart${i}`] = new Chart(ctx, {
                type: 'doughnut',
                data: { labels: [], datasets: [] },
                options: getChartOptions('doughnut')
            });
        }
    }
    
    initializeAdvancedCharts();
    initializeOverviewCharts();
    initializeCombinedCharts();
}

function initializeAdvancedCharts() {
    const injuryAdvancedCharts = [
        'injuryRecordableRateTrendChart',
        'injuryBodyPartHeatMapChart',
        'injuryRootCauseBySiteChart',
        'injuryDAFWDistributionChart'
    ];
    
    injuryAdvancedCharts.forEach(chartId => {
        const ctx = document.getElementById(chartId)?.getContext('2d');
        if (ctx) {
            state.injury.charts[chartId] = new Chart(ctx, {
                type: 'line',
                data: { labels: [], datasets: [] },
                options: getChartOptions('line')
            });
        }
    });
    
    const nearMissAdvancedCharts = [
        'nearMissRiskTrendChart',
        'nearMissImpactAnalysisChart',
        'nearMissLocationRiskChart',
        'nearMissProcessRiskChart'
    ];
    
    nearMissAdvancedCharts.forEach(chartId => {
        const ctx = document.getElementById(chartId)?.getContext('2d');
        if (ctx) {
            state.nearMiss.charts[chartId] = new Chart(ctx, {
                type: 'line',
                data: { labels: [], datasets: [] },
                options: getChartOptions('line')
            });
        }
    });
}

function initializeOverviewCharts() {
    const overviewTrendCtx = document.getElementById('overviewTrendChart')?.getContext('2d');
    if (overviewTrendCtx) {
        new Chart(overviewTrendCtx, {
            type: 'line',
            data: { labels: [], datasets: [] },
            options: getChartOptions('line')
        });
    }
    
    const overviewSiteCtx = document.getElementById('overviewSiteChart')?.getContext('2d');
    if (overviewSiteCtx) {
        new Chart(overviewSiteCtx, {
            type: 'bar',
            data: { labels: [], datasets: [] },
            options: getChartOptions('bar')
        });
    }
}

function initializeCombinedCharts() {
    const combinedChartIds = [
        'combinedTrendChart',
        'combinedSiteChart',
        'combinedSeverityChart',
        'combinedPreventionChart'
    ];
    
    combinedChartIds.forEach(chartId => {
        const ctx = document.getElementById(chartId)?.getContext('2d');
        if (ctx) {
            new Chart(ctx, {
                type: 'line',
                data: { labels: [], datasets: [] },
                options: getChartOptions('line')
            });
        }
    });
}

// Get chart options based on type
function getChartOptions(type) {
    const isDark = state.theme === 'dark';
    const textColor = isDark ? '#ffffff' : '#212121';
    const gridColor = isDark ? 'rgba(255, 255, 255, 0.1)' : 'rgba(0, 0, 0, 0.1)';
    
    const baseOptions = {
        responsive: true,
        maintainAspectRatio: false,
        plugins: {
            legend: {
                display: type === 'doughnut' || type === 'pie',
                position: 'bottom',
                labels: {
                    color: textColor,
                    padding: 15,
                    font: {
                        size: 11,
                        family: 'Amazon Ember, Arial, sans-serif'
                    }
                }
            },
            tooltip: {
                backgroundColor: isDark ? 'rgba(0, 0, 0, 0.9)' : 'rgba(255, 255, 255, 0.95)',
                titleColor: isDark ? '#ffffff' : '#212121',
                bodyColor: isDark ? '#ffffff' : '#212121',
                borderColor: AMAZON_COLORS.orange,
                borderWidth: 1,
                padding: 10,
                cornerRadius: 4,
                titleFont: {
                    size: 12,
                    weight: 'bold'
                },
                bodyFont: {
                    size: 11
                }
            }
        }
    };
    
    if (type === 'line' || type === 'bar') {
        baseOptions.scales = {
            x: {
                ticks: {
                    color: textColor,
                    font: {
                        size: 10
                    }
                },
                grid: {
                    color: gridColor,
                    lineWidth: 0.5
                }
            },
            y: {
                ticks: {
                    color: textColor,
                    font: {
                        size: 10
                    }
                },
                grid: {
                    color: gridColor,
                    lineWidth: 0.5
                },
                beginAtZero: true
            }
        };
    }
    
    return baseOptions;
}

// Update Charts
function updateInjuryCharts() {
    for (let i = 1; i <= 4; i++) {
        const selector = document.querySelector(`#injuryChart${i}`).parentElement.parentElement.querySelector('select');
        if (selector) {
            updateInjuryChart(i, selector.value);
        }
    }
}

function updateNearMissCharts() {
    for (let i = 1; i <= 4; i++) {
        const selector = document.querySelector(`#nearMissChart${i}`).parentElement.parentElement.querySelector('select');
        if (selector) {
            updateNearMissChart(i, selector.value);
        }
    }
}

function updateInjuryChart(chartNum, type) {
    const chart = state.injury.charts[`chart${chartNum}`];
    if (!chart || state.injury.filteredData.length === 0) return;
    
    const data = state.injury.filteredData;
    
    // Call the universal chart update function
    updateUniversalChart(chart, data, type, 'injury');
}

function updateNearMissChart(chartNum, type) {
    const chart = state.nearMiss.charts[`chart${chartNum}`];
    if (!chart || state.nearMiss.filteredData.length === 0) return;
    
    const data = state.nearMiss.filteredData;
    
    // Call the universal chart update function
    updateUniversalChart(chart, data, type, 'nearmiss');
}

// Universal chart update function
function updateUniversalChart(chart, data, type, module) {
    switch(type) {
        // Distribution & Overview
        case 'severity':
            updateSeverityChart(chart, data);
            break;
        case 'site':
            updateSiteChart(chart, data);
            break;
        case 'trend':
            updateTrendChart(chart, data, module);
            break;
        case 'recordableDistribution':
            updateRecordableDistributionChart(chart, data);
            break;
        case 'statusDistribution':
            updateStatusDistributionChart(chart, data);
            break;

        // Injury specific - Body Part
        case 'bodyPart':
            updateBodyPartChart(chart, data);
            break;
        case 'bodyPartTrend':
            updateBodyPartTrendChart(chart, data);
            break;
        case 'bodyPartHeatmap':
            updateBodyPartHeatmapChart(chart, data);
            break;
        case 'bodyPartBySite':
            updateBodyPartBySiteChart(chart, data);
            break;

        // Injury specific - Type & Mechanism
        case 'injuryType':
            updateInjuryTypeChart(chart, data);
            break;
        case 'mechanismOfInjury':
            updateMechanismOfInjuryChart(chart, data);
            break;
        case 'injuryTypeByProcess':
            updateInjuryTypeByProcessChart(chart, data);
            break;

        // Process & Operations
        case 'processPath':
            updateProcessPathChart(chart, data);
            break;
        case 'shiftAnalysis':
            updateShiftAnalysisChart(chart, data);
            break;
        case 'departmentAnalysis':
            updateDepartmentAnalysisChart(chart, data);
            break;
        case 'processRisk':
            updateProcessRiskChart(chart, data);
            break;
        case 'processHeatmap':
            updateProcessHeatmapChart(chart, data);
            break;

        // Root Cause & Contributing Factors
        case 'rootCause':
            updateRootCauseChart(chart, data);
            break;
        case 'contributingFactors':
            updateContributingFactorsChart(chart, data);
            break;
        case 'rootCauseBySite':
            updateRootCauseBySiteChart(chart, data);
            break;
        case 'rootCauseTrend':
            updateRootCauseTrendChart(chart, data);
            break;

        // Performance Metrics
        case 'recordableRate':
            updateRecordableRateChart(chart, data);
            break;
        case 'recordableTrend':
            updateRecordableTrendChart(chart, data);
            break;
        case 'dafwAnalysis':
        case 'dafwDistribution':
            updateDafwAnalysisChart(chart, data);
            break;
        case 'otrAnalysis':
            updateOtrAnalysisChart(chart, data);
            break;
        case 'lostTimeAnalysis':
            updateLostTimeAnalysisChart(chart, data);
            break;

        // Near Miss specific - Location
        case 'location':
            updateLocationChart(chart, data);
            break;
        case 'locationHeatmap':
            updateLocationHeatmapChart(chart, data);
            break;
        case 'locationTrend':
            updateLocationTrendChart(chart, data);
            break;
        case 'locationBySeverity':
            updateLocationBySeverityChart(chart, data);
            break;

        // Near Miss specific - Impact
        case 'impact':
        case 'impactType':
            updateImpactChart(chart, data);
            break;
        case 'impactSeverity':
            updateImpactSeverityChart(chart, data);
            break;
        case 'impactByLocation':
            updateImpactByLocationChart(chart, data);
            break;
        case 'impactTrend':
            updateImpactTrendChart(chart, data);
            break;

        // Risk Analysis
        case 'riskScore':
            updateRiskScoreChart(chart, data);
            break;
        case 'riskTrend':
            updateRiskTrendChart(chart, data);
            break;
        case 'riskMatrix':
            updateRiskMatrixChart(chart, data);
            break;
        case 'likelihood':
            updateLikelihoodChart(chart, data);
            break;
        case 'likelihoodTrend':
            updateLikelihoodTrendChart(chart, data);
            break;

        // Trends
        case 'severityTrend':
            updateSeverityTrendChart(chart, data);
            break;
        case 'weeklyTrend':
            updateWeeklyTrendChart(chart, data);
            break;

        // Prevention & Advanced
        case 'preventionEffectiveness':
        case 'preventionOpportunities':
            updatePreventionOpportunitiesChart(chart, data);
            break;
        case 'closureAnalysis':
            updateClosureAnalysisChart(chart, data);
            break;
        case 'mitigationStatus':
            updateMitigationStatusChart(chart, data);
            break;
        case 'hazardCategories':
            updateHazardCategoriesChart(chart, data);
            break;

        // Advanced Analytics
        case 'severityPrediction':
            updateSeverityPredictionChart(chart, data);
            break;
        case 'recoveryTimeAnalysis':
            updateRecoveryTimeAnalysisChart(chart, data);
            break;
        case 'costImpactAnalysis':
            updateCostImpactAnalysisChart(chart, data);
            break;
        case 'nearMissToInjuryRatio':
            updateNearMissToInjuryRatioChart(chart, data);
            break;
        case 'predictiveRisk':
            updatePredictiveRiskChart(chart, data);
            break;
        case 'hotspotAnalysis':
            updateHotspotAnalysisChart(chart, data);
            break;

        default:
            console.warn(`Unknown chart type: ${type}`);
            updateSeverityChart(chart, data); // Fallback
    }
}

// Chart Update Functions
function updateSeverityChart(chart, data) {
    const severityCounts = {
        'A': data.filter(r => r.severity === 'A').length,
        'B': data.filter(r => r.severity === 'B').length,
        'C': data.filter(r => r.severity === 'C').length,
        'D': data.filter(r => r.severity === 'D').length
    };
    
    const nonZero = Object.entries(severityCounts).filter(([_, count]) => count > 0);
    
    chart.config.type = 'doughnut';
    chart.data = {
        labels: nonZero.map(([severity]) => `Severity ${severity}`),
        datasets: [{
            data: nonZero.map(([, count]) => count),
            backgroundColor: nonZero.map(([severity]) => SEVERITY_COLORS[severity])
        }]
    };
    chart.options = getChartOptions('doughnut');
    chart.update();
}

function updateRootCauseChart(chart, data) {
    const causeCounts = {};
    data.forEach(row => {
        const cause = row.rootCause || 'Unknown';
        causeCounts[cause] = (causeCounts[cause] || 0) + 1;
    });
    
    const topCauses = Object.entries(causeCounts)
        .sort((a, b) => b[1] - a[1])
        .slice(0, 8);
    
    chart.config.type = 'bar';
    chart.data = {
        labels: topCauses.map(([cause]) => cause.substring(0, 25) + (cause.length > 25 ? '...' : '')),
        datasets: [{
            data: topCauses.map(([, count]) => count),
            backgroundColor: AMAZON_COLORS.orange,
            borderColor: AMAZON_COLORS.darkBlue,
            borderWidth: 1,
            label: 'Cases'
        }]
    };
    chart.options = getChartOptions('bar');
    chart.options.indexAxis = 'y';
    chart.update();
}

function updateProcessPathChart(chart, data) {
    const pathCounts = {};
    data.forEach(row => {
        const path = row.processPath || 'Unknown';
        pathCounts[path] = (pathCounts[path] || 0) + 1;
    });
    
    const topPaths = Object.entries(pathCounts)
        .sort((a, b) => b[1] - a[1])
        .slice(0, 8);
    
    chart.config.type = 'bar';
    chart.data = {
        labels: topPaths.map(([path]) => path),
        datasets: [{
            data: topPaths.map(([, count]) => count),
            backgroundColor: AMAZON_COLORS.darkBlue,
            borderColor: AMAZON_COLORS.orange,
            borderWidth: 1,
            label: 'Cases'
        }]
    };
    chart.options = getChartOptions('bar');
    chart.update();
}

function updateContributingFactorsChart(chart, data) {
    const factorCounts = {};
    data.forEach(row => {
        const factor = row.contributingFactor || 'Unknown';
        factorCounts[factor] = (factorCounts[factor] || 0) + 1;
    });
    
    const topFactors = Object.entries(factorCounts)
        .sort((a, b) => b[1] - a[1])
        .slice(0, 6);
    
    chart.config.type = 'doughnut';
    chart.data = {
        labels: topFactors.map(([factor]) => factor),
        datasets: [{
            data: topFactors.map(([, count]) => count),
            backgroundColor: [
                AMAZON_COLORS.orange,
                AMAZON_COLORS.darkBlue,
                AMAZON_COLORS.lightBlue,
                '#FF5722',
                '#4CAF50',
                '#2196F3'
            ],
            label: 'Cases'
        }]
    };
    chart.options = getChartOptions('doughnut');
    chart.update();
}

function updateTrendChart(chart, data, type) {
    const monthlyData = {};
    data.forEach(row => {
        if (row.parsedDate && !isNaN(row.parsedDate)) {
            const monthKey = `${row.parsedDate.getFullYear()}-${String(row.parsedDate.getMonth() + 1).padStart(2, '0')}`;
            monthlyData[monthKey] = (monthlyData[monthKey] || 0) + 1;
        }
    });
    
    const sortedMonths = Object.keys(monthlyData).sort();
    const monthNames = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
    
    chart.config.type = 'line';
    chart.data = {
        labels: sortedMonths.map(m => {
            const [year, month] = m.split('-');
            return `${monthNames[parseInt(month)-1]} ${year}`;
        }),
        datasets: [{
            label: type === 'injury' ? 'Injuries' : 'Near Misses',
            data: sortedMonths.map(m => monthlyData[m]),
            borderColor: AMAZON_COLORS.orange,
            backgroundColor: `${AMAZON_COLORS.orange}20`,
            tension: 0.3,
            borderWidth: 2
        }]
    };
    chart.options = getChartOptions('line');
    chart.update();
}

function updateRecordableRateChart(chart, data) {
    const siteData = {};
    data.forEach(row => {
        const site = row.site || 'Unknown';
        if (!siteData[site]) {
            siteData[site] = { total: 0, recordable: 0 };
        }
        siteData[site].total++;
        if (row.recordable === 1) {
            siteData[site].recordable++;
        }
    });
    
    const siteRates = Object.entries(siteData)
        .map(([site, data]) => ({
            site,
            rate: data.total > 0 ? ((data.recordable / data.total) * 100).toFixed(1) : 0
        }))
        .sort((a, b) => b.rate - a.rate);
    
    chart.config.type = 'bar';
    chart.data = {
        labels: siteRates.map(s => s.site),
        datasets: [{
            data: siteRates.map(s => parseFloat(s.rate)),
            backgroundColor: '#FF5722',
            borderWidth: 1,
            label: 'Recordable Rate %'
        }]
    };
    chart.options = getChartOptions('bar');
    chart.options.scales.y.max = 100;
    chart.update();
}

function updateSiteChart(chart, data) {
    const siteCounts = {};
    data.forEach(row => {
        const site = row.site || 'Unknown';
        siteCounts[site] = (siteCounts[site] || 0) + 1;
    });
    
    const sites = Object.entries(siteCounts)
        .sort((a, b) => b[1] - a[1]);
    
    chart.config.type = 'bar';
    chart.data = {
        labels: sites.map(([site]) => site),
        datasets: [{
            data: sites.map(([, count]) => count),
            backgroundColor: sites.map((_, i) => 
                i % 2 === 0 ? AMAZON_COLORS.orange : AMAZON_COLORS.darkBlue
            ),
            borderWidth: 1,
            label: 'Incidents'
        }]
    };
    chart.options = getChartOptions('bar');
    chart.update();
}

function updateImpactTypeChart(chart, data) {
    const impactCounts = {};
    data.forEach(row => {
        const impact = row.impactType || row.primaryImpact || row.type || 'Unknown';
        impactCounts[impact] = (impactCounts[impact] || 0) + 1;
    });
    
    const topImpacts = Object.entries(impactCounts)
        .sort((a, b) => b[1] - a[1])
        .slice(0, 6);
    
    chart.config.type = 'pie';
    chart.data = {
        labels: topImpacts.map(([impact]) => impact),
        datasets: [{
            data: topImpacts.map(([, count]) => count),
            backgroundColor: [
                AMAZON_COLORS.orange,
                AMAZON_COLORS.darkBlue,
                AMAZON_COLORS.lightBlue,
                '#FF5722',
                '#4CAF50',
                '#2196F3'
            ],
            label: 'Cases'
        }]
    };
    chart.options = getChartOptions('pie');
    chart.update();
}

function updateSeverityBySiteChart(chart, data) {
    const siteData = {};
    data.forEach(row => {
        const site = row.site || 'Unknown';
        if (!siteData[site]) {
            siteData[site] = { A: 0, B: 0, C: 0, D: 0 };
        }
        if (row.severity && siteData[site][row.severity] !== undefined) {
            siteData[site][row.severity]++;
        }
    });
    
    const sites = Object.keys(siteData).sort();
    
    chart.config.type = 'bar';
    chart.data = {
        labels: sites,
        datasets: [
            {
                label: 'Severity A',
                data: sites.map(site => siteData[site].A),
                backgroundColor: SEVERITY_COLORS.A
            },
            {
                label: 'Severity B',
                data: sites.map(site => siteData[site].B),
                backgroundColor: SEVERITY_COLORS.B
            },
            {
                label: 'Severity C',
                data: sites.map(site => siteData[site].C),
                backgroundColor: SEVERITY_COLORS.C
            },
            {
                label: 'Severity D',
                data: sites.map(site => siteData[site].D),
backgroundColor: SEVERITY_COLORS.D
            }
        ]
    };
    chart.options = getChartOptions('bar');
    chart.options.scales.x.stacked = true;
    chart.options.scales.y.stacked = true;
    chart.update();
}

function updateLocationHeatmapChart(chart, data) {
    const locationRisk = {};
    data.forEach(row => {
        const location = row.location || row.initial_info_location_event || 'Unknown';
        if (!locationRisk[location]) {
            locationRisk[location] = { total: 0, count: 0 };
        }
        const risk = parseFloat(row.risk || calculateRiskScore(row));
        if (!isNaN(risk)) {
            locationRisk[location].total += risk;
            locationRisk[location].count++;
        }
    });
    
    const topLocations = Object.entries(locationRisk)
        .map(([location, data]) => ({
            location,
            avgRisk: data.count > 0 ? (data.total / data.count).toFixed(1) : 0,
            count: data.count
        }))
        .sort((a, b) => b.avgRisk - a.avgRisk)
        .slice(0, 10);
    
    chart.config.type = 'bar';
    chart.data = {
        labels: topLocations.map(l => l.location.substring(0, 30) + (l.location.length > 30 ? '...' : '')),
        datasets: [{
            label: 'Average Risk Score',
            data: topLocations.map(l => parseFloat(l.avgRisk)),
            backgroundColor: topLocations.map(l => {
                const risk = parseFloat(l.avgRisk);
                if (risk >= 8) return SEVERITY_COLORS.A;
                if (risk >= 6) return SEVERITY_COLORS.B;
                if (risk >= 4) return SEVERITY_COLORS.C;
                return SEVERITY_COLORS.D;
            }),
            borderWidth: 1
        }]
    };
    chart.options = getChartOptions('bar');
    chart.options.indexAxis = 'y';
    chart.update();
}

function updateBodyPartHeatmapChart(chart, data) {
    const bodyPartSeverity = {};
    data.forEach(row => {
        const part = row.bodyPart || 'Unknown';
        if (!bodyPartSeverity[part]) {
            bodyPartSeverity[part] = { A: 0, B: 0, C: 0, D: 0, total: 0 };
        }
        if (row.severity && bodyPartSeverity[part][row.severity] !== undefined) {
            bodyPartSeverity[part][row.severity]++;
            bodyPartSeverity[part].total++;
        }
    });
    
    const topBodyParts = Object.entries(bodyPartSeverity)
        .sort((a, b) => b[1].total - a[1].total)
        .slice(0, 10);
    
    chart.config.type = 'bar';
    chart.data = {
        labels: topBodyParts.map(([part]) => part.substring(0, 20) + (part.length > 20 ? '...' : '')),
        datasets: [
            {
                label: 'Severity A',
                data: topBodyParts.map(([, data]) => data.A),
                backgroundColor: SEVERITY_COLORS.A
            },
            {
                label: 'Severity B',
                data: topBodyParts.map(([, data]) => data.B),
                backgroundColor: SEVERITY_COLORS.B
            },
            {
                label: 'Severity C',
                data: topBodyParts.map(([, data]) => data.C),
                backgroundColor: SEVERITY_COLORS.C
            },
            {
                label: 'Severity D',
                data: topBodyParts.map(([, data]) => data.D),
                backgroundColor: SEVERITY_COLORS.D
            }
        ]
    };
    chart.options = getChartOptions('bar');
    chart.options.indexAxis = 'y';
    chart.options.scales.x.stacked = true;
    chart.options.scales.y.stacked = true;
    chart.update();
}

function updateRiskTrendChart(chart, data) {
    const monthlyRisk = {};
    data.forEach(row => {
        if (row.parsedDate && !isNaN(row.parsedDate)) {
            const monthKey = `${row.parsedDate.getFullYear()}-${String(row.parsedDate.getMonth() + 1).padStart(2, '0')}`;
            if (!monthlyRisk[monthKey]) {
                monthlyRisk[monthKey] = { total: 0, count: 0 };
            }
            const risk = parseFloat(row.risk || calculateRiskScore(row));
            if (!isNaN(risk)) {
                monthlyRisk[monthKey].total += risk;
                monthlyRisk[monthKey].count++;
            }
        }
    });
    
    const sortedMonths = Object.keys(monthlyRisk).sort();
    const monthNames = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
    
    chart.config.type = 'line';
    chart.data = {
        labels: sortedMonths.map(m => {
            const [year, month] = m.split('-');
            return `${monthNames[parseInt(month)-1]} ${year}`;
        }),
        datasets: [{
            label: 'Average Risk Score',
            data: sortedMonths.map(m => 
                monthlyRisk[m].count > 0 ? (monthlyRisk[m].total / monthlyRisk[m].count).toFixed(1) : 0
            ),
            borderColor: AMAZON_COLORS.orange,
            backgroundColor: `${AMAZON_COLORS.orange}20`,
            tension: 0.3,
            borderWidth: 2
        }]
    };
    chart.options = getChartOptions('line');
    chart.update();
}

function updateHighRiskAreasChart(chart, data) {
    const highRiskData = data.filter(r => {
        const risk = parseFloat(r.risk || calculateRiskScore(r));
        return risk >= 7;
    });
    
    const areaCounts = {};
    highRiskData.forEach(row => {
        const key = `${row.location || row.bodyPart || 'Unknown'} - ${row.processPath || 'Unknown'}`;
        areaCounts[key] = (areaCounts[key] || 0) + 1;
    });
    
    const topAreas = Object.entries(areaCounts)
        .sort((a, b) => b[1] - a[1])
        .slice(0, 10);
    
    chart.config.type = 'bar';
    chart.data = {
        labels: topAreas.map(([area]) => area.substring(0, 40) + (area.length > 40 ? '...' : '')),
        datasets: [{
            label: 'High Risk Incidents',
            data: topAreas.map(([, count]) => count),
            backgroundColor: SEVERITY_COLORS.A,
            borderColor: SEVERITY_COLORS.B,
            borderWidth: 1
        }]
    };
    chart.options = getChartOptions('bar');
    chart.options.indexAxis = 'y';
    chart.update();
}

function updatePreventionOpportunitiesChart(chart, data) {
    const preventionData = {};
    
    data.forEach(row => {
        const factor = row.contributingFactor || 'Unknown';
        if (!preventionData[factor]) {
            preventionData[factor] = {
                total: 0,
                highSeverity: 0,
                preventable: 0
            };
        }
        preventionData[factor].total++;
        if (row.severity === 'A' || row.severity === 'B') {
            preventionData[factor].highSeverity++;
        }
        if (row.standardized_likelihood !== 'Rare') {
            preventionData[factor].preventable++;
        }
    });
    
    const topOpportunities = Object.entries(preventionData)
        .map(([factor, data]) => ({
            factor,
            preventionScore: (data.preventable / data.total) * (data.highSeverity + 1)
        }))
        .sort((a, b) => b.preventionScore - a.preventionScore)
        .slice(0, 8);
    
    chart.config.type = 'bar';
    chart.data = {
        labels: topOpportunities.map(o => o.factor),
        datasets: [{
            label: 'Prevention Priority Score',
            data: topOpportunities.map(o => o.preventionScore.toFixed(1)),
            backgroundColor: AMAZON_COLORS.orange,
            borderColor: AMAZON_COLORS.darkBlue,
            borderWidth: 1
        }]
    };
    chart.options = getChartOptions('bar');
    chart.update();
}

function updateQualityMetricsChart(chart, data, module) {
    const metrics = module === 'injury' ? state.injury.qualityMetrics : state.nearMiss.qualityMetrics;
    
    if (!metrics || !metrics.totalRecords) {
        chart.data = { labels: [], datasets: [] };
        chart.update();
        return;
    }
    
    chart.config.type = 'radar';
    chart.data = {
        labels: ['Completeness', 'Uniqueness', 'Accuracy', 'Consistency', 'Overall'],
        datasets: [{
            label: 'Data Quality Score',
            data: [
                metrics.dataCompleteness,
                Math.max(0, 100 - (metrics.duplicates * 5)),
                Math.max(0, 100 - (metrics.missingCriticalFields / metrics.totalRecords * 100)),
                85, // Placeholder for consistency
                metrics.qualityScore
            ],
            borderColor: AMAZON_COLORS.orange,
            backgroundColor: `${AMAZON_COLORS.orange}30`,
            borderWidth: 2
        }]
    };
    chart.options = {
        ...getChartOptions('radar'),
        scales: {
            r: {
                beginAtZero: true,
                max: 100,
                ticks: {
                    stepSize: 20
                }
            }
        }
    };
    chart.update();
}

function updateTrendForecastChart(chart, data, module) {
    const monthlyData = {};
    data.forEach(row => {
        if (row.parsedDate && !isNaN(row.parsedDate)) {
            const monthKey = `${row.parsedDate.getFullYear()}-${String(row.parsedDate.getMonth() + 1).padStart(2, '0')}`;
            monthlyData[monthKey] = (monthlyData[monthKey] || 0) + 1;
        }
    });
    
    const sortedMonths = Object.keys(monthlyData).sort();
    const monthNames = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
    
    // Simple linear regression for forecast
    const values = sortedMonths.map(m => monthlyData[m]);
    const n = values.length;
    const sumX = values.reduce((sum, _, i) => sum + i, 0);
    const sumY = values.reduce((sum, y) => sum + y, 0);
    const sumXY = values.reduce((sum, y, i) => sum + i * y, 0);
    const sumX2 = values.reduce((sum, _, i) => sum + i * i, 0);
    
    const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
    const intercept = (sumY - slope * sumX) / n;
    
    // Generate forecast for next 3 months
    const forecastMonths = [];
    const forecastValues = [];
    for (let i = 0; i < 3; i++) {
        const lastMonth = sortedMonths[sortedMonths.length - 1];
        const [year, month] = lastMonth.split('-');
        const nextDate = new Date(parseInt(year), parseInt(month) - 1 + i + 1);
        const nextMonth = `${nextDate.getFullYear()}-${String(nextDate.getMonth() + 1).padStart(2, '0')}`;
        forecastMonths.push(nextMonth);
        forecastValues.push(Math.max(0, Math.round(slope * (n + i) + intercept)));
    }
    
    chart.config.type = 'line';
    chart.data = {
        labels: [
            ...sortedMonths.map(m => {
                const [year, month] = m.split('-');
                return `${monthNames[parseInt(month)-1]} ${year}`;
            }),
            ...forecastMonths.map(m => {
                const [year, month] = m.split('-');
                return `${monthNames[parseInt(month)-1]} ${year} (Forecast)`;
            })
        ],
        datasets: [
            {
                label: 'Actual',
                data: [...values, ...Array(3).fill(null)],
                borderColor: AMAZON_COLORS.darkBlue,
                backgroundColor: `${AMAZON_COLORS.darkBlue}20`,
                tension: 0.3,
                borderWidth: 2
            },
            {
                label: 'Forecast',
                data: [...Array(values.length).fill(null), values[values.length - 1], ...forecastValues],
                borderColor: AMAZON_COLORS.orange,
                backgroundColor: `${AMAZON_COLORS.orange}20`,
                borderDash: [5, 5],
                tension: 0.3,
                borderWidth: 2
            }
        ]
    };
    chart.options = getChartOptions('line');
    chart.update();
}

function updateWeeklyTrendChart(chart, data) {
    const weeklyData = {};
    data.forEach(row => {
        if (row.parsedDate && !isNaN(row.parsedDate)) {
            const weekKey = getWeekNumber(row.parsedDate);
            weeklyData[weekKey] = (weeklyData[weekKey] || 0) + 1;
        }
    });
    
    const sortedWeeks = Object.keys(weeklyData).sort().slice(-12); // Last 12 weeks
    
    chart.config.type = 'line';
    chart.data = {
        labels: sortedWeeks.map(w => `Week ${w.split('-')[1]}`),
        datasets: [{
            label: 'Weekly Incidents',
            data: sortedWeeks.map(w => weeklyData[w]),
            borderColor: AMAZON_COLORS.orange,
            backgroundColor: `${AMAZON_COLORS.orange}20`,
            tension: 0.3
        }]
    };
    chart.options = getChartOptions('line');
    chart.update();
}

function updateBodyPartTrendChart(chart, data) {
    const monthlyBodyPart = {};
    
    data.forEach(row => {
        if (row.parsedDate && !isNaN(row.parsedDate) && row.bodyPart) {
            const monthKey = `${row.parsedDate.getFullYear()}-${String(row.parsedDate.getMonth() + 1).padStart(2, '0')}`;
            if (!monthlyBodyPart[monthKey]) {
                monthlyBodyPart[monthKey] = {};
            }
            const part = row.bodyPart;
            monthlyBodyPart[monthKey][part] = (monthlyBodyPart[monthKey][part] || 0) + 1;
        }
    });
    
    const months = Object.keys(monthlyBodyPart).sort().slice(-6);
    const topBodyParts = getTopBodyParts(data, 5);
    
    chart.config.type = 'line';
    chart.data = {
        labels: months.map(formatMonthLabel),
        datasets: topBodyParts.map((part, index) => ({
            label: part,
            data: months.map(month => monthlyBodyPart[month][part] || 0),
            borderColor: getColorByIndex(index),
            backgroundColor: `${getColorByIndex(index)}20`,
            tension: 0.3
        }))
    };
    chart.options = getChartOptions('line');
    chart.update();
}

function updateShiftAnalysisChart(chart, data) {
    const shiftData = {};
    data.forEach(row => {
        const shift = row.initial_info_shift || row.shift || 'Unknown';
        shiftData[shift] = (shiftData[shift] || 0) + 1;
    });
    
    chart.config.type = 'bar';
    chart.data = {
        labels: Object.keys(shiftData),
        datasets: [{
            label: 'Incidents by Shift',
            data: Object.values(shiftData),
            backgroundColor: AMAZON_COLORS.darkBlue,
            borderColor: AMAZON_COLORS.orange,
            borderWidth: 1
        }]
    };
    chart.options = getChartOptions('bar');
    chart.update();
}

function updateDafwAnalysisChart(chart, data) {
    const dafwRanges = {
        '0 Days': 0,
        '1-3 Days': 0,
        '4-7 Days': 0,
        '8-14 Days': 0,
        '15-30 Days': 0,
        '30+ Days': 0
    };
    
    data.forEach(row => {
        const days = row.total_dafw_days || 0;
        if (days === 0) dafwRanges['0 Days']++;
        else if (days <= 3) dafwRanges['1-3 Days']++;
        else if (days <= 7) dafwRanges['4-7 Days']++;
        else if (days <= 14) dafwRanges['8-14 Days']++;
        else if (days <= 30) dafwRanges['15-30 Days']++;
        else dafwRanges['30+ Days']++;
    });
    
    chart.config.type = 'doughnut';
    chart.data = {
        labels: Object.keys(dafwRanges),
        datasets: [{
            data: Object.values(dafwRanges),
            backgroundColor: [
                SEVERITY_COLORS.D,
                SEVERITY_COLORS.C,
                AMAZON_COLORS.orange,
                SEVERITY_COLORS.B,
                SEVERITY_COLORS.A,
                AMAZON_COLORS.darkBlue
            ]
        }]
    };
    chart.options = getChartOptions('doughnut');
    chart.update();
}

function updateOtrAnalysisChart(chart, data) {
    const otrData = data.filter(r => r.otr === 'yes');
    const nonOtrData = data.filter(r => r.otr === 'no');
    
    chart.config.type = 'pie';
    chart.data = {
        labels: ['On The Road', 'Under The Roof'],
        datasets: [{
            data: [otrData.length, nonOtrData.length],
            backgroundColor: [AMAZON_COLORS.orange, AMAZON_COLORS.darkBlue]
        }]
    };
    chart.options = getChartOptions('pie');
    chart.update();
}

function updateLocationChart(chart, data) {
    const locationCounts = {};
    data.forEach(row => {
        const location = row.location || row.initial_info_location_event || 'Unknown';
        locationCounts[location] = (locationCounts[location] || 0) + 1;
    });

    const topLocations = Object.entries(locationCounts)
        .sort((a, b) => b[1] - a[1])
        .slice(0, 10);

    chart.config.type = 'bar';
    chart.data = {
        labels: topLocations.map(([loc]) => loc.substring(0, 30) + (loc.length > 30 ? '...' : '')),
        datasets: [{
            label: 'Near Misses',
            data: topLocations.map(([, count]) => count),
            backgroundColor: AMAZON_COLORS.orange,
            borderWidth: 1
        }]
    };
    chart.options = getChartOptions('bar');
    chart.options.indexAxis = 'y';
    chart.update();
}

function updateImpactChart(chart, data) {
    const impactCounts = {};
    data.forEach(row => {
        const impact = row.primaryImpact || row.initial_info_primary_impact || 'Unknown';
        impactCounts[impact] = (impactCounts[impact] || 0) + 1;
    });

    const topImpacts = Object.entries(impactCounts)
        .sort((a, b) => b[1] - a[1])
        .slice(0, 8);

    chart.config.type = 'doughnut';
    chart.data = {
        labels: topImpacts.map(([impact]) => impact),
        datasets: [{
            data: topImpacts.map(([, count]) => count),
            backgroundColor: [
                AMAZON_COLORS.orange,
                AMAZON_COLORS.darkBlue,
                '#FF5722',
                '#4CAF50',
                '#2196F3',
                '#9C27B0',
                '#FFC107',
                '#795548'
            ]
        }]
    };
    chart.options = getChartOptions('doughnut');
    chart.update();
}

function updateLikelihoodChart(chart, data) {
    const likelihoodCounts = {
        'Rare': 0,
        'Unlikely': 0,
        'Possible': 0,
        'Likely': 0,
        'Almost Certain': 0
    };

    data.forEach(row => {
        const likelihood = row.standardized_likelihood || 'Possible';
        if (likelihoodCounts[likelihood] !== undefined) {
            likelihoodCounts[likelihood]++;
        }
    });

    chart.config.type = 'bar';
    chart.data = {
        labels: Object.keys(likelihoodCounts),
        datasets: [{
            label: 'Frequency',
            data: Object.values(likelihoodCounts),
            backgroundColor: [
                SEVERITY_COLORS.D,
                SEVERITY_COLORS.C,
                AMAZON_COLORS.orange,
                SEVERITY_COLORS.B,
                SEVERITY_COLORS.A
            ]
        }]
    };
    chart.options = getChartOptions('bar');
    chart.update();
}

function updateInjuryTypeChart(chart, data) {
    const typeCounts = {};
    data.forEach(row => {
        const type = row.type || row.injury_type || 'Unknown';
        typeCounts[type] = (typeCounts[type] || 0) + 1;
    });

    const topTypes = Object.entries(typeCounts)
        .sort((a, b) => b[1] - a[1])
        .slice(0, 8);

    chart.config.type = 'pie';
    chart.data = {
        labels: topTypes.map(([type]) => type),
        datasets: [{
            data: topTypes.map(([, count]) => count),
            backgroundColor: [
                '#FF6384',
                '#36A2EB',
                '#FFCE56',
                '#4BC0C0',
                '#9966FF',
                '#FF9F40',
                '#FF6384',
                '#C9CBCF'
            ]
        }]
    };
    chart.options = getChartOptions('pie');
    chart.update();
}

function updateRecordableDistributionChart(chart, data) {
    const recordable = data.filter(r => r.recordable === 1).length;
    const nonRecordable = data.filter(r => r.recordable === 0).length;

    chart.config.type = 'doughnut';
    chart.data = {
        labels: ['Recordable', 'Non-Recordable'],
        datasets: [{
            data: [recordable, nonRecordable],
            backgroundColor: [SEVERITY_COLORS.B, SEVERITY_COLORS.D]
        }]
    };
    chart.options = getChartOptions('doughnut');
    chart.update();
}

function updateStatusDistributionChart(chart, data) {
    const statusCounts = {};
    data.forEach(row => {
        const status = row.status || 'Unknown';
        statusCounts[status] = (statusCounts[status] || 0) + 1;
    });

    chart.config.type = 'pie';
    chart.data = {
        labels: Object.keys(statusCounts),
        datasets: [{
            data: Object.values(statusCounts),
            backgroundColor: Object.keys(statusCounts).map((status, index) => {
                if (status === 'Closed' || status === 'Completed') return SEVERITY_COLORS.D;
                if (status === 'Open' || status === 'In Progress') return AMAZON_COLORS.orange;
                if (status === 'Pending') return SEVERITY_COLORS.C;
                return ['#9E9E9E', '#607D8B', '#795548'][index % 3];
            })
        }]
    };
    chart.options = getChartOptions('pie');
    chart.update();
}

function updateClosureAnalysisChart(chart, data) {
    const monthlyClosures = {};

    data.forEach(row => {
        if (row.parsedDate && !isNaN(row.parsedDate)) {
            const monthKey = `${row.parsedDate.getFullYear()}-${String(row.parsedDate.getMonth() + 1).padStart(2, '0')}`;
            if (!monthlyClosures[monthKey]) {
                monthlyClosures[monthKey] = { total: 0, closed: 0 };
            }
            monthlyClosures[monthKey].total++;
            if (row.status === 'Closed' || row.status === 'Completed') {
                monthlyClosures[monthKey].closed++;
            }
        }
    });

    const sortedMonths = Object.keys(monthlyClosures).sort();
    const monthNames = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];

    chart.config.type = 'line';
    chart.data = {
        labels: sortedMonths.map(m => {
            const [year, month] = m.split('-');
            return `${monthNames[parseInt(month)-1]} ${year}`;
        }),
        datasets: [{
            label: 'Closure Rate %',
            data: sortedMonths.map(m => {
                const data = monthlyClosures[m];
                return data.total > 0 ? ((data.closed / data.total) * 100).toFixed(1) : 0;
            }),
            borderColor: SEVERITY_COLORS.D,
            backgroundColor: `${SEVERITY_COLORS.D}20`,
            tension: 0.3
        }]
    };
    chart.options = getChartOptions('line');
    chart.options.scales.y.max = 100;
    chart.update();
}

function updateBodyPartBySiteChart(chart, data) {
    const siteBodyPart = {};
    
    data.forEach(row => {
        const site = row.site || 'Unknown';
        const bodyPart = row.bodyPart || row.initial_info_principal_body_part || 'Unknown';
        
        if (!siteBodyPart[site]) {
            siteBodyPart[site] = {};
        }
        siteBodyPart[site][bodyPart] = (siteBodyPart[site][bodyPart] || 0) + 1;
    });
    
    const sites = Object.keys(siteBodyPart).slice(0, 5);
    const bodyParts = [...new Set(data.map(r => r.bodyPart || r.initial_info_principal_body_part || 'Unknown'))]
        .slice(0, 5);
    
    chart.config.type = 'bar';
    chart.data = {
        labels: sites,
        datasets: bodyParts.map((part, index) => ({
            label: part.substring(0, 20),
            data: sites.map(site => siteBodyPart[site][part] || 0),
            backgroundColor: getColorByIndex(index)
        }))
    };
    chart.options = getChartOptions('bar');
    chart.options.scales.x.stacked = true;
    chart.options.scales.y.stacked = true;
    chart.update();
}

function updateMechanismOfInjuryChart(chart, data) {
    const mechanisms = {};
    
    data.forEach(row => {
        // Use impact type as mechanism proxy
        const mechanism = row.initial_info_impact_type_primary || row.type || 'Unknown';
        mechanisms[mechanism] = (mechanisms[mechanism] || 0) + 1;
    });
    
    const topMechanisms = Object.entries(mechanisms)
        .sort((a, b) => b[1] - a[1])
        .slice(0, 8);
    
    chart.config.type = 'doughnut';
    chart.data = {
        labels: topMechanisms.map(([mech]) => mech),
        datasets: [{
            data: topMechanisms.map(([, count]) => count),
            backgroundColor: [
                '#FF6384', '#36A2EB', '#FFCE56', '#4BC0C0',
                '#9966FF', '#FF9F40', '#FF6384', '#C9CBCF'
            ]
        }]
    };
    chart.options = getChartOptions('doughnut');
    chart.update();
}

function updateDepartmentAnalysisChart(chart, data) {
    const deptData = {};
    
    data.forEach(row => {
        const dept = row.initial_info_contractor_department || row.suborg || 'Unknown';
        deptData[dept] = (deptData[dept] || 0) + 1;
    });
    
    const topDepts = Object.entries(deptData)
        .sort((a, b) => b[1] - a[1])
        .slice(0, 10);
    
    chart.config.type = 'bar';
    chart.data = {
        labels: topDepts.map(([dept]) => dept.substring(0, 20)),
        datasets: [{
            label: 'Incidents',
            data: topDepts.map(([, count]) => count),
            backgroundColor: AMAZON_COLORS.darkBlue,
            borderColor: AMAZON_COLORS.orange,
            borderWidth: 1
        }]
    };
    chart.options = getChartOptions('bar');
    chart.update();
}

function updateRootCauseTrendChart(chart, data) {
    const monthlyRootCause = {};
    
    data.forEach(row => {
        if (row.parsedDate && !isNaN(row.parsedDate)) {
            const monthKey = `${row.parsedDate.getFullYear()}-${String(row.parsedDate.getMonth() + 1).padStart(2, '0')}`;
            const cause = row.rootCause || row.rca_primary_cause || 'Unknown';
            
            if (!monthlyRootCause[monthKey]) {
                monthlyRootCause[monthKey] = {};
            }
            monthlyRootCause[monthKey][cause] = (monthlyRootCause[monthKey][cause] || 0) + 1;
        }
    });
    
    const months = Object.keys(monthlyRootCause).sort().slice(-6);
    const topCauses = [...new Set(data.map(r => r.rootCause || r.rca_primary_cause || 'Unknown'))]
        .slice(0, 5);
    
    chart.config.type = 'line';
    chart.data = {
        labels: months.map(formatMonthLabel),
        datasets: topCauses.map((cause, index) => ({
            label: cause.substring(0, 30),
            data: months.map(month => monthlyRootCause[month][cause] || 0),
            borderColor: getColorByIndex(index),
            backgroundColor: `${getColorByIndex(index)}20`,
            tension: 0.3
        }))
    };
    chart.options = getChartOptions('line');
    chart.update();
}

function updateRecordableTrendChart(chart, data) {
    const monthlyData = {};
    
    data.forEach(row => {
        if (row.parsedDate && !isNaN(row.parsedDate)) {
            const monthKey = `${row.parsedDate.getFullYear()}-${String(row.parsedDate.getMonth() + 1).padStart(2, '0')}`;
            if (!monthlyData[monthKey]) {
                monthlyData[monthKey] = { total: 0, recordable: 0 };
            }
            monthlyData[monthKey].total++;
            if (row.recordable === 1) {
                monthlyData[monthKey].recordable++;
            }
        }
    });
    
    const sortedMonths = Object.keys(monthlyData).sort();
    
    chart.config.type = 'line';
    chart.data = {
        labels: sortedMonths.map(formatMonthLabel),
        datasets: [{
            label: 'Recordable Rate %',
            data: sortedMonths.map(m => {
                const data = monthlyData[m];
                return data.total > 0 ? ((data.recordable / data.total) * 100).toFixed(1) : 0;
            }),
            borderColor: SEVERITY_COLORS.B,
            backgroundColor: `${SEVERITY_COLORS.B}20`,
            tension: 0.3
        }]
    };
    chart.options = getChartOptions('line');
    chart.options.scales.y.max = 100;
    chart.update();
}

function updateLostTimeAnalysisChart(chart, data) {
    const lostTimeData = data.filter(r => r.total_dafw_days > 0);
    const siteLostTime = {};
    
    lostTimeData.forEach(row => {
        const site = row.site || 'Unknown';
        if (!siteLostTime[site]) {
            siteLostTime[site] = { count: 0, totalDays: 0 };
        }
        siteLostTime[site].count++;
        siteLostTime[site].totalDays += row.total_dafw_days;
    });
    
    const sites = Object.keys(siteLostTime);
    
    chart.config.type = 'bar';
    chart.data = {
        labels: sites,
        datasets: [
            {
                label: 'Lost Time Cases',
                data: sites.map(site => siteLostTime[site].count),
                backgroundColor: SEVERITY_COLORS.B,
                yAxisID: 'y'
            },
            {
                label: 'Total Days Lost',
                data: sites.map(site => siteLostTime[site].totalDays),
                backgroundColor: AMAZON_COLORS.orange,
                yAxisID: 'y1'
            }
        ]
    };
    chart.options = {
        ...getChartOptions('bar'),
        scales: {
            y: {
                type: 'linear',
                display: true,
                position: 'left',
                title: { display: true, text: 'Cases' }
            },
            y1: {
                type: 'linear',
                display: true,
                position: 'right',
                title: { display: true, text: 'Days' },
                grid: { drawOnChartArea: false }
            }
        }
    };
    chart.update();
}

// Near Miss specific functions

function updateLocationTrendChart(chart, data) {
    const monthlyLocation = {};
    
    data.forEach(row => {
        if (row.parsedDate && !isNaN(row.parsedDate)) {
            const monthKey = `${row.parsedDate.getFullYear()}-${String(row.parsedDate.getMonth() + 1).padStart(2, '0')}`;
            const location = row.location || row.initial_info_location_event || 'Unknown';
            
            if (!monthlyLocation[monthKey]) {
                monthlyLocation[monthKey] = {};
            }
            monthlyLocation[monthKey][location] = (monthlyLocation[monthKey][location] || 0) + 1;
        }
    });
    
    const months = Object.keys(monthlyLocation).sort().slice(-6);
    const topLocations = [...new Set(data.map(r => r.location || r.initial_info_location_event || 'Unknown'))]
        .slice(0, 5);
    
    chart.config.type = 'line';
    chart.data = {
        labels: months.map(formatMonthLabel),
        datasets: topLocations.map((location, index) => ({
            label: location.substring(0, 20),
            data: months.map(month => monthlyLocation[month][location] || 0),
            borderColor: getColorByIndex(index),
            backgroundColor: `${getColorByIndex(index)}20`,
            tension: 0.3
        }))
    };
    chart.options = getChartOptions('line');
    chart.update();
}

function updateLocationBySeverityChart(chart, data) {
    const locationSeverity = {};
    
    data.forEach(row => {
        const location = row.location || row.initial_info_location_event || 'Unknown';
        const severity = row.severity || row.potential_severity || 'Unknown';
        
        if (!locationSeverity[location]) {
            locationSeverity[location] = { A: 0, B: 0, C: 0, D: 0 };
        }
        if (locationSeverity[location][severity] !== undefined) {
            locationSeverity[location][severity]++;
        }
    });
    
    const topLocations = Object.entries(locationSeverity)
        .sort((a, b) => {
            const totalA = a[1].A + a[1].B + a[1].C + a[1].D;
            const totalB = b[1].A + b[1].B + b[1].C + b[1].D;
            return totalB - totalA;
        })
        .slice(0, 8);
    
    chart.config.type = 'bar';
    chart.data = {
        labels: topLocations.map(([loc]) => loc.substring(0, 25)),
        datasets: [
            {
                label: 'Severity A',
                data: topLocations.map(([, data]) => data.A),
                backgroundColor: SEVERITY_COLORS.A
            },
            {
                label: 'Severity B',
                data: topLocations.map(([, data]) => data.B),
                backgroundColor: SEVERITY_COLORS.B
            },
            {
                label: 'Severity C',
                data: topLocations.map(([, data]) => data.C),
                backgroundColor: SEVERITY_COLORS.C
            },
            {
                label: 'Severity D',
                data: topLocations.map(([, data]) => data.D),
                backgroundColor: SEVERITY_COLORS.D
            }
        ]
    };
    chart.options = getChartOptions('bar');
    chart.options.scales.x.stacked = true;
    chart.options.scales.y.stacked = true;
    chart.update();
}

function updateImpactSeverityChart(chart, data) {
    const impactSeverity = {};
    
    data.forEach(row => {
        const impact = row.primaryImpact || row.initial_info_primary_impact || 'Unknown';
        const severity = row.severity || row.potential_severity || 'Unknown';
        
        if (!impactSeverity[impact]) {
            impactSeverity[impact] = { A: 0, B: 0, C: 0, D: 0 };
        }
        if (impactSeverity[impact][severity] !== undefined) {
            impactSeverity[impact][severity]++;
        }
    });
    
    const topImpacts = Object.entries(impactSeverity)
        .sort((a, b) => {
            const totalA = a[1].A + a[1].B + a[1].C + a[1].D;
            const totalB = b[1].A + b[1].B + b[1].C + b[1].D;
            return totalB - totalA;
        })
        .slice(0, 6);
    
    chart.config.type = 'bar';
    chart.data = {
        labels: topImpacts.map(([impact]) => impact),
        datasets: [
            {
                label: 'Severity A',
                data: topImpacts.map(([, data]) => data.A),
                backgroundColor: SEVERITY_COLORS.A
            },
            {
                label: 'Severity B',
                data: topImpacts.map(([, data]) => data.B),
                backgroundColor: SEVERITY_COLORS.B
            },
            {
                label: 'Severity C',
                data: topImpacts.map(([, data]) => data.C),
                backgroundColor: SEVERITY_COLORS.C
            },
            {
                label: 'Severity D',
                data: topImpacts.map(([, data]) => data.D),
                backgroundColor: SEVERITY_COLORS.D
            }
        ]
    };
    chart.options = getChartOptions('bar');
    chart.options.scales.x.stacked = true;
    chart.options.scales.y.stacked = true;
    chart.update();
}

function updateRiskScoreChart(chart, data) {
    const riskRanges = {
        '0-2': 0,
        '2-4': 0,
        '4-6': 0,
        '6-8': 0,
        '8-10': 0
    };
    
    data.forEach(row => {
        const risk = parseFloat(row.risk || calculateRiskScore(row));
        if (risk <= 2) riskRanges['0-2']++;
        else if (risk <= 4) riskRanges['2-4']++;
        else if (risk <= 6) riskRanges['4-6']++;
        else if (risk <= 8) riskRanges['6-8']++;
        else riskRanges['8-10']++;
    });
    
    chart.config.type = 'bar';
    chart.data = {
        labels: Object.keys(riskRanges),
        datasets: [{
            label: 'Near Misses',
            data: Object.values(riskRanges),
            backgroundColor: [
                SEVERITY_COLORS.D,
                SEVERITY_COLORS.C,
                AMAZON_COLORS.orange,
                SEVERITY_COLORS.B,
                SEVERITY_COLORS.A
            ]
        }]
    };
    chart.options = getChartOptions('bar');
    chart.update();
}

function updateSeverityTrendChart(chart, data) {
    const monthlySeverity = {};
    
    data.forEach(row => {
        if (row.parsedDate && !isNaN(row.parsedDate)) {
            const monthKey = `${row.parsedDate.getFullYear()}-${String(row.parsedDate.getMonth() + 1).padStart(2, '0')}`;
            const severity = row.severity || row.potential_severity || 'Unknown';
            
            if (!monthlySeverity[monthKey]) {
                monthlySeverity[monthKey] = { A: 0, B: 0, C: 0, D: 0 };
            }
            if (monthlySeverity[monthKey][severity] !== undefined) {
                monthlySeverity[monthKey][severity]++;
            }
        }
    });
    
    const sortedMonths = Object.keys(monthlySeverity).sort();
    
    chart.config.type = 'line';
    chart.data = {
        labels: sortedMonths.map(formatMonthLabel),
        datasets: [
            {
                label: 'Severity A',
                data: sortedMonths.map(m => monthlySeverity[m].A),
                borderColor: SEVERITY_COLORS.A,
                backgroundColor: `${SEVERITY_COLORS.A}20`,
                tension: 0.3
            },
            {
                label: 'Severity B',
                data: sortedMonths.map(m => monthlySeverity[m].B),
                borderColor: SEVERITY_COLORS.B,
                backgroundColor: `${SEVERITY_COLORS.B}20`,
                tension: 0.3
            },
            {
                label: 'Severity C',
                data: sortedMonths.map(m => monthlySeverity[m].C),
                borderColor: SEVERITY_COLORS.C,
                backgroundColor: `${SEVERITY_COLORS.C}20`,
                tension: 0.3
            },
            {
                label: 'Severity D',
                data: sortedMonths.map(m => monthlySeverity[m].D),
                borderColor: SEVERITY_COLORS.D,
                backgroundColor: `${SEVERITY_COLORS.D}20`,
                tension: 0.3
            }
        ]
    };
    chart.options = getChartOptions('line');
    chart.update();
}

function updateBodyPartChart(chart, data) {
    const counts = {};
    data.forEach(row => {
        const part = row.bodyPart || row.initial_info_principal_body_part || 'Unknown';
        counts[part] = (counts[part] || 0) + 1;
    });

    const topParts = Object.entries(counts)
        .sort((a, b) => b[1] - a[1])
        .slice(0, 8);

    chart.config.type = 'bar';
    chart.data = {
        labels: topParts.map(([part]) => part),
        datasets: [{
            label: 'Cases',
            data: topParts.map(([, count]) => count),
            backgroundColor: AMAZON_COLORS.orange,
            borderWidth: 1
        }]
    };
    chart.options = getChartOptions('bar');
    chart.options.indexAxis = 'y';
    chart.update();
}

function updateInjuryTypeByProcessChart(chart, data) {
    const processTypes = {};
    data.forEach(row => {
        const process = row.processPath || 'Unknown';
        const type = row.injuryType || row.initial_info_injury_type || 'Unknown';
        if (!processTypes[process]) processTypes[process] = {};
        processTypes[process][type] = (processTypes[process][type] || 0) + 1;
    });

    const processes = Object.keys(processTypes).slice(0, 5);
    const types = [...new Set(data.map(r => r.injuryType || r.initial_info_injury_type || 'Unknown'))].slice(0, 5);

    chart.config.type = 'bar';
    chart.data = {
        labels: processes,
        datasets: types.map((t, idx) => ({
            label: t.substring(0, 20),
            data: processes.map(p => processTypes[p][t] || 0),
            backgroundColor: getColorByIndex(idx)
        }))
    };
    chart.options = getChartOptions('bar');
    chart.options.scales.x.stacked = true;
    chart.options.scales.y.stacked = true;
    chart.update();
}

function updateRootCauseBySiteChart(chart, data) {
    const siteCause = {};
    data.forEach(row => {
        const site = row.site || 'Unknown';
        const cause = row.rootCause || 'Unknown';
        if (!siteCause[site]) siteCause[site] = {};
        siteCause[site][cause] = (siteCause[site][cause] || 0) + 1;
    });

    const sites = Object.keys(siteCause).slice(0, 5);
    const causes = [...new Set(data.map(r => r.rootCause || 'Unknown'))].slice(0, 5);

    chart.config.type = 'bar';
    chart.data = {
        labels: sites,
        datasets: causes.map((c, idx) => ({
            label: c.substring(0, 20),
            data: sites.map(s => siteCause[s][c] || 0),
            backgroundColor: getColorByIndex(idx)
        }))
    };
    chart.options = getChartOptions('bar');
    chart.options.scales.x.stacked = true;
    chart.options.scales.y.stacked = true;
    chart.update();
}

function updateSeverityPredictionChart(chart, data) {
    updateSeverityChart(chart, data);
}

function updateCostImpactAnalysisChart(chart, data) {
    const ranges = { '0-100': 0, '100-500': 0, '500-1000': 0, '1000+': 0 };
    data.forEach(row => {
        const cost = parseFloat(row.estimatedCost || row.costImpact || 0);
        if (cost <= 100) ranges['0-100']++;
        else if (cost <= 500) ranges['100-500']++;
        else if (cost <= 1000) ranges['500-1000']++;
        else ranges['1000+']++;
    });

    chart.config.type = 'bar';
    chart.data = {
        labels: Object.keys(ranges),
        datasets: [{
            label: 'Cases',
            data: Object.values(ranges),
            backgroundColor: AMAZON_COLORS.darkBlue
        }]
    };
    chart.options = getChartOptions('bar');
    chart.update();
}

function updateRecoveryTimeAnalysisChart(chart, data) {
    const ranges = { '0-7': 0, '8-14': 0, '15-30': 0, '30+': 0 };
    data.forEach(row => {
        const days = parseFloat(row.recoveryTime || row.recoveryDays || row.total_dafw_days || 0);
        if (days <= 7) ranges['0-7']++;
        else if (days <= 14) ranges['8-14']++;
        else if (days <= 30) ranges['15-30']++;
        else ranges['30+']++;
    });

    chart.config.type = 'doughnut';
    chart.data = {
        labels: Object.keys(ranges),
        datasets: [{
            data: Object.values(ranges),
            backgroundColor: [SEVERITY_COLORS.D, SEVERITY_COLORS.C, AMAZON_COLORS.orange, SEVERITY_COLORS.B]
        }]
    };
    chart.options = getChartOptions('doughnut');
    chart.update();
}

function updateImpactByLocationChart(chart, data) {
    const locationImpact = {};
    data.forEach(row => {
        const location = row.location || row.initial_info_location_event || 'Unknown';
        const impact = row.primaryImpact || row.initial_info_primary_impact || 'Unknown';
        if (!locationImpact[location]) locationImpact[location] = {};
        locationImpact[location][impact] = (locationImpact[location][impact] || 0) + 1;
    });

    const locations = Object.keys(locationImpact).slice(0, 5);
    const impacts = [...new Set(data.map(r => r.primaryImpact || r.initial_info_primary_impact || 'Unknown'))].slice(0, 5);

    chart.config.type = 'bar';
    chart.data = {
        labels: locations,
        datasets: impacts.map((im, idx) => ({
            label: im.substring(0, 20),
            data: locations.map(loc => locationImpact[loc][im] || 0),
            backgroundColor: getColorByIndex(idx)
        }))
    };
    chart.options = getChartOptions('bar');
    chart.options.scales.x.stacked = true;
    chart.options.scales.y.stacked = true;
    chart.update();
}

function updateImpactTrendChart(chart, data) {
    const monthlyImpact = {};
    data.forEach(row => {
        if (row.parsedDate && !isNaN(row.parsedDate)) {
            const monthKey = `${row.parsedDate.getFullYear()}-${String(row.parsedDate.getMonth() + 1).padStart(2, '0')}`;
            const impact = row.primaryImpact || row.initial_info_primary_impact || 'Unknown';
            if (!monthlyImpact[monthKey]) monthlyImpact[monthKey] = {};
            monthlyImpact[monthKey][impact] = (monthlyImpact[monthKey][impact] || 0) + 1;
        }
    });

    const months = Object.keys(monthlyImpact).sort().slice(-6);
    const impacts = [...new Set(data.map(r => r.primaryImpact || r.initial_info_primary_impact || 'Unknown'))].slice(0, 5);

    chart.config.type = 'line';
    chart.data = {
        labels: months.map(formatMonthLabel),
        datasets: impacts.map((im, idx) => ({
            label: im,
            data: months.map(m => monthlyImpact[m][im] || 0),
            borderColor: getColorByIndex(idx),
            backgroundColor: `${getColorByIndex(idx)}20`,
            tension: 0.3
        }))
    };
    chart.options = getChartOptions('line');
    chart.update();
}

function updateProcessRiskChart(chart, data) {
    const processRisk = {};
    data.forEach(row => {
        const process = row.processPath || 'Unknown';
        const risk = parseFloat(row.risk || calculateRiskScore(row));
        if (!processRisk[process]) processRisk[process] = { total: 0, count: 0 };
        processRisk[process].total += risk;
        processRisk[process].count++;
    });

    const top = Object.entries(processRisk)
        .map(([p, v]) => [p, v.total / v.count])
        .sort((a, b) => b[1] - a[1])
        .slice(0, 8);

    chart.config.type = 'bar';
    chart.data = {
        labels: top.map(([p]) => p),
        datasets: [{
            label: 'Avg Risk',
            data: top.map(([, v]) => v),
            backgroundColor: AMAZON_COLORS.darkBlue
        }]
    };
    chart.options = getChartOptions('bar');
    chart.update();
}

function updateProcessHeatmapChart(chart, data) {
    const processSeverity = {};
    data.forEach(row => {
        const process = row.processPath || 'Unknown';
        const severity = row.severity || row.potential_severity || 'Unknown';
        if (!processSeverity[process]) processSeverity[process] = { A: 0, B: 0, C: 0, D: 0 };
        if (processSeverity[process][severity] !== undefined) processSeverity[process][severity]++;
    });

    const processes = Object.keys(processSeverity).slice(0, 5);
    const severities = ['A', 'B', 'C', 'D'];

    chart.config.type = 'bar';
    chart.data = {
        labels: processes,
        datasets: severities.map((s, idx) => ({
            label: `Severity ${s}`,
            data: processes.map(p => processSeverity[p][s] || 0),
            backgroundColor: getColorByIndex(idx)
        }))
    };
    chart.options = getChartOptions('bar');
    chart.options.scales.x.stacked = true;
    chart.options.scales.y.stacked = true;
    chart.update();
}

function updateRiskMatrixChart(chart, data) {
    const matrix = {};
    ['A','B','C','D'].forEach(sev => {
        ['Rare','Unlikely','Possible','Likely','Almost Certain'].forEach(lik => {
            matrix[`${sev}-${lik}`] = 0;
        });
    });

    data.forEach(row => {
        const severity = row.severity || row.potential_severity || 'Unknown';
        const likelihood = row.standardized_likelihood || row.likelihood || 'Unknown';
        const key = `${severity}-${likelihood}`;
        if (matrix[key] !== undefined) matrix[key]++;
    });

    const likelihoods = ['Rare','Unlikely','Possible','Likely','Almost Certain'];
    chart.config.type = 'bar';
    chart.data = {
        labels: likelihoods,
        datasets: ['A','B','C','D'].map((sev, idx) => ({
            label: `Severity ${sev}`,
            data: likelihoods.map(lik => matrix[`${sev}-${lik}`] || 0),
            backgroundColor: getColorByIndex(idx)
        }))
    };
    chart.options = getChartOptions('bar');
    chart.options.scales.x.stacked = true;
    chart.options.scales.y.stacked = true;
    chart.update();
}

function updateLikelihoodTrendChart(chart, data) {
    const monthlyLikelihood = {};
    data.forEach(row => {
        if (row.parsedDate && !isNaN(row.parsedDate)) {
            const monthKey = `${row.parsedDate.getFullYear()}-${String(row.parsedDate.getMonth() + 1).padStart(2, '0')}`;
            const likelihood = row.standardized_likelihood || row.likelihood || 'Unknown';
            if (!monthlyLikelihood[monthKey]) monthlyLikelihood[monthKey] = {};
            monthlyLikelihood[monthKey][likelihood] = (monthlyLikelihood[monthKey][likelihood] || 0) + 1;
        }
    });

    const months = Object.keys(monthlyLikelihood).sort().slice(-6);
    const likelihoods = [...new Set(data.map(r => r.standardized_likelihood || r.likelihood || 'Unknown'))];

    chart.config.type = 'line';
    chart.data = {
        labels: months.map(formatMonthLabel),
        datasets: likelihoods.map((lik, idx) => ({
            label: lik,
            data: months.map(m => monthlyLikelihood[m][lik] || 0),
            borderColor: getColorByIndex(idx),
            backgroundColor: `${getColorByIndex(idx)}20`,
            tension: 0.3
        }))
    };
    chart.options = getChartOptions('line');
    chart.update();
}

function updateHazardCategoriesChart(chart, data) {
    const counts = {};
    data.forEach(row => {
        const category = row.hazardCategory || row.hazard_category || 'Unknown';
        counts[category] = (counts[category] || 0) + 1;
    });

    const top = Object.entries(counts)
        .sort((a, b) => b[1] - a[1])
        .slice(0, 8);

    chart.config.type = 'doughnut';
    chart.data = {
        labels: top.map(([c]) => c),
        datasets: [{
            data: top.map(([, c]) => c),
            backgroundColor: top.map((_, i) => getColorByIndex(i))
        }]
    };
    chart.options = getChartOptions('doughnut');
    chart.update();
}

function updateMitigationStatusChart(chart, data) {
    const counts = {};
    data.forEach(row => {
        const status = row.mitigationStatus || row.mitigation_status || 'Unknown';
        counts[status] = (counts[status] || 0) + 1;
    });

    chart.config.type = 'pie';
    chart.data = {
        labels: Object.keys(counts),
        datasets: [{
            data: Object.values(counts),
            backgroundColor: Object.keys(counts).map((_, i) => getColorByIndex(i))
        }]
    };
    chart.options = getChartOptions('pie');
    chart.update();
}

function updateNearMissToInjuryRatioChart(chart, data) {
    const nearMissCount = state.nearMiss.filteredData ? state.nearMiss.filteredData.length : 0;
    const injuryCount = state.injury.filteredData ? state.injury.filteredData.length : 0;

    chart.config.type = 'bar';
    chart.data = {
        labels: ['Near Misses', 'Injuries'],
        datasets: [{
            label: 'Count',
            data: [nearMissCount, injuryCount],
            backgroundColor: [AMAZON_COLORS.orange, AMAZON_COLORS.darkBlue]
        }]
    };
    chart.options = getChartOptions('bar');
    chart.update();
}

function updatePredictiveRiskChart(chart, data) {
    updateRiskTrendChart(chart, data);
}

function updateHotspotAnalysisChart(chart, data) {
    updateLocationHeatmapChart(chart, data);
}

// Helper functions
function getWeekNumber(date) {
    const d = new Date(date);
    const year = d.getFullYear();
    const oneJan = new Date(year, 0, 1);
    const week = Math.ceil((((d - oneJan) / 86400000) + oneJan.getDay() + 1) / 7);
    return `${year}-${String(week).padStart(2, '0')}`;
}

function formatMonthLabel(monthKey) {
    const monthNames = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
    const [year, month] = monthKey.split('-');
    return `${monthNames[parseInt(month)-1]} ${year}`;
}

function getTopBodyParts(data, limit = 5) {
    const counts = {};
    data.forEach(row => {
        if (row.bodyPart) {
            counts[row.bodyPart] = (counts[row.bodyPart] || 0) + 1;
        }
    });
    return Object.entries(counts)
        .sort((a, b) => b[1] - a[1])
        .slice(0, limit)
        .map(([part]) => part);
}

function getColorByIndex(index) {
    const colors = [
        AMAZON_COLORS.orange,
        AMAZON_COLORS.darkBlue,
        '#FF5722',
        '#4CAF50',
        '#2196F3',
        '#9C27B0',
        '#FFC107',
        '#795548'
    ];
    return colors[index % colors.length];
}

// Update Overview
function updateOverview() {
    if (state.injury.rawData.length > 0 || state.nearMiss.rawData.length > 0) {
        // Hide welcome screen and show dashboards
        document.getElementById('welcomeScreen').style.display = 'none';
        document.getElementById('kpiDashboard').style.display = 'block';
        document.getElementById('overviewMetrics').style.display = 'grid';
        document.getElementById('overviewCharts').style.display = 'grid';
        // Show unified filters and populate options once
        const overviewFilters = document.getElementById('overviewFilters');
        if (overviewFilters) {
            populateOverviewFilters();
            overviewFilters.style.display = 'flex';
        }
        
        const totalIncidents = state.injury.filteredData.length + state.nearMiss.filteredData.length;
        document.getElementById('totalIncidents').textContent = totalIncidents;
        document.getElementById('injuryCount').textContent = state.injury.filteredData.length;
        document.getElementById('nearMissCount').textContent = state.nearMiss.filteredData.length;
        
        const allRisks = [
            ...state.injury.filteredData.map(r => parseFloat(calculateRiskScore(r))),
            ...state.nearMiss.filteredData.map(r => parseFloat(r.risk))
        ].filter(r => !isNaN(r));
        
        const avgRisk = allRisks.length > 0 ? 
            (allRisks.reduce((a, b) => a + b, 0) / allRisks.length).toFixed(1) : '0.0';
        document.getElementById('riskScore').textContent = avgRisk;
        
        updateKPIs();
        updateOverviewCharts();
    }
}

function updateOverviewCharts() {
    const trendChart = Chart.getChart("overviewTrendChart");
    if (trendChart) {
        const allData = [...state.injury.filteredData, ...state.nearMiss.filteredData];
        const monthlyData = {};
        
        allData.forEach(row => {
            if (row.parsedDate && !isNaN(row.parsedDate)) {
                const monthKey = `${row.parsedDate.getFullYear()}-${String(row.parsedDate.getMonth() + 1).padStart(2, '0')}`;
                if (!monthlyData[monthKey]) {
                    monthlyData[monthKey] = { injury: 0, nearMiss: 0 };
                }
                if (row.case_number) {
                    monthlyData[monthKey].injury++;
                } else {
                    monthlyData[monthKey].nearMiss++;
                }
            }
        });
        
        const sortedMonths = Object.keys(monthlyData).sort();
        const monthNames = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
        
        trendChart.data = {
            labels: sortedMonths.map(m => {
                const [year, month] = m.split('-');
                return `${monthNames[parseInt(month)-1]} ${year}`;
            }),
            datasets: [
                {
                    label: 'Injuries',
                    data: sortedMonths.map(m => monthlyData[m].injury),
                    borderColor: SEVERITY_COLORS.B,
                    backgroundColor: `${SEVERITY_COLORS.B}20`,
                    tension: 0.3
                },
                {
                    label: 'Near Misses',
                    data: sortedMonths.map(m => monthlyData[m].nearMiss),
                    borderColor: AMAZON_COLORS.orange,
                    backgroundColor: `${AMAZON_COLORS.orange}20`,
                    tension: 0.3
                }
            ]
        };
        trendChart.update();
    }
    
    const siteChart = Chart.getChart("overviewSiteChart");
    if (siteChart) {
        const siteCounts = {};
        
        state.injury.filteredData.forEach(row => {
            const site = row.site || 'Unknown';
            if (!siteCounts[site]) siteCounts[site] = { injury: 0, nearMiss: 0 };
            siteCounts[site].injury++;
        });
        
        state.nearMiss.filteredData.forEach(row => {
            const site = row.site || 'Unknown';
            if (!siteCounts[site]) siteCounts[site] = { injury: 0, nearMiss: 0 };
            siteCounts[site].nearMiss++;
        });
        
        const sites = Object.keys(siteCounts).sort();
        
        siteChart.data = {
            labels: sites,
            datasets: [
                {
                    label: 'Injuries',
                    data: sites.map(site => siteCounts[site].injury),
                    backgroundColor: SEVERITY_COLORS.B
                },
                {
                    label: 'Near Misses',
                    data: sites.map(site => siteCounts[site].nearMiss),
                    backgroundColor: AMAZON_COLORS.orange
                }
            ]
        };
        siteChart.update();
    }
}

// Risk Matrix Functions
function createRiskMatrices() {
    createRiskMatrix('injuryRiskMatrixGrid');
    createRiskMatrix('nearMissRiskMatrixGrid');
    createRiskMatrix('combinedRiskMatrix');
}

function createRiskMatrix(elementId) {
    const matrix = document.getElementById(elementId);
    if (!matrix) return;
    
    matrix.innerHTML = '';
    
    const severityLabels = ['', 'A', 'B', 'C', 'D'];
    const likelihoodLabels = ['', 'Rare', 'Unlikely', 'Possible', 'Likely', 'Almost Certain'];
    
    for (let s = 0; s < 6; s++) {
        for (let l = 0; l < 6; l++) {
            const cell = document.createElement('div');
            
            if (s === 0 && l === 0) {
                cell.className = 'matrix-label';
                cell.textContent = 'S/L';
            } else if (s === 0) {
                cell.className = 'matrix-label';
                cell.textContent = likelihoodLabels[l];
            } else if (l === 0) {
                cell.className = 'matrix-label';
                cell.textContent = severityLabels[s];
            } else {
                const risk = (5 - s) * l;
                let riskClass = 'risk-low';
                if (risk > 15) riskClass = 'risk-critical';
                else if (risk > 10) riskClass = 'risk-high';
                else if (risk > 5) riskClass = 'risk-medium';
                
                cell.className = `matrix-cell ${riskClass}`;
                cell.textContent = '0';
                cell.id = `${elementId}-${severityLabels[s]}-${likelihoodLabels[l]}`;
                cell.onclick = () => showMatrixDetails(severityLabels[s], likelihoodLabels[l], elementId);
            }
            
            matrix.appendChild(cell);
        }
    }
}

function updateInjuryRiskMatrix() {
    updateRiskMatrix(state.injury.filteredData, 'injuryRiskMatrixGrid');
}

function updateNearMissRiskMatrix() {
    updateRiskMatrix(state.nearMiss.filteredData, 'nearMissRiskMatrixGrid');
}

function updateRiskMatrix(data, matrixId) {
    const severityLabels = ['A', 'B', 'C', 'D'];
    const likelihoodLabels = ['Rare', 'Unlikely', 'Possible', 'Likely', 'Almost Certain'];
    
    severityLabels.forEach(severity => {
        likelihoodLabels.forEach(likelihood => {
            const cell = document.getElementById(`${matrixId}-${severity}-${likelihood}`);
            if (cell) {
                cell.textContent = '0';
                cell.style.fontWeight = 'normal';
            }
        });
    });
    
    const matrixCounts = {};
    
    data.forEach(incident => {
        const severity = incident.severity;
        const likelihood = incident.standardized_likelihood || 'Possible';
        
        if (['A', 'B', 'C', 'D'].includes(severity)) {
            const key = `${severity}-${likelihood}`;
            matrixCounts[key] = (matrixCounts[key] || 0) + 1;
        }
    });
    
    Object.entries(matrixCounts).forEach(([key, count]) => {
        const [severity, likelihood] = key.split('-');
        const cell = document.getElementById(`${matrixId}-${severity}-${likelihood}`);
        if (cell) {
            cell.textContent = count.toString();
            if (count > 0) {
                cell.style.fontWeight = 'bold';
                cell.style.fontSize = '1.1rem';
            }
        }
    });
}

function showMatrixDetails(severity, likelihood, matrixId) {
    let data;
    let type;
    
    if (matrixId.includes('injury')) {
        data = state.injury.filteredData;
        type = 'Injury';
    } else if (matrixId.includes('nearMiss')) {
        data = state.nearMiss.filteredData;
        type = 'Near Miss';
    } else {
        data = [...state.injury.filteredData, ...state.nearMiss.filteredData];
        type = 'Combined';
    }
    
    const incidents = data.filter(r => 
        r.severity === severity && 
        r.standardized_likelihood === likelihood
    );
    
    if (incidents.length === 0) {
        showStatus(`No ${type.toLowerCase()} incidents found with Severity ${severity} and Likelihood ${likelihood}`, 'info');
        return;
    }
    
    const modal = document.getElementById('detailModal');
    const title = document.getElementById('modalTitle');
    const body = document.getElementById('modalBody');
    
    title.textContent = `${type} Incidents: Severity ${severity}, ${likelihood}`;
    body.innerHTML = `
        <p style="margin-bottom: 1rem;">Total incidents: ${incidents.length}</p>
        <div style="max-height: 400px; overflow-y: auto;">
            ${incidents.map(incident => `
                <div style="padding: 1rem; border-bottom: 1px solid var(--bg-secondary);">
                    <strong>${incident.case_number || incident.incident_id}</strong><br>
                    <span style="color: var(--text-secondary);">
                        Date: ${incident.incident_date || incident.nearmiss_date || 'N/A'}<br>
                        Site: ${incident.site || 'N/A'}<br>
                        ${incident.bodyPart ? `Body Part: ${incident.bodyPart}<br>` : ''}
                        ${incident.location ? `Location: ${incident.location}<br>` : ''}
                        ${incident.processPath ? `Process: ${incident.processPath}<br>` : ''}
                    </span>
                    ${incident.austin_url && incident.austin_url !== '#' ? `<a href="${incident.austin_url}" target="_blank" class="austin-link" style="margin-top:0.5rem; display:inline-block;">Austin Link</a>` : ''}
                </div>
            `).join('')}
        </div>
    `;
    
    modal.style.display = 'block';
}

function showDuplicateDetails(groupIndex, type) {
    const metrics = type === 'nearmiss' ? state.nearMiss.qualityMetrics : state.injury.qualityMetrics;
    const group = metrics.duplicateDetails[groupIndex];
    if (!group) return;

    const source = type === 'nearmiss' ? state.nearMiss.rawData : state.injury.rawData;
    const records = group.indices.map(i => source[i]);

    const modal = document.getElementById('detailModal');
    const title = document.getElementById('modalTitle');
    const body = document.getElementById('modalBody');

    title.textContent = `Duplicate Records (${group.indices.length})`;
    body.innerHTML = `
        <p style="margin-bottom:1rem;">${group.data.date || 'No date'} ‚Äì ${group.data.site} ‚Äì ${group.data.location}</p>
        <div style="max-height:400px; overflow-y:auto;">
            ${records.map((rec, idx) => `
                <div style="padding:1rem; border-bottom:1px solid var(--bg-secondary);">
                    <strong>${rec.case_number || rec.incident_id || 'Row #' + (group.indices[idx] + 1)}</strong><br>
                    <span style="color: var(--text-secondary);">
                        Date: ${rec.incident_date || rec.nearmiss_date || 'N/A'}<br>
                        Site: ${rec.site || 'N/A'}<br>
                        ${rec.bodyPart ? `Body Part: ${rec.bodyPart}<br>` : ''}
        ${rec.location ? `Location: ${rec.location}<br>` : ''}
                    </span>
                    ${rec.austin_url && rec.austin_url !== '#' ? `<a href="${rec.austin_url}" target="_blank" class="austin-link" style="margin-top:0.5rem; display:inline-block;">Austin Link</a>` : ''}
                </div>
            `).join('')}
        </div>
        <button class="btn btn-primary" style="margin-top:1rem;" onclick="mergeDuplicateGroup(${groupIndex}, '${type}')">Merge Duplicates</button>
    `;
    modal.style.display = 'block';
}

function mergeDuplicateGroup(groupIndex, type) {
    const metrics = type === 'nearmiss' ? state.nearMiss.qualityMetrics : state.injury.qualityMetrics;
    const group = metrics.duplicateDetails[groupIndex];
    if (!group) return;
    const source = type === 'nearmiss' ? state.nearMiss.rawData : state.injury.rawData;
    group.indices.slice(1).sort((a,b) => b - a).forEach(i => source.splice(i, 1));
    calculateQualityMetrics(type);
    applyFilters(type);
    showStatus('Merged duplicate records', 'success');
    closeModal();
}

function showAllDuplicates(type) {
    const metrics = type === 'nearmiss' ? state.nearMiss.qualityMetrics : state.injury.qualityMetrics;
    if (!metrics.duplicateDetails.length) return;

    const modal = document.getElementById('detailModal');
    const title = document.getElementById('modalTitle');
    const body = document.getElementById('modalBody');

    title.textContent = 'All Duplicate Groups';
    body.innerHTML = `
        <div style="max-height:400px; overflow-y:auto;">
            ${metrics.duplicateDetails.map((dup, index) => `
                <div style="padding:1rem; border-bottom:1px solid var(--bg-secondary);">
                    <strong>Group ${index + 1}</strong><br>
                    <span style="color: var(--text-secondary);">
                        Date: ${dup.data.date || 'No date'}<br>
                        Site: ${dup.data.site}<br>
                        ${dup.data.location ? `Location: ${dup.data.location}<br>` : ''}
                    </span>
                    <div>Rows: ${dup.indices.map(i => `#${i + 1}`).join(', ')}</div>
                    <button class="btn btn-sm btn-primary" style="margin-top:0.5rem;" onclick="showDuplicateDetails(${index}, '${type}')">Review & Merge</button>
                </div>
            `).join('')}
        </div>
    `;
    modal.style.display = 'block';
}

// Timeline Functions
function updateInjuryTimeline() {
    const timelineContent = document.getElementById('injuryTimelineContent');
    const data = state.injury.filteredData
        .filter(r => r.parsedDate)
        .sort((a, b) => b.parsedDate - a.parsedDate);
    
    const currentPage = state.injury.timelinePage;
    const startIndex = (currentPage - 1) * 10;
    const endIndex = Math.min(startIndex + 10, data.length);
    const pageData = data.slice(startIndex, endIndex);
    
    if (pageData.length === 0) {
        timelineContent.innerHTML = '<p style="text-align: center; padding: 2rem;">No incidents to display.</p>';
        return;
    }
    
    timelineContent.innerHTML = pageData.map(incident => {
        const austinUrl = incident.austin_url && incident.austin_url !== '#' ? incident.austin_url : null;
        
        return `
            <div class="timeline-item">
                <div class="timeline-date">${incident.incident_date || 'N/A'}</div>
                <div class="timeline-content">
                    <h4>${incident.case_number}</h4>
                    <p><strong>Site:</strong> ${incident.site || 'N/A'}</p>
                    <p><strong>Body Part:</strong> ${incident.bodyPart || 'N/A'}</p>
                    <p><strong>Severity:</strong> <span class="badge badge-${getSeverityClass(incident.severity)}">${incident.severity}</span></p>
                    <p><strong>Recordable:</strong> <span class="badge badge-${incident.recordable === 1 ? 'danger' : 'success'}">${incident.recordable === 1 ? 'Yes' : 'No'}</span></p>
                    <p><strong>Description:</strong> ${incident.initial_info_incident_description || 'No description'}</p>
                    ${austinUrl ? `<a href="${austinUrl}" target="_blank" class="austin-link">Austin Link</a>` : ''}
                </div>
            </div>
        `;
    }).join('');
    
    const totalPages = Math.ceil(data.length / 10);
    const pageInfo = document.getElementById('injuryTimelinePageInfo');
    if (pageInfo) pageInfo.textContent = `Page ${currentPage} of ${totalPages || 1}`;
}

function updateNearMissTimeline() {
    const timelineContent = document.getElementById('nearMissTimelineContent');
    const data = state.nearMiss.filteredData
        .filter(r => r.parsedDate)
        .sort((a, b) => b.parsedDate - a.parsedDate);
    
    const currentPage = state.nearMiss.timelinePage;
    const startIndex = (currentPage - 1) * 10;
    const endIndex = Math.min(startIndex + 10, data.length);
    const pageData = data.slice(startIndex, endIndex);
    
    if (pageData.length === 0) {
        timelineContent.innerHTML = '<p style="text-align: center; padding: 2rem;">No near misses to display.</p>';
        return;
    }
    
    timelineContent.innerHTML = pageData.map(incident => {
        const austinUrl = incident.austin_url && incident.austin_url !== '#' ? incident.austin_url : null;

        return `
        <div class="timeline-item">
            <div class="timeline-date">${incident.nearmiss_date || 'N/A'}</div>
            <div class="timeline-content">
                <h4>${incident.incident_id}</h4>
                <p><strong>Site:</strong> ${incident.site || 'N/A'}</p>
                <p><strong>Location:</strong> ${incident.location || 'N/A'}</p>
                <p><strong>Process:</strong> ${incident.processPath || 'N/A'}</p>
                <p><strong>Severity:</strong> <span class="badge badge-${getSeverityClass(incident.severity)}">${incident.severity}</span></p>
                <p><strong>Risk Score:</strong> <span class="badge badge-${getRiskClass(incident.risk)}">${incident.risk}</span></p>
                <p><strong>Description:</strong> ${incident.initial_info_incident_description || 'No description'}</p>
                ${austinUrl ? `<a href="${austinUrl}" target="_blank" class="austin-link">Austin Link</a>` : ''}
            </div>
        </div>
        `;
    }).join('');
    
    const totalPages = Math.ceil(data.length / 10);
    const pageInfo = document.getElementById('nearMissTimelinePageInfo');
    if (pageInfo) pageInfo.textContent = `Page ${currentPage} of ${totalPages || 1}`;
}

function changeTimelinePage(type, direction) {
    const data = type === 'injury' ? 
        state.injury.filteredData.filter(r => r.parsedDate) : 
        state.nearMiss.filteredData.filter(r => r.parsedDate);
    
    const totalPages = Math.ceil(data.length / 10);
    
    if (type === 'injury') {
        state.injury.timelinePage += direction;
        if (state.injury.timelinePage < 1) state.injury.timelinePage = 1;
        if (state.injury.timelinePage > totalPages) state.injury.timelinePage = totalPages;
        updateInjuryTimeline();
    } else {
        state.nearMiss.timelinePage += direction;
        if (state.nearMiss.timelinePage < 1) state.nearMiss.timelinePage = 1;
        if (state.nearMiss.timelinePage > totalPages) state.nearMiss.timelinePage = totalPages;
        updateNearMissTimeline();
    }
}

// Advanced Analytics
function updateInjuryAdvancedAnalytics() {
    const recordableRateChart = state.injury.charts.injuryRecordableRateTrendChart;
    if (recordableRateChart) {
        const monthlyRates = {};
        const monthlyTotals = {};
        
        state.injury.filteredData.forEach(row => {
            if (row.parsedDate && !isNaN(row.parsedDate)) {
                const monthKey = `${row.parsedDate.getFullYear()}-${String(row.parsedDate.getMonth() + 1).padStart(2, '0')}`;
                if (!monthlyTotals[monthKey]) {
                    monthlyTotals[monthKey] = 0;
                    monthlyRates[monthKey] = 0;
                }
                monthlyTotals[monthKey]++;
                if (row.recordable === 1) {
                    monthlyRates[monthKey]++;
                }
            }
        });
        
        const sortedMonths = Object.keys(monthlyTotals).sort();
        const monthNames = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
        
        recordableRateChart.data = {
            labels: sortedMonths.map(m => {
                const [year, month] = m.split('-');
                return `${monthNames[parseInt(month)-1]} ${year}`;
            }),
            datasets: [{
                label: 'Recordable Rate %',
                data: sortedMonths.map(m => 
                    monthlyTotals[m] > 0 ? ((monthlyRates[m] / monthlyTotals[m]) * 100).toFixed(1) : 0
                ),
                borderColor: SEVERITY_COLORS.B,
                backgroundColor: `${SEVERITY_COLORS.B}20`,
                tension: 0.3
            }]
        };
        recordableRateChart.update();
    }
    
    const bodyPartHeatMapChart = state.injury.charts.injuryBodyPartHeatMapChart;
    if (bodyPartHeatMapChart) {
        updateBodyPartHeatmapChart(bodyPartHeatMapChart, state.injury.filteredData);
    }
    
    const rootCauseBySiteChart = state.injury.charts.injuryRootCauseBySiteChart;
    if (rootCauseBySiteChart) {
        const siteRootCause = {};
        state.injury.filteredData.forEach(row => {
            const site = row.site || 'Unknown';
            const cause = row.rootCause || 'Unknown';
            if (!siteRootCause[site]) {
                siteRootCause[site] = {};
            }
            siteRootCause[site][cause] = (siteRootCause[site][cause] || 0) + 1;
        });
        
        const sites = Object.keys(siteRootCause).sort();
        const allCauses = [...new Set(state.injury.filteredData.map(r => r.rootCause || 'Unknown'))];
        
        rootCauseBySiteChart.config.type = 'bar';
        rootCauseBySiteChart.data = {
            labels: sites,
            datasets: allCauses.slice(0, 5).map((cause, index) => ({
                label: cause,
                data: sites.map(site => siteRootCause[site][cause] || 0),
                backgroundColor: [
                    AMAZON_COLORS.orange,
                    AMAZON_COLORS.darkBlue,
                    AMAZON_COLORS.lightBlue,
                    '#FF5722',
                    '#4CAF50'
                ][index]
            }))
        };
        rootCauseBySiteChart.options = getChartOptions('bar');
        rootCauseBySiteChart.options.scales.x.stacked = true;
        rootCauseBySiteChart.options.scales.y.stacked = true;
        rootCauseBySiteChart.update();
    }
    
    const dafwDistributionChart = state.injury.charts.injuryDAFWDistributionChart;
    if (dafwDistributionChart) {
        const dafwRanges = {
            '0 Days': 0,
            '1-3 Days': 0,
            '4-7 Days': 0,
            '8-14 Days': 0,
            '15-30 Days': 0,
            '30+ Days': 0
        };
        
        state.injury.filteredData.forEach(row => {
            const days = row.total_dafw_days || 0;
            if (days === 0) dafwRanges['0 Days']++;
            else if (days <= 3) dafwRanges['1-3 Days']++;
            else if (days <= 7) dafwRanges['4-7 Days']++;
            else if (days <= 14) dafwRanges['8-14 Days']++;
            else if (days <= 30) dafwRanges['15-30 Days']++;
            else dafwRanges['30+ Days']++;
        });
        
        dafwDistributionChart.config.type = 'doughnut';
        dafwDistributionChart.data = {
            labels: Object.keys(dafwRanges),
            datasets: [{
                data: Object.values(dafwRanges),
                backgroundColor: [
                    SEVERITY_COLORS.D,
                    SEVERITY_COLORS.C,
                    AMAZON_COLORS.orange,
                    SEVERITY_COLORS.B,
                    SEVERITY_COLORS.A,
                    AMAZON_COLORS.darkBlue
                ],
                label: 'Cases'
            }]
        };
        dafwDistributionChart.options = getChartOptions('doughnut');
        dafwDistributionChart.update();
    }
}

function updateNearMissAdvancedAnalytics() {
    const riskTrendChart = state.nearMiss.charts.nearMissRiskTrendChart;
    if (riskTrendChart) {
        updateRiskTrendChart(riskTrendChart, state.nearMiss.filteredData);
    }
    
    const impactAnalysisChart = state.nearMiss.charts.nearMissImpactAnalysisChart;
    if (impactAnalysisChart) {
        const impactSeverity = {};
        state.nearMiss.filteredData.forEach(row => {
            const impact = row.primaryImpact || 'Unknown';
            if (!impactSeverity[impact]) {
                impactSeverity[impact] = { A: 0, B: 0, C: 0, D: 0 };
            }
            if (row.severity && impactSeverity[impact][row.severity] !== undefined) {
                impactSeverity[impact][row.severity]++;
            }
        });
        
        const topImpacts = Object.entries(impactSeverity)
            .map(([impact, severities]) => ({
                impact,
                total: Object.values(severities).reduce((a, b) => a + b, 0),
                severities
            }))
            .sort((a, b) => b.total - a.total)
            .slice(0, 8);
        
        impactAnalysisChart.config.type = 'bar';
        impactAnalysisChart.data = {
            labels: topImpacts.map(i => i.impact),
            datasets: [
                {
                    label: 'Severity A',
                    data: topImpacts.map(i => i.severities.A),
                    backgroundColor: SEVERITY_COLORS.A
                },
                {
                    label: 'Severity B',
                    data: topImpacts.map(i => i.severities.B),
                    backgroundColor: SEVERITY_COLORS.B
                },
                {
                    label: 'Severity C',
                    data: topImpacts.map(i => i.severities.C),
                    backgroundColor: SEVERITY_COLORS.C
                },
                {
                    label: 'Severity D',
                    data: topImpacts.map(i => i.severities.D),
                    backgroundColor: SEVERITY_COLORS.D
                }
            ]
        };
        impactAnalysisChart.options = getChartOptions('bar');
        impactAnalysisChart.options.scales.x.stacked = true;
        impactAnalysisChart.options.scales.y.stacked = true;
        impactAnalysisChart.update();
    }
    
    const locationRiskChart = state.nearMiss.charts.nearMissLocationRiskChart;
    if (locationRiskChart) {
        updateLocationHeatmapChart(locationRiskChart, state.nearMiss.filteredData);
    }
    
    const processRiskChart = state.nearMiss.charts.nearMissProcessRiskChart;
    if (processRiskChart) {
        const processRisk = {};
        state.nearMiss.filteredData.forEach(row => {
            const process = row.processPath || 'Unknown';
            if (!processRisk[process]) {
                processRisk[process] = { total: 0, highRisk: 0 };
            }
            processRisk[process].total++;
            const risk = parseFloat(row.risk || calculateRiskScore(row));
            if (risk >= 7) {
                processRisk[process].highRisk++;
            }
        });
        
        const topProcesses = Object.entries(processRisk)
            .map(([process, data]) => ({
                process,
                riskRate: data.total > 0 ? ((data.highRisk / data.total) * 100).toFixed(1) : 0
            }))
            .sort((a, b) => b.riskRate - a.riskRate)
            .slice(0, 10);
        
        processRiskChart.config.type = 'bar';
        processRiskChart.data = {
            labels: topProcesses.map(p => p.process),
            datasets: [{
                label: 'High Risk Rate %',
                data: topProcesses.map(p => parseFloat(p.riskRate)),
                backgroundColor: SEVERITY_COLORS.B,
                borderWidth: 1
            }]
        };
        processRiskChart.options = getChartOptions('bar');
        processRiskChart.update();
    }
}

// Combined Analytics
function updateCombinedAnalytics() {
    // If no data is loaded yet simply return; nothing to update
    if (state.injury.rawData.length === 0 && state.nearMiss.rawData.length === 0) {
        return;
    }

    // Show and populate the combined filter bar the first time data is loaded.
    const combinedFilters = document.getElementById('combinedFilters');
    if (combinedFilters) {
        populateCombinedFilters();
        combinedFilters.style.display = 'flex';
    }
    
    const totalEvents = state.injury.filteredData.length + state.nearMiss.filteredData.length;
    document.getElementById('combinedTotal').textContent = totalEvents;
    
    const highRiskEvents = [
        ...state.injury.filteredData.filter(r => r.severity === 'A' || r.severity === 'B'),
        ...state.nearMiss.filteredData.filter(r => r.severity === 'A' || r.severity === 'B')
    ].length;
    document.getElementById('combinedHighRisk').textContent = highRiskEvents;
    
    const currentMonth = new Date().getMonth();
    const lastMonth = currentMonth - 1;
    const currentMonthEvents = [...state.injury.filteredData, ...state.nearMiss.filteredData]
        .filter(r => r.parsedDate && r.parsedDate.getMonth() === currentMonth).length;
    const lastMonthEvents = [...state.injury.filteredData, ...state.nearMiss.filteredData]
        .filter(r => r.parsedDate && r.parsedDate.getMonth() === lastMonth).length;
    
    const trend = lastMonthEvents > 0 ? 
        ((currentMonthEvents - lastMonthEvents) / lastMonthEvents * 100).toFixed(0) : '0';
    document.getElementById('combinedTrend').textContent = `${trend > 0 ? '+' : ''}${trend}%`;
    
    const siteCounts = {};
    [...state.injury.filteredData, ...state.nearMiss.filteredData].forEach(row => {
        const site = row.site || 'Unknown';
        siteCounts[site] = (siteCounts[site] || 0) + 1;
    });
    const targetSites = Object.values(siteCounts).filter(count => count > 5).length;
    document.getElementById('combinedTargetSites').textContent = targetSites;
    
    updateCombinedRiskMatrix();
    updateCombinedCharts();
    updateCombinedInsights();
}

function updateCombinedRiskMatrix() {
    const allData = [...state.injury.filteredData, ...state.nearMiss.filteredData];
    updateRiskMatrix(allData, 'combinedRiskMatrix');
}

function updateCombinedCharts() {
    const trendChart = Chart.getChart('combinedTrendChart');
    if (trendChart) {
        const monthlyData = {};
        
        [...state.injury.filteredData, ...state.nearMiss.filteredData].forEach(row => {
            if (row.parsedDate && !isNaN(row.parsedDate)) {
                const monthKey = `${row.parsedDate.getFullYear()}-${String(row.parsedDate.getMonth() + 1).padStart(2, '0')}`;
                if (!monthlyData[monthKey]) {
                    monthlyData[monthKey] = { injury: 0, nearMiss: 0, total: 0 };
                }
                monthlyData[monthKey].total++;
                if (row.case_number) {
                    monthlyData[monthKey].injury++;
                } else {
                    monthlyData[monthKey].nearMiss++;
                }
            }
        });
        
        const sortedMonths = Object.keys(monthlyData).sort();
        const monthNames = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
        
        trendChart.data = {
            labels: sortedMonths.map(m => {
                const [year, month] = m.split('-');
                return `${monthNames[parseInt(month)-1]} ${year}`;
            }),
            datasets: [
                {
                    label: 'Total Events',
                    data: sortedMonths.map(m => monthlyData[m].total),
                    borderColor: AMAZON_COLORS.orange,
                    backgroundColor: `${AMAZON_COLORS.orange}20`,
                    tension: 0.3
                },
                {
                    label: 'Injuries',
                    data: sortedMonths.map(m => monthlyData[m].injury),
                    borderColor: SEVERITY_COLORS.B,
                    backgroundColor: `${SEVERITY_COLORS.B}20`,
                    tension: 0.3
                },
                {
                    label: 'Near Misses',
                    data: sortedMonths.map(m => monthlyData[m].nearMiss),
                    borderColor: AMAZON_COLORS.darkBlue,
                    backgroundColor: `${AMAZON_COLORS.darkBlue}20`,
                    tension: 0.3
                }
            ]
        };
        trendChart.update();
    }
    
    const siteChart = Chart.getChart('combinedSiteChart');
    if (siteChart) {
        const siteData = {};
        
        state.injury.filteredData.forEach(row => {
            const site = row.site || 'Unknown';
            if (!siteData[site]) {
                siteData[site] = { injury: 0, nearMiss: 0, highSeverity: 0 };
            }
            siteData[site].injury++;
            if (row.severity === 'A' || row.severity === 'B') {
                siteData[site].highSeverity++;
            }
        });
        
        state.nearMiss.filteredData.forEach(row => {
            const site = row.site || 'Unknown';
            if (!siteData[site]) {
                siteData[site] = { injury: 0, nearMiss: 0, highSeverity: 0 };
            }
            siteData[site].nearMiss++;
            if (row.severity === 'A' || row.severity === 'B') {
                siteData[site].highSeverity++;
            }
        });
        
        const sites = Object.entries(siteData)
            .sort((a, b) => (b[1].injury + b[1].nearMiss) - (a[1].injury + a[1].nearMiss))
            .slice(0, 10);
        
        siteChart.config.type = 'bar';
        siteChart.data = {
            labels: sites.map(([site]) => site),
            datasets: [
                {
                    label: 'Injuries',
                    data: sites.map(([, data]) => data.injury),
                    backgroundColor: SEVERITY_COLORS.B
                },
                {
                    label: 'Near Misses',
                    data: sites.map(([, data]) => data.nearMiss),
                    backgroundColor: AMAZON_COLORS.orange
                },
                {
                    label: 'High Severity',
                    data: sites.map(([, data]) => data.highSeverity),
                    backgroundColor: SEVERITY_COLORS.A
                }
            ]
        };
        siteChart.options = getChartOptions('bar');
        siteChart.update();
    }
    
    const severityChart = Chart.getChart('combinedSeverityChart');
    if (severityChart) {
        const severityData = {
            injury: { A: 0, B: 0, C: 0, D: 0 },
            nearMiss: { A: 0, B: 0, C: 0, D: 0 }
        };
        
        state.injury.filteredData.forEach(row => {
            if (row.severity && severityData.injury[row.severity] !== undefined) {
                severityData.injury[row.severity]++;
            }
        });
        
        state.nearMiss.filteredData.forEach(row => {
            if (row.severity && severityData.nearMiss[row.severity] !== undefined) {
                severityData.nearMiss[row.severity]++;
            }
        });
        
        severityChart.config.type = 'bar';
        severityChart.data = {
            labels: ['Severity A', 'Severity B', 'Severity C', 'Severity D'],
            datasets: [
                {
                    label: 'Injuries',
                    data: ['A', 'B', 'C', 'D'].map(s => severityData.injury[s]),
                    backgroundColor: SEVERITY_COLORS.B
                },
                {
                    label: 'Near Misses',
                    data: ['A', 'B', 'C', 'D'].map(s => severityData.nearMiss[s]),
                    backgroundColor: AMAZON_COLORS.orange
                }
            ]
        };
        severityChart.options = getChartOptions('bar');
        severityChart.update();
    }
    
    const preventionChart = Chart.getChart('combinedPreventionChart');
    if (preventionChart) {
        const monthlyPrevention = {};
        
        [...state.injury.filteredData, ...state.nearMiss.filteredData].forEach(row => {
            if (row.parsedDate && !isNaN(row.parsedDate)) {
                const monthKey = `${row.parsedDate.getFullYear()}-${String(row.parsedDate.getMonth() + 1).padStart(2, '0')}`;
                if (!monthlyPrevention[monthKey]) {
                    monthlyPrevention[monthKey] = { injury: 0, nearMiss: 0 };
                }
                if (row.case_number) {
                    monthlyPrevention[monthKey].injury++;
                } else {
                    monthlyPrevention[monthKey].nearMiss++;
                }
            }
        });
        
        const sortedMonths = Object.keys(monthlyPrevention).sort();
        const monthNames = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
        
        preventionChart.config.type = 'line';
        preventionChart.data = {
            labels: sortedMonths.map(m => {
                const [year, month] = m.split('-');
                return `${monthNames[parseInt(month)-1]} ${year}`;
            }),
            datasets: [{
                label: 'Prevention Ratio (Near Miss / Injury)',
                data: sortedMonths.map(m => {
                    const data = monthlyPrevention[m];
                    return data.injury > 0 ? (data.nearMiss / data.injury).toFixed(1) : data.nearMiss;
                }),
                borderColor: AMAZON_COLORS.orange,
                backgroundColor: `${AMAZON_COLORS.orange}20`,
                tension: 0.3
            }]
        };
        preventionChart.options = getChartOptions('line');
        preventionChart.update();
    }
}

function updateCombinedInsights() {
    const insightsContainer = document.getElementById('combinedInsights');
    
    const insights = [];
    
    const injuryCount = state.injury.filteredData.length;
    const nearMissCount = state.nearMiss.filteredData.length;
    const ratio = injuryCount > 0 ? (nearMissCount / injuryCount).toFixed(1) : nearMissCount;
    
    insights.push({
        type: ratio > 10 ? 'positive' : ratio > 5 ? 'neutral' : 'negative',
        title: 'Near Miss to Injury Ratio',
        content: `Current ratio is ${ratio}:1. ${ratio > 10 ? 'Excellent' : ratio > 5 ? 'Good' : 'Needs improvement'} - higher ratios indicate better hazard identification before injuries occur.`
    });
    
    const commonBodyParts = {};
    const commonLocations = {};
    
    state.injury.filteredData.forEach(row => {
        if (row.bodyPart) commonBodyParts[row.bodyPart] = (commonBodyParts[row.bodyPart] || 0) + 1;
    });
    
    state.nearMiss.filteredData.forEach(row => {
        if (row.location) commonLocations[row.location] = (commonLocations[row.location] || 0) + 1;
    });
    
    const topBodyPart = Object.entries(commonBodyParts).sort((a, b) => b[1] - a[1])[0];
    const topLocation = Object.entries(commonLocations).sort((a, b) => b[1] - a[1])[0];
    
    if (topBodyPart) {
        insights.push({
            type: 'warning',
            title: 'Most Affected Body Part',
            content: `"${topBodyPart[0]}" accounts for ${topBodyPart[1]} injuries. Consider targeted ergonomic improvements or PPE enhancements.`
        });
    }
    
    if (topLocation) {
        insights.push({
            type: 'warning',
            title: 'High-Risk Location',
            content: `"${topLocation[0]}" has ${topLocation[1]} near miss reports. This location requires immediate safety assessment.`
        });
    }
    
    const highSeverityInjuries = state.injury.filteredData.filter(r => r.severity === 'A' || r.severity === 'B').length;
    const highSeverityNearMisses = state.nearMiss.filteredData.filter(r => r.severity === 'A' || r.severity === 'B').length;
    
    if (highSeverityNearMisses > highSeverityInjuries * 2) {
        insights.push({
            type: 'critical',
            title: 'High Severity Risk',
            content: `${highSeverityNearMisses} high-severity near misses detected. This indicates potential for serious injuries if not addressed immediately.`
        });
    }
    
    insightsContainer.innerHTML = insights.map(insight => `
        <div style="padding: 1rem; margin-bottom: 1rem; background: ${
            insight.type === 'positive' ? 'rgba(76, 175, 80, 0.1)' :
            insight.type === 'warning' ? 'rgba(255, 193, 7, 0.1)' :
            insight.type === 'critical' ? 'rgba(255, 87, 34, 0.1)' :
            'rgba(33, 150, 243, 0.1)'
        }; border-radius: 8px; border-left: 4px solid ${
            insight.type === 'positive' ? '#4CAF50' :
            insight.type === 'warning' ? '#FFC107' :
            insight.type === 'critical' ? '#FF5722' :
            '#2196F3'
        };">
            <h4 style="margin-bottom: 0.5rem;">${insight.title}</h4>
            <p style="margin: 0;">${insight.content}</p>
        </div>
    `).join('');
}

// Action Items
function updateActionItems() {
    const allData = [...state.injury.filteredData, ...state.nearMiss.filteredData];
    
    if (allData.length === 0) return;
    
    const actions = generateActionItems(allData);
    
    const immediateContainer = document.getElementById('immediateActions');
    immediateContainer.innerHTML = actions.immediate.map(action => `
        <li class="action-item">
            <span class="action-icon immediate">!</span>
            <div style="flex: 1;">
                <strong>${action.title}</strong>
                <p style="font-size: 0.9rem; color: var(--text-secondary); margin-top: 0.25rem;">
                    ${action.description}
                </p>
            </div>
            <button class="btn btn-sm btn-outline" onclick="markActionComplete('immediate', '${action.id}')">
                Mark Complete
            </button>
        </li>
    `).join('');
    
    const shortTermContainer = document.getElementById('shortTermActions');
    shortTermContainer.innerHTML = actions.shortTerm.map(action => `
        <li class="action-item">
            <span class="action-icon short-term">üìÖ</span>
            <div style="flex: 1;">
                <strong>${action.title}</strong>
                <p style="font-size: 0.9rem; color: var(--text-secondary); margin-top: 0.25rem;">
                    ${action.description}
                </p>
            </div>
            <button class="btn btn-sm btn-outline" onclick="markActionComplete('shortTerm', '${action.id}')">
                Mark Complete
            </button>
        </li>
    `).join('');
    
    const longTermContainer = document.getElementById('longTermActions');
    longTermContainer.innerHTML = actions.longTerm.map(action => `
        <li class="action-item">
            <span class="action-icon long-term">üîÑ</span>
            <div style="flex: 1;">
                <strong>${action.title}</strong>
                <p style="font-size: 0.9rem; color: var(--text-secondary); margin-top: 0.25rem;">
                    ${action.description}
                </p>
            </div>
            <button class="btn btn-sm btn-outline" onclick="markActionComplete('longTerm', '${action.id}')">
                Mark Complete
            </button>
        </li>
    `).join('');
}

function generateActionItems(data) {
    const actions = {
        immediate: [],
        shortTerm: [],
        longTerm: []
    };
    
    const highSeverityCount = data.filter(r => r.severity === 'A' || r.severity === 'B').length;
    const recordableCount = state.injury.filteredData.filter(r => r.recordable === 1).length;
    const otrCount = state.injury.filteredData.filter(r => r.otr === 'yes').length;
    
    if (highSeverityCount > 5) {
        actions.immediate.push({
            id: 'imm-1',
            title: `Address ${highSeverityCount} high-severity incidents`,
            description: 'Conduct immediate safety stand-down and review all A & B severity cases'
        });
    }
    
    if (recordableCount > 3) {
        actions.immediate.push({
            id: 'imm-2',
            title: `Review ${recordableCount} recordable cases`,
            description: 'Ensure all OSHA reporting requirements are met and root causes are identified'
        });
    }
    
    if (otrCount > 2) {
        actions.immediate.push({
            id: 'imm-3',
            title: `Investigate ${otrCount} OTR incidents`,
            description: 'Review driver safety protocols and implement immediate corrective actions'
        });
    }
    
    const locationCounts = {};
    data.forEach(row => {
        const location = row.location || row.initial_info_location_event || 'Unknown';
        locationCounts[location] = (locationCounts[location] || 0) + 1;
    });
    
    Object.entries(locationCounts)
        .sort((a, b) => b[1] - a[1])
        .slice(0, 3)
        .forEach(([location, count], index) => {
            if (count > 5) {
                actions.shortTerm.push({
                    id: `st-${index + 1}`,
                    title: `Safety audit at ${location}`,
                    description: `${count} incidents reported. Conduct comprehensive safety assessment within 30 days`
                });
            }
        });
    
    const processCounts = {};
    data.forEach(row => {
        const process = row.processPath || row.initial_info_process_path || 'Unknown';
        processCounts[process] = (processCounts[process] || 0) + 1;
    });
    
    Object.entries(processCounts)
        .sort((a, b) => b[1] - a[1])
        .slice(0, 2)
        .forEach(([process, count], index) => {
            if (count > 3) {
                actions.shortTerm.push({
                    id: `st-p-${index + 1}`,
                    title: `Review ${process} process`,
                    description: `${count} incidents in this process. Update SOPs and conduct training`
                });
            }
        });
    
    actions.longTerm.push({
        id: 'lt-1',
        title: 'Implement predictive analytics',
        description: 'Develop machine learning models to predict high-risk situations based on historical data'
    });
    
    actions.longTerm.push({
        id: 'lt-2',
        title: 'Enhanced safety culture program',
        description: 'Launch comprehensive behavioral safety program focusing on near miss reporting'
    });
    
    if (data.length > 50) {
        actions.longTerm.push({
            id: 'lt-3',
            title: 'Quarterly trend analysis',
            description: 'Establish regular review cycles for safety metrics and leading indicators'
        });
    }
    
    return actions;
}

function markActionComplete(type, actionId) {
    showStatus(`Action ${actionId} marked as complete`, 'success');
    event.target.closest('.action-item').style.opacity = '0.5';
    event.target.disabled = true;
    event.target.textContent = 'Completed';
}

function addNewAction() {
    showStatus('Action creation form would open here', 'info');
}

// View Details
function viewDetails(type, id) {
    const data = type === 'injury' ? 
        state.injury.filteredData.find(r => r.case_number === id) :
        state.nearMiss.filteredData.find(r => r.incident_id === id);
    
    if (!data) return;
    
    const modal = document.getElementById('detailModal');
    const title = document.getElementById('modalTitle');
    const body = document.getElementById('modalBody');
    
    title.textContent = type === 'injury' ? 'Injury & Illness Details' : 'Near Miss Details';
    
    if (type === 'injury') {
        const austinUrl = data.austin_url && data.austin_url !== '#' ? data.austin_url : null;
        
        body.innerHTML = `
            <div style="display: grid; gap: 1rem;">
                <div><strong>Case Number:</strong> ${data.case_number}</div>
                <div><strong>Date:</strong> ${data.incident_date || 'N/A'}</div>
                <div><strong>Time:</strong> ${data.incident_time || 'N/A'}</div>
                <div><strong>Site:</strong> ${data.site || 'N/A'}</div>
                <div><strong>Body Part:</strong> ${data.bodyPart || 'N/A'}</div>
                <div><strong>Type:</strong> ${data.type || 'N/A'}</div>
                <div><strong>Severity:</strong> <span class="badge badge-${getSeverityClass(data.severity)}">${data.severity}</span></div>
                <div><strong>Recordable:</strong> <span class="badge badge-${data.recordable === 1 ? 'danger' : 'success'}">${data.recordable === 1 ? 'Yes' : 'No'}</span></div>
                <div><strong>OTR:</strong> <span class="badge badge-${data.otr === 'yes' ? 'warning' : 'info'}">${data.otr === 'yes' ? 'Yes' : 'No'}</span></div>
                <div><strong>DAFW Days:</strong> ${data.total_dafw_days || 0}</div>
                <div><strong>RWA Days:</strong> ${data.total_rwa_days || 0}</div>
                <div><strong>Root Cause:</strong> ${data.rootCause || 'Under Investigation'}</div>
                <div><strong>Contributing Factors:</strong> ${data.contributingFactor || 'N/A'}</div>
                <div><strong>Process Path:</strong> ${data.processPath || 'N/A'}</div>
                <div><strong>Description:</strong> ${data.initial_info_incident_description || 'No description available'}</div>
                <div><strong>Status:</strong> ${data.status || 'N/A'}</div>
                ${austinUrl ? `
                <div style="margin-top: 1rem;">
                    <a href="${austinUrl}" target="_blank" class="btn btn-primary">
                        <span>üìö</span> Austin Link
                    </a>
                </div>` : ''}
            </div>
        `;
    } else {
        const austinUrl = data.austin_url && data.austin_url !== '#' ? data.austin_url : null;

        body.innerHTML = `
            <div style="display: grid; gap: 1rem;">
                <div><strong>ID:</strong> ${data.incident_id}</div>
                <div><strong>Date:</strong> ${data.nearmiss_date || 'N/A'}</div>
                <div><strong>Site:</strong> ${data.site || 'N/A'}</div>
                <div><strong>Location:</strong> ${data.location || 'N/A'}</div>
                <div><strong>Process Path:</strong> ${data.processPath || 'N/A'}</div>
                <div><strong>Primary Impact:</strong> ${data.primaryImpact || 'N/A'}</div>
                <div><strong>Potential Severity:</strong> <span class="badge badge-${getSeverityClass(data.severity)}">${data.severity}</span></div>
                <div><strong>Likelihood:</strong> <span class="badge badge-info">${data.standardized_likelihood || 'N/A'}</span></div>
                <div><strong>Risk Score:</strong> <span class="badge badge-${getRiskClass(data.risk)}">${data.risk || 'N/A'}</span></div>
                <div><strong>Contributing Factors:</strong> ${data.contributingFactor || 'N/A'}</div>
                <div><strong>Description:</strong> ${data.initial_info_incident_description || 'No description available'}</div>
                <div><strong>Root Cause:</strong> ${data.rca_primary_cause || 'Under investigation'}</div>
                <div><strong>Status:</strong> ${data.status || 'N/A'}</div>
                ${austinUrl ? `
                <div style="margin-top: 1rem;">
                    <a href="${austinUrl}" target="_blank" class="btn btn-primary">
                        <span>üìö</span> Austin Link
                    </a>
                </div>` : ''}
            </div>
        `;
    }
    
    modal.style.display = 'block';
}

function closeModal() {
    document.getElementById('detailModal').style.display = 'none';
}

// Export Functions
function exportInjuryData() {
    exportToExcel('injury');
}

function exportNearMissData() {
    exportToExcel('nearmiss');
}

function exportToExcel(type = 'all') {
    try {
        const wb = XLSX.utils.book_new();
        
        if (type === 'injury' || type === 'all') {
            if (state.injury.filteredData.length > 0) {
                const ws1 = XLSX.utils.json_to_sheet(state.injury.filteredData);
                XLSX.utils.book_append_sheet(wb, ws1, "Injury Data");
                
                const injurySummary = createInjurySummarySheet();
                const ws1Summary = XLSX.utils.aoa_to_sheet(injurySummary);
                XLSX.utils.book_append_sheet(wb, ws1Summary, "Injury Summary");
            }
        }
        
        if (type === 'nearmiss' || type === 'all') {
            if (state.nearMiss.filteredData.length > 0) {
                const ws2 = XLSX.utils.json_to_sheet(state.nearMiss.filteredData);
                XLSX.utils.book_append_sheet(wb, ws2, "Near Miss Data");
                
                const nearMissSummary = createNearMissSummarySheet();
                const ws2Summary = XLSX.utils.aoa_to_sheet(nearMissSummary);
                XLSX.utils.book_append_sheet(wb, ws2Summary, "Near Miss Summary");
            }
        }
        
        if ((type === 'injury' && state.injury.filteredData.length === 0) ||
            (type === 'nearmiss' && state.nearMiss.filteredData.length === 0) ||
            (type === 'all' && state.injury.filteredData.length === 0 && state.nearMiss.filteredData.length === 0)) {
            showStatus('No data to export', 'error');
            return;
        }
        
        const filename = type === 'all' ? 
            `safety_analysis_complete_${new Date().toISOString().split('T')[0]}.xlsx` :
            `${type}_analysis_${new Date().toISOString().split('T')[0]}.xlsx`;
        
        XLSX.writeFile(wb, filename);
        showStatus('Data exported successfully!', 'success');
    } catch (error) {
        console.error('Export error:', error);
        showStatus('Error exporting data: ' + error.message, 'error');
    }
}

function createInjurySummarySheet() {
    const data = state.injury.filteredData;
    const recordableCount = data.filter(r => r.recordable === 1).length;
    const lostTimeCount = data.filter(r => r.total_dafw_days > 0).length;
    const totalDaysLost = data.reduce((sum, r) => sum + (r.total_dafw_days || 0), 0);
    const otrCount = data.filter(r => r.otr === 'yes').length;
    
    return [
        ['Injury & Illness Analysis Summary'],
        ['Generated on:', new Date().toLocaleString()],
        ['Report by:', 'Erwin Esener @eeesener - Amazon WHS Austria'],
        [''],
        ['Key Metrics:'],
        ['Total Incidents:', data.length],
        ['Recordable Cases:', recordableCount],
        ['Lost Time Cases:', lostTimeCount],
        ['Total Days Lost (DAFW):', totalDaysLost],
        ['OTR Incidents:', otrCount],
        [''],
        ['Severity Distribution:'],
        ['A - Critical:', data.filter(r => r.severity === 'A').length],
        ['B - High:', data.filter(r => r.severity === 'B').length],
        ['C - Medium:', data.filter(r => r.severity === 'C').length],
        ['D - Low:', data.filter(r => r.severity === 'D').length],
        [''],
        ['Top Body Parts Affected:'],
        ...getTopItems(data, 'bodyPart', 5).map(([part, count]) => [part, count]),
        [''],
        ['Top Root Causes:'],
        ...getTopItems(data, 'rootCause', 5).map(([cause, count]) => [cause, count]),
        [''],
        ['Data Quality Score:', state.injury.qualityMetrics?.qualityScore || 'N/A']
    ];
}

function createNearMissSummarySheet() {
    const data = state.nearMiss.filteredData;
    const highSeverityCount = data.filter(r => r.severity === 'A' || r.severity === 'B').length;
    const avgRisk = data.length > 0 ? 
        (data.reduce((sum, r) => sum + parseFloat(r.risk || 0), 0) / data.length).toFixed(1) : 0;
    
    return [
        ['Near Miss Analysis Summary'],
        ['Generated on:', new Date().toLocaleString()],
        ['Report by:', 'Erwin Esener @eeesener - Amazon WHS Austria'],
        [''],
        ['Key Metrics:'],
        ['Total Near Misses:', data.length],
        ['High Severity Cases (A & B):', highSeverityCount],
        ['Average Risk Score:', avgRisk],
        [''],
        ['Severity Distribution:'],
        ['A - Critical:', data.filter(r => r.severity === 'A').length],
        ['B - High:', data.filter(r => r.severity === 'B').length],
        ['C - Medium:', data.filter(r => r.severity === 'C').length],
        ['D - Low:', data.filter(r => r.severity === 'D').length],
        [''],
        ['Top Locations:'],
        ...getTopItems(data, 'location', 5).map(([location, count]) => [location, count]),
        [''],
        ['Top Process Paths:'],
        ...getTopItems(data, 'processPath', 5).map(([process, count]) => [process, count]),
        [''],
        ['Data Quality Score:', state.nearMiss.qualityMetrics?.qualityScore || 'N/A']
    ];
}

function getTopItems(data, field, limit = 5) {
    const counts = {};
    data.forEach(row => {
        const value = row[field] || 'Unknown';
        counts[value] = (counts[value] || 0) + 1;
    });
    
    return Object.entries(counts)
        .sort((a, b) => b[1] - a[1])
        .slice(0, limit);
}

// Export Table
function exportTable(type) {
    const tableId = type === 'injury' ? 'injuryTable' : 'nearMissTable';
    const table = document.getElementById(tableId);
    
    if (!table) {
        showStatus('Table not found', 'error');
        return;
    }
    
    try {
        const wb = XLSX.utils.table_to_book(table);
        XLSX.writeFile(wb, `${type}_table_export_${new Date().toISOString().split('T')[0]}.xlsx`);
        showStatus('Table exported successfully!', 'success');
    } catch (error) {
        console.error('Table export error:', error);
        showStatus('Error exporting table: ' + error.message, 'error');
    }
}

// Export Chart
function exportChart(chartId) {
    const chart = Chart.getChart(chartId);
    if (!chart) {
        showStatus('Chart not found', 'error');
        return;
    }
    
    const url = chart.toBase64Image();
    const link = document.createElement('a');
    link.download = `${chartId}_${new Date().toISOString().split('T')[0]}.png`;
    link.href = url;
    link.click();
    
    showStatus('Chart exported successfully!', 'success');
}

// Export Dashboard
function exportDashboard() {
    showStatus('Capturing dashboard...', 'info');
    
    const dashboardElement = document.querySelector('.container');
    if (!dashboardElement) {
        showStatus('Dashboard element not found', 'error');
        return;
    }
    
    html2canvas(dashboardElement, {
        scale: 2,
        useCORS: true,
        logging: false,
        backgroundColor: state.theme === 'dark' ? '#1a1a1a' : '#ffffff'
    }).then(canvas => {
        const link = document.createElement('a');
        link.download = `safety_dashboard_${new Date().toISOString().split('T')[0]}.png`;
        link.href = canvas.toDataURL();
        link.click();
        showStatus('Dashboard exported as image!', 'success');
    }).catch(error => {
        console.error('Dashboard export error:', error);
        showStatus('Error exporting dashboard: ' + error.message, 'error');
    });
}

// Generate PDF Report
function generatePDFReport(type) {
    showStatus('Generating professional PDF report...', 'info');
    
    try {
        const { jsPDF } = window.jspdf;
        const doc = new jsPDF({
            orientation: 'portrait',
            unit: 'mm',
            format: 'a4'
        });

        // Set a default font for the entire document. Without this,
        // jsPDF may fallback to an undefined font which triggers
        // errors like "Invalid argument passed to jsPDF.f2". We
        // explicitly choose a built‚Äëin font and weight here to avoid
        // undefined font references.
        doc.setFont('helvetica', 'normal');
        
        const pageWidth = 210;
        const pageHeight = 297;
        const margin = 20;
        const contentWidth = pageWidth - (margin * 2);
        
        const addHeader = (pageNum) => {
            // Header background
            doc.setFillColor(...hexToRgb(AMAZON_COLORS.orange));
            doc.rect(0, 0, pageWidth, 30, 'F');
            
            // Amazon logo area
            doc.setFillColor(...hexToRgb(AMAZON_COLORS.darkBlue));
            doc.rect(0, 0, 60, 30, 'F');
            
            // Title
            doc.setTextColor(255, 255, 255);
            doc.setFontSize(18);
            doc.setFont('helvetica', 'bold');
            doc.text('Safety Analytics Report', pageWidth / 2, 15, { align: 'center' });
            
            // Subtitle
            doc.setFontSize(11);
            doc.setFont('helvetica', 'normal');
            doc.text('Amazon WHS Austria', pageWidth / 2, 22, { align: 'center' });
            
            // Page number
            doc.setFontSize(9);
            doc.text(`Page ${pageNum}`, pageWidth - margin, 25, { align: 'right' });
        };
        
        const addFooter = () => {
            doc.setFillColor(...hexToRgb(AMAZON_COLORS.darkBlue));
            doc.rect(0, pageHeight - 15, pageWidth, 15, 'F');
            doc.setTextColor(255, 255, 255);
            doc.setFontSize(8);
            doc.text('¬© 2024 Amazon.com, Inc. - Confidential', margin, pageHeight - 8);
            doc.text('Developed by Erwin Esener @eeesener', pageWidth - margin, pageHeight - 8, { align: 'right' });
        };
        
        const addSectionHeader = (title, yPos) => {
            doc.setFillColor(...hexToRgb(AMAZON_COLORS.orange));
            doc.rect(margin - 5, yPos - 8, contentWidth + 10, 12, 'F');
            doc.setTextColor(255, 255, 255);
            doc.setFontSize(13);
            doc.setFont('helvetica', 'bold');
            doc.text(title, margin, yPos);
            return yPos + 10;
        };
        
        const addMetricBox = (x, y, width, height, label, value, color = AMAZON_COLORS.orange) => {
            // Box background
            doc.setFillColor(250, 250, 250);
            doc.setDrawColor(200, 200, 200);
            doc.rect(x, y, width, height, 'FD');
            
            // Determine RGB values for the accent colour.  The colour parameter may
            // be a hex string, an rgb(...) string or one of our predefined
            // colours from AMAZON_COLORS.  Convert accordingly.
            let colorRGB = [];
            if (typeof color === 'string') {
                if (color.startsWith('#')) {
                    colorRGB = hexToRgb(color);
                } else if (color.toLowerCase().startsWith('rgb')) {
                    const nums = color.match(/\d+/g);
                    colorRGB = nums ? nums.map(Number) : [0, 0, 0];
                } else if (AMAZON_COLORS[color]) {
                    colorRGB = hexToRgb(AMAZON_COLORS[color]);
                } else {
                    // Fallback to orange if unknown
                    colorRGB = hexToRgb(AMAZON_COLORS.orange);
                }
            } else {
                colorRGB = hexToRgb(AMAZON_COLORS.orange);
            }
            doc.setFillColor(...colorRGB);
            doc.rect(x, y, width, 4, 'F');
            
            // Value
            doc.setTextColor(...hexToRgb(AMAZON_COLORS.darkBlue));
            doc.setFontSize(20);
            // Use a defined font name instead of undefined to avoid jsPDF errors
            doc.setFont('helvetica', 'bold');
            doc.text(value.toString(), x + width/2, y + height/2, { align: 'center' });
            
            // Label
            doc.setFontSize(9);
            doc.setFont('helvetica', 'normal');
            doc.setTextColor(...hexToRgb(AMAZON_COLORS.gray));
            doc.text(label, x + width/2, y + height - 5, { align: 'center' });
        };
        
        let currentPage = 1;
        let yPos = 40;
        
        // Page 1 - Executive Summary
        addHeader(currentPage);
        
        // Report info
        doc.setTextColor(...hexToRgb(AMAZON_COLORS.darkBlue));
        doc.setFontSize(10);
        // Use a defined font for normal weight
        doc.setFont('helvetica', 'normal');
        doc.text(`Report Generated: ${new Date().toLocaleString('en-GB')}`, margin, yPos);
        doc.text(`Report Type: ${type.charAt(0).toUpperCase() + type.slice(1)} Safety Analysis`, margin, yPos + 6);
        doc.text(`Period: ${getReportPeriod()}`, margin, yPos + 12);
        
        yPos = 65;
        
        // Executive Summary
        yPos = addSectionHeader('Executive Summary', yPos);
        
        doc.setFillColor(255, 249, 240);
        // Use a proper RGB value for the border colour
        doc.setDrawColor(...hexToRgb(AMAZON_COLORS.orange));
        doc.setLineWidth(0.5);
        doc.rect(margin, yPos, contentWidth, 50, 'FD');
        
        doc.setTextColor(...hexToRgb(AMAZON_COLORS.darkBlue));
        doc.setFontSize(10);
        doc.setFont('helvetica', 'normal');
        
        let summaryText = '';
        if (type === 'injury' || type === 'combined') {
            const injuryData = state.injury.filteredData;
            const recordableCount = injuryData.filter(r => r.recordable === 1).length;
            const lostTimeCount = injuryData.filter(r => r.total_dafw_days > 0).length;
            const totalDaysLost = injuryData.reduce((sum, r) => sum + (r.total_dafw_days || 0), 0);
            const qualityScore = state.injury.qualityMetrics?.qualityScore || 'N/A';
            
            summaryText = `Injury & Illness Analysis:\n`;
            summaryText += `‚Ä¢ Total Incidents: ${injuryData.length}\n`;
            summaryText += `‚Ä¢ Recordable Cases: ${recordableCount} (${((recordableCount/injuryData.length)*100).toFixed(1)}%)\n`;
            summaryText += `‚Ä¢ Lost Time Cases: ${lostTimeCount} with ${totalDaysLost} total days lost\n`;
            summaryText += `‚Ä¢ Data Quality Score: ${qualityScore}%\n`;
            summaryText += `‚Ä¢ Key Finding: ${getKeyFinding(injuryData, 'injury')}`;
        }
        
        if (type === 'nearmiss' || type === 'combined') {
            if (summaryText) summaryText += '\n\n';
            const nearMissData = state.nearMiss.filteredData;
            const highRiskCount = nearMissData.filter(r => r.severity === 'A' || r.severity === 'B').length;
            const qualityScore = state.nearMiss.qualityMetrics?.qualityScore || 'N/A';
            
            summaryText += `Near Miss Analysis:\n`;
            summaryText += `‚Ä¢ Total Near Misses: ${nearMissData.length}\n`;
            summaryText += `‚Ä¢ High Risk Events: ${highRiskCount} (Severity A & B)\n`;
            summaryText += `‚Ä¢ Data Quality Score: ${qualityScore}%\n`;
            summaryText += `‚Ä¢ Key Finding: ${getKeyFinding(nearMissData, 'nearmiss')}`;
        }
        
        const lines = doc.splitTextToSize(summaryText, contentWidth - 10);
        doc.text(lines, margin + 5, yPos + 8);
        
        yPos += 55;
        
        // Key Metrics Dashboard
        yPos = addSectionHeader('Key Performance Indicators', yPos);
        
        const metricsY = yPos + 5;
        const boxWidth = 38;
        const boxHeight = 28;
        const boxGap = 5;
        
        if (type === 'injury' || type === 'combined') {
            const injuryData = state.injury.filteredData;
            const metrics = [
                { label: 'Total Cases', value: injuryData.length, color: AMAZON_COLORS.darkBlue },
                { label: 'Recordable', value: injuryData.filter(r => r.recordable === 1).length, color: 'rgb(255, 87, 34)' },
                { label: 'Lost Time', value: injuryData.filter(r => r.total_dafw_days > 0).length, color: 'rgb(183, 28, 28)' },
                { label: 'Days Lost', value: injuryData.reduce((sum, r) => sum + (r.total_dafw_days || 0), 0), color: AMAZON_COLORS.orange }
            ];
            
            metrics.forEach((metric, index) => {
                const x = margin + (index * (boxWidth + boxGap));
                addMetricBox(x, metricsY, boxWidth, boxHeight, metric.label, metric.value, metric.color);
            });
        }
        
        yPos = metricsY + boxHeight + 15;
        
        // Severity Distribution
        yPos = addSectionHeader('Severity Distribution Analysis', yPos);
        
        const allData = type === 'injury' ? state.injury.filteredData :
                      type === 'nearmiss' ? state.nearMiss.filteredData :
                      [...state.injury.filteredData, ...state.nearMiss.filteredData];
        
        const severityData = {
            'A - Critical': allData.filter(r => r.severity === 'A').length,
            'B - High': allData.filter(r => r.severity === 'B').length,
            'C - Medium': allData.filter(r => r.severity === 'C').length,
            'D - Low': allData.filter(r => r.severity === 'D').length
        };
        
        const maxSeverity = Math.max(...Object.values(severityData));
        const barHeight = 8;
        
        Object.entries(severityData).forEach(([severity, count], index) => {
            const barY = yPos + (index * (barHeight + 5));
            const barWidth = maxSeverity > 0 ? (count / maxSeverity) * 100 : 0;
            const percentage = allData.length > 0 ? ((count / allData.length) * 100).toFixed(1) : '0';
            
            // Label
            doc.setFontSize(9);
            doc.setFont('helvetica', 'normal');
            doc.setTextColor(...hexToRgb(AMAZON_COLORS.darkBlue));
            doc.text(severity, margin, barY + 6);
            
            // Bar
            const colors = {
                'A - Critical': SEVERITY_COLORS.A,
                'B - High': SEVERITY_COLORS.B,
                'C - Medium': SEVERITY_COLORS.C,
                'D - Low': SEVERITY_COLORS.D
            };
            // Convert severity colour code (e.g. "#B71C1C") into an RGB array.  If the
            // value is already in rgb(...) notation extract the numbers, otherwise
            // use hexToRgb to interpret the hex code.  Falling back to the
            // amazon orange colour if parsing fails ensures valid values are
            // always passed to jsPDF.
            let colorRGB;
            const sevColor = colors[severity];
            if (typeof sevColor === 'string') {
                if (sevColor.startsWith('#')) {
                    colorRGB = hexToRgb(sevColor);
                } else if (sevColor.toLowerCase().startsWith('rgb')) {
                    const nums = sevColor.match(/\d+/g);
                    colorRGB = nums ? nums.map(Number) : hexToRgb(AMAZON_COLORS.orange);
                } else {
                    colorRGB = hexToRgb(sevColor);
                }
            } else {
                colorRGB = hexToRgb(AMAZON_COLORS.orange);
            }
            doc.setFillColor(...colorRGB);
            doc.rect(margin + 25, barY, barWidth, barHeight, 'F');
            
            // Value
            doc.setTextColor(...hexToRgb(AMAZON_COLORS.gray));
            doc.text(`${count} (${percentage}%)`, margin + 130, barY + 6);
        });
        
        yPos += (4 * (barHeight + 5)) + 10;
        
        // Add footer
        addFooter();
        
        // Page 2 - Detailed Analysis
        if (type === 'injury' || type === 'combined') {
            doc.addPage();
            currentPage++;
            addHeader(currentPage);
            yPos = 40;
            
            yPos = addSectionHeader('Injury & Illness Detailed Analysis', yPos);
            
            // Top affected body parts table
            const bodyPartCounts = {};
            state.injury.filteredData.forEach(row => {
                const part = row.bodyPart || 'Unknown';
                bodyPartCounts[part] = (bodyPartCounts[part] || 0) + 1;
            });
            
            const topBodyParts = Object.entries(bodyPartCounts)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 5);
            
            doc.autoTable({
                startY: yPos,
                head: [['Body Part', 'Incidents', 'Percentage', 'Severity']],
                body: topBodyParts.map(([part, count]) => [
                    part.substring(0, 40) + (part.length > 40 ? '...' : ''),
                    count,
                    ((count / state.injury.filteredData.length) * 100).toFixed(1) + '%',
                    getAverageSeverity(state.injury.filteredData.filter(r => r.bodyPart === part))
                ]),
                theme: 'grid',
                // Use proper RGB colour for the table header
                headStyles: { fillColor: hexToRgb(AMAZON_COLORS.darkBlue) },
                margin: { left: margin, right: margin }
            });
            
            yPos = doc.lastAutoTable.finalY + 10;
            
            // Root causes
            yPos = addSectionHeader('Root Cause Analysis', yPos);
            
            const rootCauseCounts = {};
            state.injury.filteredData.forEach(row => {
                const cause = row.rootCause || 'Under Investigation';
                rootCauseCounts[cause] = (rootCauseCounts[cause] || 0) + 1;
            });
            
            const topCauses = Object.entries(rootCauseCounts)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 6);
            
            doc.autoTable({
                startY: yPos,
                head: [['Root Cause', 'Count', 'Percentage']],
                body: topCauses.map(([cause, count]) => [
                    cause.substring(0, 50) + (cause.length > 50 ? '...' : ''),
                    count,
                    ((count / state.injury.filteredData.length) * 100).toFixed(1) + '%'
                ]),
                theme: 'grid',
                headStyles: { fillColor: hexToRgb(AMAZON_COLORS.darkBlue) },
                margin: { left: margin, right: margin }
            });
            
            addFooter();
        }
        
        // Page 3 - Near Miss Analysis
        if (type === 'nearmiss' || type === 'combined') {
            doc.addPage();
            currentPage++;
            addHeader(currentPage);
            yPos = 40;
            
            yPos = addSectionHeader('Near Miss Detailed Analysis', yPos);
            
            // Top locations
            const locationCounts = {};
            state.nearMiss.filteredData.forEach(row => {
                const location = row.location || 'Unknown';
                locationCounts[location] = (locationCounts[location] || 0) + 1;
            });
            
            const topLocations = Object.entries(locationCounts)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 5);
            
            doc.autoTable({
                startY: yPos,
                head: [['Location', 'Incidents', 'Avg Risk Score']],
                body: topLocations.map(([location, count]) => {
                    const locationData = state.nearMiss.filteredData.filter(r => r.location === location);
                    const avgRisk = locationData.reduce((sum, r) => sum + parseFloat(r.risk || 0), 0) / locationData.length;
                    return [
                        location.substring(0, 50) + (location.length > 50 ? '...' : ''),
                        count,
                        avgRisk.toFixed(1)
                    ];
                }),
                theme: 'grid',
                headStyles: { fillColor: hexToRgb(AMAZON_COLORS.darkBlue) },
                margin: { left: margin, right: margin }
            });
            
            yPos = doc.lastAutoTable.finalY + 10;
            
            // Process paths
            yPos = addSectionHeader('Process Path Analysis', yPos);
            
            const processCounts = {};
            state.nearMiss.filteredData.forEach(row => {
                const process = row.processPath || 'Unknown';
                processCounts[process] = (processCounts[process] || 0) + 1;
            });
            
            const topProcesses = Object.entries(processCounts)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 5);
            
            doc.autoTable({
                startY: yPos,
                head: [['Process Path', 'Near Misses', 'High Risk %']],
                body: topProcesses.map(([process, count]) => {
                    const processData = state.nearMiss.filteredData.filter(r => r.processPath === process);
                    const highRisk = processData.filter(r => parseFloat(r.risk) >= 7).length;
                    return [
                        process,
                        count,
                        ((highRisk / count) * 100).toFixed(1) + '%'
                    ];
                }),
                theme: 'grid',
                headStyles: { fillColor: hexToRgb(AMAZON_COLORS.darkBlue) },
                margin: { left: margin, right: margin }
            });
            
            addFooter();
        }
        
        // Page 4 - Data Quality Report
        doc.addPage();
        currentPage++;
        addHeader(currentPage);
        yPos = 40;
        
        yPos = addSectionHeader('Data Quality Assessment', yPos);
        
        // Quality metrics for each type
        if (type === 'injury' || type === 'combined') {
            const metrics = state.injury.qualityMetrics;
            if (metrics && metrics.totalRecords) {
                doc.setFontSize(11);
                doc.setFont('helvetica', 'bold');
                doc.setTextColor(...hexToRgb(AMAZON_COLORS.darkBlue));
                doc.text('Injury Data Quality', margin, yPos + 5);
                
                // Quality score circle
                const scoreColor = metrics.qualityScore >= 90 ? SEVERITY_COLORS.D : 
                                  metrics.qualityScore >= 70 ? SEVERITY_COLORS.C : 
                                  metrics.qualityScore >= 50 ? SEVERITY_COLORS.B : 
                                  SEVERITY_COLORS.A;
                // Convert the severity colour into an RGB triple.  SEVERITY_COLORS
                // values are defined as hex strings (e.g. "#4CAF50"), so using
                // hexToRgb ensures the values are parsed correctly.  If the
                // string is already in an rgb(...) format we extract the
                // numeric components; otherwise we default to orange.
                let scoreRGB;
                if (typeof scoreColor === 'string') {
                    if (scoreColor.startsWith('#')) {
                        scoreRGB = hexToRgb(scoreColor);
                    } else if (scoreColor.toLowerCase().startsWith('rgb')) {
                        const nums = scoreColor.match(/\d+/g);
                        scoreRGB = nums ? nums.map(Number) : hexToRgb(AMAZON_COLORS.orange);
                    } else {
                        scoreRGB = hexToRgb(scoreColor);
                    }
                } else {
                    scoreRGB = hexToRgb(AMAZON_COLORS.orange);
                }

                doc.setFillColor(...scoreRGB);
                doc.circle(margin + 30, yPos + 20, 15, 'F');
                doc.setTextColor(255, 255, 255);
                doc.setFontSize(16);
                doc.setFont('helvetica', 'bold');
                doc.text(`${metrics.qualityScore}%`, margin + 30, yPos + 23, { align: 'center' });
                
                // Quality details
                doc.setTextColor(...hexToRgb(AMAZON_COLORS.darkBlue));
                doc.setFontSize(10);
                doc.setFont('helvetica', 'normal');
                doc.text(`Total Records: ${metrics.totalRecords}`, margin + 60, yPos + 10);
                doc.text(`Duplicate Records: ${metrics.duplicates}`, margin + 60, yPos + 16);
                doc.text(`Missing Critical Fields: ${metrics.missingCriticalFields}`, margin + 60, yPos + 22);
                doc.text(`Data Completeness: ${metrics.dataCompleteness}%`, margin + 60, yPos + 28);
                
                yPos += 40;
            }
        }
        
        if (type === 'nearmiss' || type === 'combined') {
            const metrics = state.nearMiss.qualityMetrics;
            if (metrics && metrics.totalRecords) {
                doc.setFontSize(11);
                doc.setFont('helvetica', 'bold');
                doc.setTextColor(...hexToRgb(AMAZON_COLORS.darkBlue));
                doc.text('Near Miss Data Quality', margin, yPos + 5);
                
                // Quality score circle
                const scoreColor = metrics.qualityScore >= 90 ? SEVERITY_COLORS.D : 
                                  metrics.qualityScore >= 70 ? SEVERITY_COLORS.C : 
                                  metrics.qualityScore >= 50 ? SEVERITY_COLORS.B : 
                                  SEVERITY_COLORS.A;
                // Convert the colour into an RGB triple for jsPDF. The
                // severity colours are defined as hex strings (e.g. "#FF5722");
                // convert using hexToRgb. If the colour is provided in
                // rgb(...) format extract the numeric values. Fallback to
                // orange if parsing fails.
                let scoreRGB;
                if (typeof scoreColor === 'string') {
                    if (scoreColor.startsWith('#')) {
                        scoreRGB = hexToRgb(scoreColor);
                    } else if (scoreColor.toLowerCase().startsWith('rgb')) {
                        const nums = scoreColor.match(/\d+/g);
                        scoreRGB = nums ? nums.map(Number) : hexToRgb(AMAZON_COLORS.orange);
                    } else {
                        scoreRGB = hexToRgb(scoreColor);
                    }
                } else {
                    scoreRGB = hexToRgb(AMAZON_COLORS.orange);
                }

                doc.setFillColor(...scoreRGB);
                doc.circle(margin + 30, yPos + 20, 15, 'F');
                doc.setTextColor(255, 255, 255);
                doc.setFontSize(16);
                doc.setFont('helvetica', 'bold');
                doc.text(`${metrics.qualityScore}%`, margin + 30, yPos + 23, { align: 'center' });
                
                // Quality details
                doc.setTextColor(...hexToRgb(AMAZON_COLORS.darkBlue));
                doc.setFontSize(10);
                doc.setFont('helvetica', 'normal');
                doc.text(`Total Records: ${metrics.totalRecords}`, margin + 60, yPos + 10);
                doc.text(`Duplicate Records: ${metrics.duplicates}`, margin + 60, yPos + 16);
                doc.text(`Missing Critical Fields: ${metrics.missingCriticalFields}`, margin + 60, yPos + 22);
                doc.text(`Data Completeness: ${metrics.dataCompleteness}%`, margin + 60, yPos + 28);
                
                yPos += 40;
            }
        }
        
        // Page 5 - Recommendations
        doc.addPage();
        currentPage++;
        addHeader(currentPage);
        yPos = 40;
        
        yPos = addSectionHeader('Recommendations & Action Plan', yPos);
        
        const allDataForActions = type === 'injury' ? state.injury.filteredData :
                                type === 'nearmiss' ? state.nearMiss.filteredData :
                                [...state.injury.filteredData, ...state.nearMiss.filteredData];
        
        const actions = generateActionItems(allDataForActions);
        
        // Immediate Actions
        doc.setFillColor(255, 249, 240);
        doc.setDrawColor(255, 87, 34);
        doc.setLineWidth(0.5);
        doc.rect(margin, yPos, contentWidth, 35, 'FD');
        
        doc.setTextColor(255, 87, 34);
        doc.setFontSize(11);
        // Use a defined font to avoid jsPDF undefined font error
        doc.setFont('helvetica', 'bold');
        doc.text('Immediate Actions Required', margin + 5, yPos + 8);
        
        doc.setTextColor(...hexToRgb(AMAZON_COLORS.darkBlue));
        doc.setFontSize(9);
        doc.setFont('helvetica', 'normal');
        
        const immediateText = actions.immediate.slice(0, 3).map((action, i) => 
            `${i + 1}. ${action.title}: ${action.description}`
        ).join('\n');
        
        const immediateLines = doc.splitTextToSize(immediateText || 'No immediate actions required', contentWidth - 10);
        doc.text(immediateLines, margin + 5, yPos + 15);
        
        yPos += 40;
        
        // Short-term Actions
        doc.setFillColor(255, 252, 240);
        doc.setDrawColor(255, 193, 7);
        doc.rect(margin, yPos, contentWidth, 35, 'FD');
        
        doc.setTextColor(255, 152, 0);
        doc.setFontSize(11);
        doc.setFont('helvetica', 'bold');
        doc.text('Short-term Actions (30 days)', margin + 5, yPos + 8);
        
        doc.setTextColor(...hexToRgb(AMAZON_COLORS.darkBlue));
        doc.setFontSize(9);
        doc.setFont('helvetica', 'normal');
        
        const shortTermText = actions.shortTerm.slice(0, 3).map((action, i) => 
            `${i + 1}. ${action.title}: ${action.description}`
        ).join('\n');
        
        const shortTermLines = doc.splitTextToSize(shortTermText || 'No short-term actions identified', contentWidth - 10);
        doc.text(shortTermLines, margin + 5, yPos + 15);
        
        yPos += 40;
        
        // Long-term Improvements
        doc.setFillColor(240, 248, 255);
        doc.setDrawColor(33, 150, 243);
        doc.rect(margin, yPos, contentWidth, 35, 'FD');
        
        doc.setTextColor(33, 150, 243);
        doc.setFontSize(11);
        doc.setFont('helvetica', 'bold');
        doc.text('Long-term Improvements', margin + 5, yPos + 8);
        
        doc.setTextColor(...hexToRgb(AMAZON_COLORS.darkBlue));
        doc.setFontSize(9);
        doc.setFont('helvetica', 'normal');
        
        const longTermText = actions.longTerm.slice(0, 3).map((action, i) => 
            `${i + 1}. ${action.title}: ${action.description}`
        ).join('\n');
        
        const longTermLines = doc.splitTextToSize(longTermText || 'No long-term improvements identified', contentWidth - 10);
        doc.text(longTermLines, margin + 5, yPos + 15);
        
        yPos += 40;
        
        // Risk Matrix Summary
        yPos = addSectionHeader('Risk Matrix Summary', yPos);
        
        const riskSummary = calculateRiskMatrixSummary(allDataForActions);
        
        doc.autoTable({
            startY: yPos,
            head: [['Risk Level', 'Count', 'Percentage', 'Action Priority']],
            body: [
                ['Critical (16-25)', riskSummary.critical, `${riskSummary.criticalPercent}%`, 'Immediate'],
                ['High (11-15)', riskSummary.high, `${riskSummary.highPercent}%`, 'Within 7 days'],
                ['Medium (6-10)', riskSummary.medium, `${riskSummary.mediumPercent}%`, 'Within 30 days'],
                ['Low (1-5)', riskSummary.low, `${riskSummary.lowPercent}%`, 'Routine']
            ],
            theme: 'grid',
            headStyles: { fillColor: hexToRgb(AMAZON_COLORS.darkBlue) },
            bodyStyles: { cellPadding: 3 },
            columnStyles: {
                0: { cellWidth: 40 },
                1: { cellWidth: 30, halign: 'center' },
                2: { cellWidth: 35, halign: 'center' },
                3: { cellWidth: 65 }
            },
            margin: { left: margin, right: margin }
        });
        
        addFooter();
        
        // Executive Summary Page (if requested)
        if (type === 'executive') {
            doc.addPage();
            currentPage++;
            addHeader(currentPage);
            yPos = 40;
            
            yPos = addSectionHeader('Executive Summary Dashboard', yPos);
            
            // Create executive metrics
            const execMetrics = calculateExecutiveMetrics();
            
            // Monthly trend summary
            doc.setFillColor(240, 240, 240);
            doc.rect(margin, yPos, contentWidth, 45, 'F');
            
            doc.setTextColor(...hexToRgb(AMAZON_COLORS.darkBlue));
            doc.setFontSize(10);
            const trendText = `Safety Performance Trend:\n`;
            const trendAnalysis = analyzeTrend(execMetrics);
            const trendLines = doc.splitTextToSize(trendText + trendAnalysis, contentWidth - 10);
            doc.text(trendLines, margin + 5, yPos + 8);
            
            yPos += 50;
            
            // Site ranking
            yPos = addSectionHeader('Site Performance Ranking', yPos);
            
            const siteRanking = calculateSiteRanking();
            
            doc.autoTable({
                startY: yPos,
                head: [['Rank', 'Site', 'Total Incidents', 'Risk Score', 'Status']],
                body: siteRanking.slice(0, 5).map((site, index) => [
                    index + 1,
                    site.name,
                    site.incidents,
                    site.riskScore.toFixed(1),
                    site.status
                ]),
                theme: 'grid',
                headStyles: { fillColor: hexToRgb(AMAZON_COLORS.darkBlue) },
                bodyStyles: { cellPadding: 3 },
                margin: { left: margin, right: margin }
            });
            
            addFooter();
        }
        
        // Save the PDF
        const fileName = `${type}_safety_report_${new Date().toISOString().split('T')[0]}.pdf`;
        doc.save(fileName);
        
        showStatus('Professional PDF report generated successfully!', 'success');
        
        // Add to report history
        addToReportHistory(type, fileName);
        
    } catch (error) {
        console.error('PDF generation error:', error);
        showStatus('Error generating PDF: ' + error.message, 'error');
    }
}

function getReportPeriod() {
    const allData = [...state.injury.filteredData, ...state.nearMiss.filteredData];
    if (allData.length === 0) return 'No data available';
    
    const dates = allData
        .map(r => r.parsedDate)
        .filter(d => d && !isNaN(d))
        .sort((a, b) => a - b);
    
    if (dates.length === 0) return 'Date range not available';
    
    const startDate = dates[0].toLocaleDateString('en-GB');
    const endDate = dates[dates.length - 1].toLocaleDateString('en-GB');
    
    return `${startDate} - ${endDate}`;
}

function getKeyFinding(data, type) {
    if (data.length === 0) return 'No data available for analysis';
    
    if (type === 'injury') {
        const severityA = data.filter(r => r.severity === 'A').length;
        const recordable = data.filter(r => r.recordable === 1).length;
        const recordableRate = ((recordable / data.length) * 100).toFixed(1);
        
        if (severityA > 0) {
            return `${severityA} critical severity incidents require immediate attention`;
        }
        if (recordableRate > 50) {
            return `High recordable rate (${recordableRate}%) indicates need for enhanced safety measures`;
        }
        return `Stable safety performance with ${data.length} total incidents`;
    } else {
        const highRisk = data.filter(r => parseFloat(r.risk) >= 7).length;
        const repeatLocations = {};
        data.forEach(r => {
            repeatLocations[r.location] = (repeatLocations[r.location] || 0) + 1;
        });
        const hotspots = Object.values(repeatLocations).filter(count => count >= 3).length;
        
        if (highRisk > 5) {
            return `${highRisk} high-risk near misses indicate potential for serious incidents`;
        }
        if (hotspots > 0) {
            return `${hotspots} locations with repeated near misses require targeted interventions`;
        }
        return `Good hazard identification with ${data.length} near misses reported`;
    }
}

function getAverageSeverity(data) {
    const severityMap = { 'A': 4, 'B': 3, 'C': 2, 'D': 1 };
    const severitySum = data.reduce((sum, r) => sum + (severityMap[r.severity] || 0), 0);
    const avgValue = data.length > 0 ? severitySum / data.length : 0;
    
    if (avgValue >= 3.5) return 'Critical';
    if (avgValue >= 2.5) return 'High';
    if (avgValue >= 1.5) return 'Medium';
    return 'Low';
}

function calculateRiskMatrixSummary(data) {
    const riskScores = data.map(r => {
        if (r.risk) return parseFloat(r.risk) * 2.5; // Scale to 25
        const severityMap = { 'A': 5, 'B': 4, 'C': 3, 'D': 2, 'Unknown': 1 };
        const likelihoodMap = { 
            'Rare': 1, 
            'Unlikely': 2, 
            'Possible': 3, 
            'Likely': 4, 
            'Almost Certain': 5 
        };
        const severity = severityMap[r.severity] || 1;
        const likelihood = likelihoodMap[r.standardized_likelihood] || 3;
        return severity * likelihood;
    });
    
    const critical = riskScores.filter(s => s >= 16).length;
    const high = riskScores.filter(s => s >= 11 && s < 16).length;
    const medium = riskScores.filter(s => s >= 6 && s < 11).length;
    const low = riskScores.filter(s => s < 6).length;
    const total = riskScores.length || 1;
    
    return {
        critical,
        high,
        medium,
        low,
        criticalPercent: ((critical / total) * 100).toFixed(1),
        highPercent: ((high / total) * 100).toFixed(1),
        mediumPercent: ((medium / total) * 100).toFixed(1),
        lowPercent: ((low / total) * 100).toFixed(1)
    };
}

function calculateExecutiveMetrics() {
    const allData = [...state.injury.filteredData, ...state.nearMiss.filteredData];
    const monthlyData = {};
    
    allData.forEach(row => {
        if (row.parsedDate && !isNaN(row.parsedDate)) {
            const monthKey = `${row.parsedDate.getFullYear()}-${String(row.parsedDate.getMonth() + 1).padStart(2, '0')}`;
            if (!monthlyData[monthKey]) {
                monthlyData[monthKey] = {
                    total: 0,
                    injury: 0,
                    nearMiss: 0,
                    recordable: 0,
                    highSeverity: 0
                };
            }
            monthlyData[monthKey].total++;
            if (row.case_number) {
                monthlyData[monthKey].injury++;
                if (row.recordable === 1) monthlyData[monthKey].recordable++;
            } else {
                monthlyData[monthKey].nearMiss++;
            }
            if (row.severity === 'A' || row.severity === 'B') {
                monthlyData[monthKey].highSeverity++;
            }
        }
    });
    
    return monthlyData;
}

function analyzeTrend(monthlyData) {
    const months = Object.keys(monthlyData).sort();
    if (months.length < 2) return 'Insufficient data for trend analysis';
    
    const recent = months.slice(-3);
    const older = months.slice(-6, -3);
    
    const recentAvg = recent.reduce((sum, m) => sum + monthlyData[m].total, 0) / recent.length;
    const olderAvg = older.length > 0 ? 
        older.reduce((sum, m) => sum + monthlyData[m].total, 0) / older.length : 
        recentAvg;
    
    const trend = ((recentAvg - olderAvg) / olderAvg * 100).toFixed(0);
    
    let analysis = `Recent 3-month average: ${recentAvg.toFixed(1)} incidents/month\n`;
    
    if (trend > 10) {
        analysis += `‚ö†Ô∏è Upward trend of ${trend}% - Enhanced safety measures recommended`;
    } else if (trend < -10) {
        analysis += `‚úÖ Downward trend of ${Math.abs(trend)}% - Safety improvements showing results`;
    } else {
        analysis += `‚û°Ô∏è Stable trend (${trend > 0 ? '+' : ''}${trend}%) - Maintain current safety protocols`;
    }
    
    return analysis;
}

function calculateSiteRanking() {
    const siteData = {};
    
    [...state.injury.filteredData, ...state.nearMiss.filteredData].forEach(row => {
        const site = row.site || 'Unknown';
        if (!siteData[site]) {
            siteData[site] = {
                name: site,
                incidents: 0,
                injuries: 0,
                nearMisses: 0,
                highSeverity: 0,
                totalRisk: 0
            };
        }
        
        siteData[site].incidents++;
        if (row.case_number) {
            siteData[site].injuries++;
        } else {
            siteData[site].nearMisses++;
        }
        
        if (row.severity === 'A' || row.severity === 'B') {
            siteData[site].highSeverity++;
        }
        
        const risk = row.risk ? parseFloat(row.risk) : calculateRiskScore(row);
        siteData[site].totalRisk += parseFloat(risk);
    });
    
    return Object.values(siteData)
        .map(site => ({
            ...site,
            riskScore: site.incidents > 0 ? site.totalRisk / site.incidents : 0,
            status: site.highSeverity > 2 ? 'üî¥ Critical' : 
                   site.highSeverity > 0 ? 'üü° Warning' : 
                   'üü¢ Good'
        }))
        .sort((a, b) => b.riskScore - a.riskScore);
}

function addToReportHistory(type, fileName) {
    const historyContainer = document.getElementById('reportHistory');
    if (!historyContainer) return;
    
    const timestamp = new Date().toLocaleString();
    const reportEntry = `
        <div style="padding: 1rem; border-bottom: 1px solid var(--bg-secondary);">
            <strong>${fileName}</strong><br>
            <span style="color: var(--text-secondary); font-size: 0.9rem;">
                Type: ${type.charAt(0).toUpperCase() + type.slice(1)} | Generated: ${timestamp}
            </span>
        </div>
    `;
    
    if (historyContainer.innerHTML.includes('No reports generated yet')) {
        historyContainer.innerHTML = reportEntry;
    } else {
        historyContainer.innerHTML = reportEntry + historyContainer.innerHTML;
    }
}

// Load Sample Data
function loadSampleData() {
    showStatus('Loading sample data...', 'info');
    
    // Sample injury data
    const sampleInjuryData = generateSampleInjuryData();
    state.injury.rawData = sampleInjuryData;
    processInjuryData();
    populateInjuryFilters();
    applyFilters('injury');
    calculateQualityMetrics('injury');
    
    // Sample near miss data
    const sampleNearMissData = generateSampleNearMissData();
    state.nearMiss.rawData = sampleNearMissData;
    processNearMissData();
    populateNearMissFilters();
    applyFilters('nearmiss');
    calculateQualityMetrics('nearmiss');
    
    updateOverview();
    initializeChartSelections();
    showStatus('Sample data loaded successfully!', 'success');
}

function generateSampleInjuryData() {
    const sites = ['VIE1', 'VIE2', 'VIE3', 'VIE4', 'VIE5'];
    const bodyParts = ['Back', 'Hand', 'Shoulder', 'Knee', 'Ankle', 'Wrist', 'Finger', 'Eye'];
    const types = ['Strain/Sprain', 'Cut/Laceration', 'Contusion', 'Fracture', 'Burn'];
    const severities = ['A', 'B', 'C', 'D'];
    const rootCauses = ['Manual Handling', 'Slip/Trip/Fall', 'Equipment Malfunction', 'Ergonomic', 'Process Deviation'];
    const processes = ['Stow', 'Pick', 'Pack', 'Receive', 'Ship', 'ICQA'];
    
    const data = [];
    const startDate = new Date('2024-01-01');
    
    for (let i = 0; i < 50; i++) {
        const date = new Date(startDate);
        date.setDate(date.getDate() + Math.floor(Math.random() * 365));
        
        const severity = severities[Math.floor(Math.random() * severities.length)];
        const isRecordable = severity === 'A' || severity === 'B' || Math.random() > 0.7;
        const dafwDays = isRecordable && Math.random() > 0.5 ? Math.floor(Math.random() * 30) : 0;
        
        data.push({
            case_number: `CASE-2024-${String(i + 1).padStart(3, '0')}`,
            incident_date: date.toISOString().split('T')[0],
            incident_time: `${Math.floor(Math.random() * 24).toString().padStart(2, '0')}:${Math.floor(Math.random() * 60).toString().padStart(2, '0')}`,
            site: sites[Math.floor(Math.random() * sites.length)],
            initial_info_principal_body_part: bodyParts[Math.floor(Math.random() * bodyParts.length)],
            type: types[Math.floor(Math.random() * types.length)],
            severity: severity,
            potential_severity: severity,
            recordable: isRecordable ? 1 : 0,
            initial_info_incident_on_the_road: Math.random() > 0.9,
            total_dafw_days: dafwDays,
            total_rwa_days: isRecordable && Math.random() > 0.8 ? Math.floor(Math.random() * 10) : 0,
            rca_primary_cause: rootCauses[Math.floor(Math.random() * rootCauses.length)],
            rca_contributing_factor_category: 'Human Factors',
            initial_info_process_path: processes[Math.floor(Math.random() * processes.length)],
            initial_info_incident_description: 'Sample incident description for demonstration purposes',
            status: 'Closed',
            austin_url: `https://safety.amazon.com/austin/case-${i + 1}`,
            initial_risk_assessment_likeliness: ['Rare', 'Unlikely', 'Possible', 'Likely', 'Almost Certain'][Math.floor(Math.random() * 5)]
        });
    }
    
    return data;
}

function generateSampleNearMissData() {
    const sites = ['VIE1', 'VIE2', 'VIE3', 'VIE4', 'VIE5'];
    const locations = ['Dock Door 1', 'Aisle P-1-A', 'Break Room', 'Parking Lot', 'Conveyor Belt 3', 'Mezzanine Level 2'];
    const impacts = ['Struck By', 'Caught Between', 'Fall', 'Ergonomic', 'Environmental'];
    const severities = ['A', 'B', 'C', 'D'];
    const likelihoods = ['Rare', 'Unlikely', 'Possible', 'Likely', 'Almost Certain'];
    const processes = ['Stow', 'Pick', 'Pack', 'Receive', 'Ship', 'ICQA'];
    
    const data = [];
    const startDate = new Date('2024-01-01');
    
    for (let i = 0; i < 100; i++) {
        const date = new Date(startDate);
        date.setDate(date.getDate() + Math.floor(Math.random() * 365));
        
        const severity = severities[Math.floor(Math.random() * severities.length)];
        const likelihood = likelihoods[Math.floor(Math.random() * likelihoods.length)];
        
        data.push({
            incident_id: `NM-${sites[i % sites.length]}-2024-${String(i + 1).padStart(3, '0')}`,
            nearmiss_date: date.toISOString().split('T')[0],
            site: sites[Math.floor(Math.random() * sites.length)],
            initial_info_location_event: locations[Math.floor(Math.random() * locations.length)],
            initial_info_process_path: processes[Math.floor(Math.random() * processes.length)],
            initial_info_primary_impact: impacts[Math.floor(Math.random() * impacts.length)],
            potential_severity: severity,
            initial_risk_assessment_likeliness: likelihood,
            risk: calculateRiskScore({ severity, standardized_likelihood: likelihood }),
            rca_contributing_factor_category: 'Environmental Factors',
            initial_info_incident_description: 'Sample near miss description for demonstration purposes',
            rca_primary_cause: 'Hazardous Condition',
            status: 'Closed'
        });
    }
    
    return data;
}

// Refresh Dashboard
function refreshDashboard(type) {
    showStatus('Refreshing dashboard...', 'info');
    
    if (type === 'injury') {
        updateInjuryDashboard();
        updateInjuryTable();
        updateInjuryCharts();
    } else if (type === 'nearmiss') {
        updateNearMissDashboard();
        updateNearMissTable();
        updateNearMissCharts();
    }
    
    updateOverview();
    updateKPIs();
    
    setTimeout(() => {
        showStatus('Dashboard refreshed!', 'success');
    }, 500);
}

// Update All Charts (for theme change)
function updateAllCharts() {
    // Update all injury charts
    if (state.injury.filteredData.length > 0) {
        updateInjuryCharts();
        updateInjuryAdvancedAnalytics();
    }
    
    // Update all near miss charts
    if (state.nearMiss.filteredData.length > 0) {
        updateNearMissCharts();
        updateNearMissAdvancedAnalytics();
    }
    
    // Update overview charts
    updateOverviewCharts();
    
    // Update combined charts
    if (state.currentModule === 'combined') {
        updateCombinedCharts();
    }
}

// Status Messages
function showStatus(message, type = 'info') {
    const container = document.getElementById('statusContainer');
    if (!container) return;
    
    const statusDiv = document.createElement('div');
    statusDiv.className = `status-message status-${type}`;
    
    const icon = type === 'success' ? '‚úÖ' : 
                type === 'error' ? '‚ùå' : 
                type === 'warning' ? '‚ö†Ô∏è' : '‚ÑπÔ∏è';
    
    statusDiv.innerHTML = `
        <span>${icon}</span>
        <span>${message}</span>
    `;
    
    container.appendChild(statusDiv);
    
    setTimeout(() => {
        statusDiv.style.opacity = '0';
        setTimeout(() => {
            statusDiv.remove();
        }, 300);
    }, 3000);
}

// Event Listeners
function setupEventListeners() {
    // Close modal when clicking outside
    window.onclick = function(event) {
        const modal = document.getElementById('detailModal');
        if (event.target === modal) {
            closeModal();
        }
    };
    
    // Keyboard shortcuts
    document.addEventListener('keydown', function(event) {
        // Ctrl/Cmd + S to save/export
        if ((event.ctrlKey || event.metaKey) && event.key === 's') {
            event.preventDefault();
            exportToExcel('all');
        }
        
        // Escape to close modal
        if (event.key === 'Escape') {
            closeModal();
        }
        
        // Ctrl/Cmd + P to generate PDF
        if ((event.ctrlKey || event.metaKey) && event.key === 'p') {
            event.preventDefault();
            generatePDFReport('combined');
        }
    });
    
    // Window resize handler
    let resizeTimeout;
    window.addEventListener('resize', function() {
        clearTimeout(resizeTimeout);
        resizeTimeout = setTimeout(function() {
            // Update charts on resize
            Chart.helpers.each(Chart.instances, function(instance) {
                instance.resize();
            });
        }, 250);
    });
    
    // Print handler
    window.addEventListener('beforeprint', function() {
        // Add print-specific classes
        document.body.classList.add('printing');
    });
    
    window.addEventListener('afterprint', function() {
        // Remove print-specific classes
        document.body.classList.remove('printing');
    });
}

// Initialize tooltips and other UI enhancements
document.addEventListener('DOMContentLoaded', function() {
    // Add smooth scroll behavior
    document.documentElement.style.scrollBehavior = 'smooth';
    
    // Initialize any additional UI components
    initializeUIComponents();
});

function initializeUIComponents() {
    // Add loading animation to buttons
    document.querySelectorAll('.btn').forEach(button => {
        button.addEventListener('click', function() {
            if (!this.classList.contains('loading')) {
                this.classList.add('loading');
                setTimeout(() => {
                    this.classList.remove('loading');
                }, 1000);
            }
        });
    });
    
    // Add hover effects to metric cards
    document.querySelectorAll('.metric-card').forEach(card => {
        card.addEventListener('mouseenter', function() {
            this.style.transform = 'translateY(-4px) scale(1.02)';
        });
        
        card.addEventListener('mouseleave', function() {
            this.style.transform = 'translateY(0) scale(1)';
        });
    });
}

// Utility function to format dates
function formatDate(date) {
    if (!date) return 'N/A';
    const d = new Date(date);
    if (isNaN(d)) return 'N/A';
    return d.toLocaleDateString('en-GB');
}

// Utility function to format numbers
function formatNumber(num) {
    if (num === null || num === undefined) return '0';
    return num.toLocaleString();
}

// Export individual functions for module pattern
window.SafetyAnalytics = {
    loadSampleData,
    exportToExcel,
    generatePDFReport,
    refreshDashboard,
    switchModule,
    toggleTheme
};

// Expose functions globally for inline event handlers
// Without these assignments, functions defined in this script are not available
// on the global window object when called directly from HTML attributes like
// onclick="switchModule('injury')". Explicitly attach them to window to
// prevent ReferenceError exceptions when the page loads. Only functions
// referenced directly in HTML markup are exposed below.
window.switchModule = switchModule;
window.toggleTheme = toggleTheme;
window.loadSampleData = loadSampleData;
window.exportToExcel = exportToExcel;
window.generatePDFReport = generatePDFReport;
window.refreshDashboard = refreshDashboard;
// Functions used by various buttons and interactions
window.addNewAction = addNewAction;
window.changePage = changePage;
window.changeTimelinePage = changeTimelinePage;
window.closeModal = closeModal;
window.exportChart = exportChart;
window.exportDashboard = exportDashboard;
window.exportInjuryData = exportInjuryData;
window.exportNearMissData = exportNearMissData;
window.exportTable = exportTable;
window.markActionComplete = markActionComplete;
window.switchInjuryView = switchInjuryView;
window.switchNearMissView = switchNearMissView;
window.viewDetails = viewDetails;
window.showDuplicateDetails = showDuplicateDetails;
window.showAllDuplicates = showAllDuplicates;
window.mergeDuplicateGroup = mergeDuplicateGroup;

// Expose combined filter handler so it can be invoked from the HTML
window.applyCombinedFilters = applyCombinedFilters;

// Log initialization complete
console.log('Safety Analytics Platform initialized successfully');
console.log('Version: 2.0 | ¬© 2024 Amazon WHS Austria');
console.log('For support, contact: Erwin Esener @eeesener');
 </script>
